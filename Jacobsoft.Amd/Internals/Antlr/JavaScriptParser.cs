//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 JavaScript.g 2012-07-28 13:15:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Jacobsoft.Amd.Internals.AntlrGenerated 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
 internal  partial class JavaScriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGNMENT", "CALLEXPR", "CharacterEscapeSequence", "Comment", "DecimalDigit", "DecimalLiteral", "DoubleStringCharacter", "EscapeCharacter", "EscapeSequence", "ExponentPart", "FORSTMTCOND", "FORSTMTINCR", "FORSTMTINIT", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "INDEXEXPR", "Identifier", "IdentifierPart", "IdentifierStart", "LT", "LineComment", "NonEscapeCharacter", "NumericLiteral", "PROGRAM", "PROPEXPR", "SingleEscapeCharacter", "SingleStringCharacter", "StringLiteral", "UnicodeCombiningMark", "UnicodeConnectorPunctuation", "UnicodeDigit", "UnicodeEscapeSequence", "UnicodeLetter", "VARIABLEDECL", "WhiteSpace", "'!'", "'!='", "'!=='", "'%'", "'%='", "'&&'", "'&'", "'&='", "'('", "')'", "'*'", "'*='", "'+'", "'++'", "'+='", "','", "'-'", "'--'", "'-='", "'.'", "'/'", "'/='", "':'", "';'", "'<'", "'<<'", "'<<='", "'<='", "'='", "'=='", "'==='", "'>'", "'>='", "'>>'", "'>>='", "'>>>'", "'>>>='", "'?'", "'['", "']'", "'^'", "'^='", "'break'", "'case'", "'catch'", "'continue'", "'default'", "'delete'", "'do'", "'else'", "'false'", "'finally'", "'for'", "'function'", "'if'", "'in'", "'instanceof'", "'new'", "'null'", "'return'", "'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'var'", "'void'", "'while'", "'with'", "'{'", "'|'", "'|='", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int ASSIGNMENT=4;
	public const int CALLEXPR=5;
	public const int CharacterEscapeSequence=6;
	public const int Comment=7;
	public const int DecimalDigit=8;
	public const int DecimalLiteral=9;
	public const int DoubleStringCharacter=10;
	public const int EscapeCharacter=11;
	public const int EscapeSequence=12;
	public const int ExponentPart=13;
	public const int FORSTMTCOND=14;
	public const int FORSTMTINCR=15;
	public const int FORSTMTINIT=16;
	public const int HexDigit=17;
	public const int HexEscapeSequence=18;
	public const int HexIntegerLiteral=19;
	public const int INDEXEXPR=20;
	public const int Identifier=21;
	public const int IdentifierPart=22;
	public const int IdentifierStart=23;
	public const int LT=24;
	public const int LineComment=25;
	public const int NonEscapeCharacter=26;
	public const int NumericLiteral=27;
	public const int PROGRAM=28;
	public const int PROPEXPR=29;
	public const int SingleEscapeCharacter=30;
	public const int SingleStringCharacter=31;
	public const int StringLiteral=32;
	public const int UnicodeCombiningMark=33;
	public const int UnicodeConnectorPunctuation=34;
	public const int UnicodeDigit=35;
	public const int UnicodeEscapeSequence=36;
	public const int UnicodeLetter=37;
	public const int VARIABLEDECL=38;
	public const int WhiteSpace=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;
	public const int T__96=96;
	public const int T__97=97;
	public const int T__98=98;
	public const int T__99=99;
	public const int T__100=100;
	public const int T__101=101;
	public const int T__102=102;
	public const int T__103=103;
	public const int T__104=104;
	public const int T__105=105;
	public const int T__106=106;
	public const int T__107=107;
	public const int T__108=108;
	public const int T__109=109;
	public const int T__110=110;
	public const int T__111=111;
	public const int T__112=112;
	public const int T__113=113;
	public const int T__114=114;
	public const int T__115=115;

	public JavaScriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[381+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return JavaScriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "JavaScript.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// JavaScript.g:35:8: public program : ( LT )* sourceElements ( LT )* EOF -> ^( PROGRAM sourceElements ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int program_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT1 = default(IToken);
		IToken LT3 = default(IToken);
		IToken EOF4 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElements2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT1_tree = default(CommonTree);
		CommonTree LT3_tree = default(CommonTree);
		CommonTree EOF4_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_sourceElements=new RewriteRuleSubtreeStream(adaptor,"rule sourceElements");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(35, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// JavaScript.g:36:2: ( ( LT )* sourceElements ( LT )* EOF -> ^( PROGRAM sourceElements ) )
			DebugEnterAlt(1);
			// JavaScript.g:36:4: ( LT )* sourceElements ( LT )* EOF
			{
			DebugLocation(36, 4);
			// JavaScript.g:36:4: ( LT )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==LT))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:36:4: LT
					{
					DebugLocation(36, 4);
					LT1=(IToken)Match(input,LT,Follow._LT_in_program129); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT1);


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(36, 8);
			PushFollow(Follow._sourceElements_in_program132);
			sourceElements2=sourceElements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sourceElements.Add(sourceElements2.Tree);
			DebugLocation(36, 23);
			// JavaScript.g:36:23: ( LT )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==LT))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:36:23: LT
					{
					DebugLocation(36, 23);
					LT3=(IToken)Match(input,LT,Follow._LT_in_program134); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT3);


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(36, 27);
			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_program137); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF4);



			{
			// AST REWRITE
			// elements: sourceElements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 36:31: -> ^( PROGRAM sourceElements )
			{
				DebugLocation(36, 34);
				// JavaScript.g:36:34: ^( PROGRAM sourceElements )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(36, 36);
				root_1 = (CommonTree)adaptor.BecomeRoot(new Program(PROGRAM), root_1);

				DebugLocation(36, 58);
				adaptor.AddChild(root_1, stream_sourceElements.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
			if (state.backtracking > 0) { Memoize(input, 1, program_StartIndex); }

		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_sourceElements();
	partial void LeaveRule_sourceElements();
	// $ANTLR start "sourceElements"
	// JavaScript.g:39:1: sourceElements : sourceElement ( ( LT )* sourceElement )* -> ( sourceElement )+ ;
	[GrammarRule("sourceElements")]
	private AstParserRuleReturnScope<CommonTree, IToken> sourceElements()
	{
		EnterRule_sourceElements();
		EnterRule("sourceElements", 2);
		TraceIn("sourceElements", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sourceElements_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT6 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElement5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElement7 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT6_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_sourceElement=new RewriteRuleSubtreeStream(adaptor,"rule sourceElement");
		try { DebugEnterRule(GrammarFileName, "sourceElements");
		DebugLocation(39, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// JavaScript.g:40:2: ( sourceElement ( ( LT )* sourceElement )* -> ( sourceElement )+ )
			DebugEnterAlt(1);
			// JavaScript.g:40:4: sourceElement ( ( LT )* sourceElement )*
			{
			DebugLocation(40, 4);
			PushFollow(Follow._sourceElement_in_sourceElements162);
			sourceElement5=sourceElement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sourceElement.Add(sourceElement5.Tree);
			DebugLocation(40, 18);
			// JavaScript.g:40:18: ( ( LT )* sourceElement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				try
				{
					alt4 = dfa4.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:40:19: ( LT )* sourceElement
					{
					DebugLocation(40, 19);
					// JavaScript.g:40:19: ( LT )*
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_1 = input.LA(1);

						if ((LA3_1==LT))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch ( alt3 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:40:19: LT
							{
							DebugLocation(40, 19);
							LT6=(IToken)Match(input,LT,Follow._LT_in_sourceElements165); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT6);


							}
							break;

						default:
							goto loop3;
						}
					}

					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(40, 23);
					PushFollow(Follow._sourceElement_in_sourceElements168);
					sourceElement7=sourceElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_sourceElement.Add(sourceElement7.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }



			{
			// AST REWRITE
			// elements: sourceElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 40:39: -> ( sourceElement )+
			{
				DebugLocation(40, 42);
				if (!(stream_sourceElement.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_sourceElement.HasNext )
				{
					DebugLocation(40, 42);
					adaptor.AddChild(root_0, stream_sourceElement.NextTree());

				}
				stream_sourceElement.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElements", 2);
			LeaveRule("sourceElements", 2);
			LeaveRule_sourceElements();
			if (state.backtracking > 0) { Memoize(input, 2, sourceElements_StartIndex); }

		}
		DebugLocation(41, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElements"); }
		return retval;

	}
	// $ANTLR end "sourceElements"

	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();
	// $ANTLR start "sourceElement"
	// JavaScript.g:43:1: sourceElement : ( functionDeclaration | statement );
	[GrammarRule("sourceElement")]
	private AstParserRuleReturnScope<CommonTree, IToken> sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 3);
		TraceIn("sourceElement", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sourceElement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> functionDeclaration8 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement9 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(43, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// JavaScript.g:44:2: ( functionDeclaration | statement )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==93))
			{
				int LA5_2 = input.LA(2);

				if ((EvaluatePredicate(synpred5_JavaScript_fragment)))
				{
					alt5 = 1;
				}
				else if ((true))
				{
					alt5 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA5_1==Identifier||LA5_1==NumericLiteral||LA5_1==StringLiteral||LA5_1==40||LA5_1==48||(LA5_1>=52 && LA5_1<=53)||(LA5_1>=56 && LA5_1<=57)||LA5_1==63||LA5_1==78||LA5_1==82||LA5_1==85||(LA5_1>=87 && LA5_1<=88)||LA5_1==90||LA5_1==92||LA5_1==94||(LA5_1>=97 && LA5_1<=110)||LA5_1==115))
			{
				alt5 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:44:4: functionDeclaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(44, 4);
				PushFollow(Follow._functionDeclaration_in_sourceElement187);
				functionDeclaration8=functionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:45:4: statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(45, 4);
				PushFollow(Follow._statement_in_sourceElement192);
				statement9=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement9.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElement", 3);
			LeaveRule("sourceElement", 3);
			LeaveRule_sourceElement();
			if (state.backtracking > 0) { Memoize(input, 3, sourceElement_StartIndex); }

		}
		DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return retval;

	}
	// $ANTLR end "sourceElement"

	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();
	// $ANTLR start "functionDeclaration"
	// JavaScript.g:49:1: functionDeclaration : 'function' ( LT )* Identifier ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' Identifier formalParameterList functionBody ) ;
	[GrammarRule("functionDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 4);
		TraceIn("functionDeclaration", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionDeclaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal10 = default(IToken);
		IToken LT11 = default(IToken);
		IToken Identifier12 = default(IToken);
		IToken LT13 = default(IToken);
		IToken LT15 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> formalParameterList14 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionBody16 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal10_tree = default(CommonTree);
		CommonTree LT11_tree = default(CommonTree);
		CommonTree Identifier12_tree = default(CommonTree);
		CommonTree LT13_tree = default(CommonTree);
		CommonTree LT15_tree = default(CommonTree);
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_formalParameterList=new RewriteRuleSubtreeStream(adaptor,"rule formalParameterList");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(49, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// JavaScript.g:50:2: ( 'function' ( LT )* Identifier ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' Identifier formalParameterList functionBody ) )
			DebugEnterAlt(1);
			// JavaScript.g:50:4: 'function' ( LT )* Identifier ( LT )* formalParameterList ( LT )* functionBody
			{
			DebugLocation(50, 4);
			string_literal10=(IToken)Match(input,93,Follow._93_in_functionDeclaration205); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_93.Add(string_literal10);

			DebugLocation(50, 15);
			// JavaScript.g:50:15: ( LT )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==LT))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:50:15: LT
					{
					DebugLocation(50, 15);
					LT11=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration207); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT11);


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(50, 19);
			Identifier12=(IToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration210); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier12);

			DebugLocation(50, 30);
			// JavaScript.g:50:30: ( LT )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LT))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:50:30: LT
					{
					DebugLocation(50, 30);
					LT13=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration212); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT13);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(50, 34);
			PushFollow(Follow._formalParameterList_in_functionDeclaration215);
			formalParameterList14=formalParameterList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_formalParameterList.Add(formalParameterList14.Tree);
			DebugLocation(50, 54);
			// JavaScript.g:50:54: ( LT )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==LT))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:50:54: LT
					{
					DebugLocation(50, 54);
					LT15=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration217); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT15);


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(50, 58);
			PushFollow(Follow._functionBody_in_functionDeclaration220);
			functionBody16=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody16.Tree);


			{
			// AST REWRITE
			// elements: 93, Identifier, formalParameterList, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 51:3: -> ^( 'function' Identifier formalParameterList functionBody )
			{
				DebugLocation(51, 6);
				// JavaScript.g:51:6: ^( 'function' Identifier formalParameterList functionBody )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FunctionDeclaration(stream_93.NextToken()), root_1);

				DebugLocation(52, 5);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(53, 5);
				adaptor.AddChild(root_1, stream_formalParameterList.NextTree());
				DebugLocation(54, 5);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionDeclaration", 4);
			LeaveRule("functionDeclaration", 4);
			LeaveRule_functionDeclaration();
			if (state.backtracking > 0) { Memoize(input, 4, functionDeclaration_StartIndex); }

		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return retval;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();
	// $ANTLR start "functionExpression"
	// JavaScript.g:57:1: functionExpression : 'function' ( LT )* ( Identifier )? ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' ( Identifier )? formalParameterList functionBody ) ;
	[GrammarRule("functionExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 5);
		TraceIn("functionExpression", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal17 = default(IToken);
		IToken LT18 = default(IToken);
		IToken Identifier19 = default(IToken);
		IToken LT20 = default(IToken);
		IToken LT22 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> formalParameterList21 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionBody23 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal17_tree = default(CommonTree);
		CommonTree LT18_tree = default(CommonTree);
		CommonTree Identifier19_tree = default(CommonTree);
		CommonTree LT20_tree = default(CommonTree);
		CommonTree LT22_tree = default(CommonTree);
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_formalParameterList=new RewriteRuleSubtreeStream(adaptor,"rule formalParameterList");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(57, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// JavaScript.g:58:2: ( 'function' ( LT )* ( Identifier )? ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' ( Identifier )? formalParameterList functionBody ) )
			DebugEnterAlt(1);
			// JavaScript.g:58:4: 'function' ( LT )* ( Identifier )? ( LT )* formalParameterList ( LT )* functionBody
			{
			DebugLocation(58, 4);
			string_literal17=(IToken)Match(input,93,Follow._93_in_functionExpression272); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_93.Add(string_literal17);

			DebugLocation(58, 15);
			// JavaScript.g:58:15: ( LT )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==LT))
				{
					int LA9_2 = input.LA(2);

					if ((EvaluatePredicate(synpred9_JavaScript_fragment)))
					{
						alt9 = 1;
					}


				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:58:15: LT
					{
					DebugLocation(58, 15);
					LT18=(IToken)Match(input,LT,Follow._LT_in_functionExpression274); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT18);


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(58, 19);
			// JavaScript.g:58:19: ( Identifier )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==Identifier))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:58:19: Identifier
				{
				DebugLocation(58, 19);
				Identifier19=(IToken)Match(input,Identifier,Follow._Identifier_in_functionExpression277); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier19);


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(58, 31);
			// JavaScript.g:58:31: ( LT )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==LT))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:58:31: LT
					{
					DebugLocation(58, 31);
					LT20=(IToken)Match(input,LT,Follow._LT_in_functionExpression280); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT20);


					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(58, 35);
			PushFollow(Follow._formalParameterList_in_functionExpression283);
			formalParameterList21=formalParameterList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_formalParameterList.Add(formalParameterList21.Tree);
			DebugLocation(58, 55);
			// JavaScript.g:58:55: ( LT )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==LT))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:58:55: LT
					{
					DebugLocation(58, 55);
					LT22=(IToken)Match(input,LT,Follow._LT_in_functionExpression285); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT22);


					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(58, 59);
			PushFollow(Follow._functionBody_in_functionExpression288);
			functionBody23=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody23.Tree);


			{
			// AST REWRITE
			// elements: 93, Identifier, formalParameterList, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 59:3: -> ^( 'function' ( Identifier )? formalParameterList functionBody )
			{
				DebugLocation(59, 6);
				// JavaScript.g:59:6: ^( 'function' ( Identifier )? formalParameterList functionBody )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(59, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FunctionExpression(stream_93.NextToken()), root_1);

				DebugLocation(60, 5);
				// JavaScript.g:60:5: ( Identifier )?
				if (stream_Identifier.HasNext)
				{
					DebugLocation(60, 5);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();
				DebugLocation(61, 5);
				adaptor.AddChild(root_1, stream_formalParameterList.NextTree());
				DebugLocation(62, 5);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionExpression", 5);
			LeaveRule("functionExpression", 5);
			LeaveRule_functionExpression();
			if (state.backtracking > 0) { Memoize(input, 5, functionExpression_StartIndex); }

		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return retval;

	}
	// $ANTLR end "functionExpression"

	partial void EnterRule_formalParameterList();
	partial void LeaveRule_formalParameterList();
	// $ANTLR start "formalParameterList"
	// JavaScript.g:65:1: formalParameterList : '(' ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )? ( LT )* ')' -> ^( '(' ( Identifier )* ) ;
	[GrammarRule("formalParameterList")]
	private AstParserRuleReturnScope<CommonTree, IToken> formalParameterList()
	{
		EnterRule_formalParameterList();
		EnterRule("formalParameterList", 6);
		TraceIn("formalParameterList", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int formalParameterList_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal24 = default(IToken);
		IToken LT25 = default(IToken);
		IToken Identifier26 = default(IToken);
		IToken LT27 = default(IToken);
		IToken char_literal28 = default(IToken);
		IToken LT29 = default(IToken);
		IToken Identifier30 = default(IToken);
		IToken LT31 = default(IToken);
		IToken char_literal32 = default(IToken);

		CommonTree char_literal24_tree = default(CommonTree);
		CommonTree LT25_tree = default(CommonTree);
		CommonTree Identifier26_tree = default(CommonTree);
		CommonTree LT27_tree = default(CommonTree);
		CommonTree char_literal28_tree = default(CommonTree);
		CommonTree LT29_tree = default(CommonTree);
		CommonTree Identifier30_tree = default(CommonTree);
		CommonTree LT31_tree = default(CommonTree);
		CommonTree char_literal32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		try { DebugEnterRule(GrammarFileName, "formalParameterList");
		DebugLocation(65, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// JavaScript.g:66:2: ( '(' ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )? ( LT )* ')' -> ^( '(' ( Identifier )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:66:4: '(' ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )? ( LT )* ')'
			{
			DebugLocation(66, 4);
			char_literal24=(IToken)Match(input,48,Follow._48_in_formalParameterList337); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal24);

			DebugLocation(66, 8);
			// JavaScript.g:66:8: ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			try
			{
				alt17 = dfa17.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:66:9: ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )*
				{
				DebugLocation(66, 9);
				// JavaScript.g:66:9: ( LT )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==LT))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:66:9: LT
						{
						DebugLocation(66, 9);
						LT25=(IToken)Match(input,LT,Follow._LT_in_formalParameterList340); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT25);


						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(66, 13);
				Identifier26=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList343); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier26);

				DebugLocation(66, 24);
				// JavaScript.g:66:24: ( ( LT )* ',' ( LT )* Identifier )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					try
					{
						alt16 = dfa16.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:66:25: ( LT )* ',' ( LT )* Identifier
						{
						DebugLocation(66, 25);
						// JavaScript.g:66:25: ( LT )*
						try { DebugEnterSubRule(14);
						while (true)
						{
							int alt14=2;
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if ((LA14_1==LT))
							{
								alt14 = 1;
							}


							} finally { DebugExitDecision(14); }
							switch ( alt14 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:66:25: LT
								{
								DebugLocation(66, 25);
								LT27=(IToken)Match(input,LT,Follow._LT_in_formalParameterList346); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT27);


								}
								break;

							default:
								goto loop14;
							}
						}

						loop14:
							;

						} finally { DebugExitSubRule(14); }

						DebugLocation(66, 29);
						char_literal28=(IToken)Match(input,55,Follow._55_in_formalParameterList349); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal28);

						DebugLocation(66, 33);
						// JavaScript.g:66:33: ( LT )*
						try { DebugEnterSubRule(15);
						while (true)
						{
							int alt15=2;
							try { DebugEnterDecision(15, false);
							int LA15_1 = input.LA(1);

							if ((LA15_1==LT))
							{
								alt15 = 1;
							}


							} finally { DebugExitDecision(15); }
							switch ( alt15 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:66:33: LT
								{
								DebugLocation(66, 33);
								LT29=(IToken)Match(input,LT,Follow._LT_in_formalParameterList351); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT29);


								}
								break;

							default:
								goto loop15;
							}
						}

						loop15:
							;

						} finally { DebugExitSubRule(15); }

						DebugLocation(66, 37);
						Identifier30=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList354); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_Identifier.Add(Identifier30);


						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(66, 52);
			// JavaScript.g:66:52: ( LT )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==LT))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:66:52: LT
					{
					DebugLocation(66, 52);
					LT31=(IToken)Match(input,LT,Follow._LT_in_formalParameterList360); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT31);


					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(66, 56);
			char_literal32=(IToken)Match(input,49,Follow._49_in_formalParameterList363); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal32);



			{
			// AST REWRITE
			// elements: 48, Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 67:3: -> ^( '(' ( Identifier )* )
			{
				DebugLocation(67, 6);
				// JavaScript.g:67:6: ^( '(' ( Identifier )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(67, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FormalParameterList(stream_48.NextToken()), root_1);

				DebugLocation(67, 38);
				// JavaScript.g:67:38: ( Identifier )*
				while ( stream_Identifier.HasNext )
				{
					DebugLocation(67, 38);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalParameterList", 6);
			LeaveRule("formalParameterList", 6);
			LeaveRule_formalParameterList();
			if (state.backtracking > 0) { Memoize(input, 6, formalParameterList_StartIndex); }

		}
		DebugLocation(68, 1);
		} finally { DebugExitRule(GrammarFileName, "formalParameterList"); }
		return retval;

	}
	// $ANTLR end "formalParameterList"

	partial void EnterRule_functionBody();
	partial void LeaveRule_functionBody();
	// $ANTLR start "functionBody"
	// JavaScript.g:70:1: functionBody : '{' ( LT )* sourceElements ( LT )* '}' -> ^( '{' sourceElements ) ;
	[GrammarRule("functionBody")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionBody()
	{
		EnterRule_functionBody();
		EnterRule("functionBody", 7);
		TraceIn("functionBody", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionBody_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal33 = default(IToken);
		IToken LT34 = default(IToken);
		IToken LT36 = default(IToken);
		IToken char_literal37 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElements35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal33_tree = default(CommonTree);
		CommonTree LT34_tree = default(CommonTree);
		CommonTree LT36_tree = default(CommonTree);
		CommonTree char_literal37_tree = default(CommonTree);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_sourceElements=new RewriteRuleSubtreeStream(adaptor,"rule sourceElements");
		try { DebugEnterRule(GrammarFileName, "functionBody");
		DebugLocation(70, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// JavaScript.g:71:2: ( '{' ( LT )* sourceElements ( LT )* '}' -> ^( '{' sourceElements ) )
			DebugEnterAlt(1);
			// JavaScript.g:71:4: '{' ( LT )* sourceElements ( LT )* '}'
			{
			DebugLocation(71, 4);
			char_literal33=(IToken)Match(input,110,Follow._110_in_functionBody395); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_110.Add(char_literal33);

			DebugLocation(71, 8);
			// JavaScript.g:71:8: ( LT )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==LT))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:71:8: LT
					{
					DebugLocation(71, 8);
					LT34=(IToken)Match(input,LT,Follow._LT_in_functionBody397); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT34);


					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(71, 12);
			PushFollow(Follow._sourceElements_in_functionBody400);
			sourceElements35=sourceElements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sourceElements.Add(sourceElements35.Tree);
			DebugLocation(71, 27);
			// JavaScript.g:71:27: ( LT )*
			try { DebugEnterSubRule(20);
			while (true)
			{
				int alt20=2;
				try { DebugEnterDecision(20, false);
				int LA20_1 = input.LA(1);

				if ((LA20_1==LT))
				{
					alt20 = 1;
				}


				} finally { DebugExitDecision(20); }
				switch ( alt20 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:71:27: LT
					{
					DebugLocation(71, 27);
					LT36=(IToken)Match(input,LT,Follow._LT_in_functionBody402); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT36);


					}
					break;

				default:
					goto loop20;
				}
			}

			loop20:
				;

			} finally { DebugExitSubRule(20); }

			DebugLocation(71, 31);
			char_literal37=(IToken)Match(input,114,Follow._114_in_functionBody405); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_114.Add(char_literal37);



			{
			// AST REWRITE
			// elements: 110, sourceElements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 71:35: -> ^( '{' sourceElements )
			{
				DebugLocation(71, 38);
				// JavaScript.g:71:38: ^( '{' sourceElements )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(71, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FunctionBody(stream_110.NextToken()), root_1);

				DebugLocation(71, 63);
				adaptor.AddChild(root_1, stream_sourceElements.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionBody", 7);
			LeaveRule("functionBody", 7);
			LeaveRule_functionBody();
			if (state.backtracking > 0) { Memoize(input, 7, functionBody_StartIndex); }

		}
		DebugLocation(72, 1);
		} finally { DebugExitRule(GrammarFileName, "functionBody"); }
		return retval;

	}
	// $ANTLR end "functionBody"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// JavaScript.g:75:1: statement : ( statementBlock | variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> statementBlock38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableStatement39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> emptyStatement40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expressionStatement41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement42 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> iterationStatement43 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> continueStatement44 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> breakStatement45 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> returnStatement46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> withStatement47 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> labelledStatement48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> switchStatement49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> throwStatement50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> tryStatement51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(75, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// JavaScript.g:76:2: ( statementBlock | variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement )
			int alt21=14;
			try { DebugEnterDecision(21, false);
			switch (input.LA(1))
			{
			case 110:
				{
				int LA21_2 = input.LA(2);

				if ((EvaluatePredicate(synpred21_JavaScript_fragment)))
				{
					alt21 = 1;
				}
				else if ((EvaluatePredicate(synpred24_JavaScript_fragment)))
				{
					alt21 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 106:
				{
				alt21 = 2;
				}
				break;
			case 63:
				{
				alt21 = 3;
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 40:
			case 48:
			case 52:
			case 53:
			case 56:
			case 57:
			case 78:
			case 87:
			case 90:
			case 93:
			case 97:
			case 98:
			case 101:
			case 103:
			case 105:
			case 107:
			case 115:
				{
				alt21 = 4;
				}
				break;
			case Identifier:
				{
				int LA21_2 = input.LA(2);

				if ((EvaluatePredicate(synpred24_JavaScript_fragment)))
				{
					alt21 = 4;
				}
				else if ((EvaluatePredicate(synpred31_JavaScript_fragment)))
				{
					alt21 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 94:
				{
				alt21 = 5;
				}
				break;
			case 88:
			case 92:
			case 108:
				{
				alt21 = 6;
				}
				break;
			case 85:
				{
				alt21 = 7;
				}
				break;
			case 82:
				{
				alt21 = 8;
				}
				break;
			case 99:
				{
				alt21 = 9;
				}
				break;
			case 109:
				{
				alt21 = 10;
				}
				break;
			case 100:
				{
				alt21 = 12;
				}
				break;
			case 102:
				{
				alt21 = 13;
				}
				break;
			case 104:
				{
				alt21 = 14;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 21, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:76:4: statementBlock
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(76, 4);
				PushFollow(Follow._statementBlock_in_statement430);
				statementBlock38=statementBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementBlock38.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:77:4: variableStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(77, 4);
				PushFollow(Follow._variableStatement_in_statement435);
				variableStatement39=variableStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement39.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:78:4: emptyStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(78, 4);
				PushFollow(Follow._emptyStatement_in_statement440);
				emptyStatement40=emptyStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, emptyStatement40.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:79:4: expressionStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(79, 4);
				PushFollow(Follow._expressionStatement_in_statement445);
				expressionStatement41=expressionStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionStatement41.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:80:4: ifStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(80, 4);
				PushFollow(Follow._ifStatement_in_statement450);
				ifStatement42=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement42.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:81:4: iterationStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(81, 4);
				PushFollow(Follow._iterationStatement_in_statement455);
				iterationStatement43=iterationStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, iterationStatement43.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// JavaScript.g:82:4: continueStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(82, 4);
				PushFollow(Follow._continueStatement_in_statement460);
				continueStatement44=continueStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement44.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// JavaScript.g:83:4: breakStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._breakStatement_in_statement465);
				breakStatement45=breakStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement45.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// JavaScript.g:84:4: returnStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._returnStatement_in_statement470);
				returnStatement46=returnStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement46.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// JavaScript.g:85:4: withStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(85, 4);
				PushFollow(Follow._withStatement_in_statement475);
				withStatement47=withStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement47.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// JavaScript.g:86:4: labelledStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(86, 4);
				PushFollow(Follow._labelledStatement_in_statement480);
				labelledStatement48=labelledStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, labelledStatement48.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// JavaScript.g:87:4: switchStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._switchStatement_in_statement485);
				switchStatement49=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement49.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// JavaScript.g:88:4: throwStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._throwStatement_in_statement490);
				throwStatement50=throwStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement50.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// JavaScript.g:89:4: tryStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._tryStatement_in_statement495);
				tryStatement51=tryStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement51.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
			if (state.backtracking > 0) { Memoize(input, 8, statement_StartIndex); }

		}
		DebugLocation(90, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_statementBlock();
	partial void LeaveRule_statementBlock();
	// $ANTLR start "statementBlock"
	// JavaScript.g:92:1: statementBlock : '{' ( LT )* ( statementList )? ( LT )* '}' -> ^( '{' ( statementList )? ) ;
	[GrammarRule("statementBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> statementBlock()
	{
		EnterRule_statementBlock();
		EnterRule("statementBlock", 9);
		TraceIn("statementBlock", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statementBlock_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal52 = default(IToken);
		IToken LT53 = default(IToken);
		IToken LT55 = default(IToken);
		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementList54 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal52_tree = default(CommonTree);
		CommonTree LT53_tree = default(CommonTree);
		CommonTree LT55_tree = default(CommonTree);
		CommonTree char_literal56_tree = default(CommonTree);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_statementList=new RewriteRuleSubtreeStream(adaptor,"rule statementList");
		try { DebugEnterRule(GrammarFileName, "statementBlock");
		DebugLocation(92, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// JavaScript.g:93:2: ( '{' ( LT )* ( statementList )? ( LT )* '}' -> ^( '{' ( statementList )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:93:4: '{' ( LT )* ( statementList )? ( LT )* '}'
			{
			DebugLocation(93, 4);
			char_literal52=(IToken)Match(input,110,Follow._110_in_statementBlock507); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_110.Add(char_literal52);

			DebugLocation(93, 8);
			// JavaScript.g:93:8: ( LT )*
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_1 = input.LA(1);

				if ((LA22_1==LT))
				{
					int LA22_2 = input.LA(2);

					if ((EvaluatePredicate(synpred34_JavaScript_fragment)))
					{
						alt22 = 1;
					}


				}


				} finally { DebugExitDecision(22); }
				switch ( alt22 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:93:8: LT
					{
					DebugLocation(93, 8);
					LT53=(IToken)Match(input,LT,Follow._LT_in_statementBlock509); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT53);


					}
					break;

				default:
					goto loop22;
				}
			}

			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(93, 12);
			// JavaScript.g:93:12: ( statementList )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_1 = input.LA(1);

			if ((LA23_1==Identifier||LA23_1==NumericLiteral||LA23_1==StringLiteral||LA23_1==40||LA23_1==48||(LA23_1>=52 && LA23_1<=53)||(LA23_1>=56 && LA23_1<=57)||LA23_1==63||LA23_1==78||LA23_1==82||LA23_1==85||(LA23_1>=87 && LA23_1<=88)||LA23_1==90||(LA23_1>=92 && LA23_1<=94)||(LA23_1>=97 && LA23_1<=110)||LA23_1==115))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:93:12: statementList
				{
				DebugLocation(93, 12);
				PushFollow(Follow._statementList_in_statementBlock512);
				statementList54=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statementList.Add(statementList54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }

			DebugLocation(93, 27);
			// JavaScript.g:93:27: ( LT )*
			try { DebugEnterSubRule(24);
			while (true)
			{
				int alt24=2;
				try { DebugEnterDecision(24, false);
				int LA24_1 = input.LA(1);

				if ((LA24_1==LT))
				{
					alt24 = 1;
				}


				} finally { DebugExitDecision(24); }
				switch ( alt24 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:93:27: LT
					{
					DebugLocation(93, 27);
					LT55=(IToken)Match(input,LT,Follow._LT_in_statementBlock515); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT55);


					}
					break;

				default:
					goto loop24;
				}
			}

			loop24:
				;

			} finally { DebugExitSubRule(24); }

			DebugLocation(93, 31);
			char_literal56=(IToken)Match(input,114,Follow._114_in_statementBlock518); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_114.Add(char_literal56);



			{
			// AST REWRITE
			// elements: 110, statementList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 93:35: -> ^( '{' ( statementList )? )
			{
				DebugLocation(93, 38);
				// JavaScript.g:93:38: ^( '{' ( statementList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(93, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(new StatementBlock(stream_110.NextToken()), root_1);

				DebugLocation(93, 65);
				// JavaScript.g:93:65: ( statementList )?
				if (stream_statementList.HasNext)
				{
					DebugLocation(93, 65);
					adaptor.AddChild(root_1, stream_statementList.NextTree());

				}
				stream_statementList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementBlock", 9);
			LeaveRule("statementBlock", 9);
			LeaveRule_statementBlock();
			if (state.backtracking > 0) { Memoize(input, 9, statementBlock_StartIndex); }

		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "statementBlock"); }
		return retval;

	}
	// $ANTLR end "statementBlock"

	partial void EnterRule_statementList();
	partial void LeaveRule_statementList();
	// $ANTLR start "statementList"
	// JavaScript.g:96:1: statementList : statement ( ( LT !)* statement )* ;
	[GrammarRule("statementList")]
	private AstParserRuleReturnScope<CommonTree, IToken> statementList()
	{
		EnterRule_statementList();
		EnterRule("statementList", 10);
		TraceIn("statementList", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statementList_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement57 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement59 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT58_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "statementList");
		DebugLocation(96, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// JavaScript.g:97:2: ( statement ( ( LT !)* statement )* )
			DebugEnterAlt(1);
			// JavaScript.g:97:4: statement ( ( LT !)* statement )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(97, 4);
			PushFollow(Follow._statement_in_statementList544);
			statement57=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement57.Tree);
			DebugLocation(97, 14);
			// JavaScript.g:97:14: ( ( LT !)* statement )*
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				try
				{
					alt26 = dfa26.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(26); }
				switch ( alt26 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:97:15: ( LT !)* statement
					{
					DebugLocation(97, 17);
					// JavaScript.g:97:17: ( LT !)*
					try { DebugEnterSubRule(25);
					while (true)
					{
						int alt25=2;
						try { DebugEnterDecision(25, false);
						int LA25_1 = input.LA(1);

						if ((LA25_1==LT))
						{
							alt25 = 1;
						}


						} finally { DebugExitDecision(25); }
						switch ( alt25 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:97:17: LT !
							{
							DebugLocation(97, 17);
							LT58=(IToken)Match(input,LT,Follow._LT_in_statementList547); if (state.failed) return retval;

							}
							break;

						default:
							goto loop25;
						}
					}

					loop25:
						;

					} finally { DebugExitSubRule(25); }

					DebugLocation(97, 20);
					PushFollow(Follow._statement_in_statementList551);
					statement59=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement59.Tree);

					}
					break;

				default:
					goto loop26;
				}
			}

			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementList", 10);
			LeaveRule("statementList", 10);
			LeaveRule_statementList();
			if (state.backtracking > 0) { Memoize(input, 10, statementList_StartIndex); }

		}
		DebugLocation(98, 1);
		} finally { DebugExitRule(GrammarFileName, "statementList"); }
		return retval;

	}
	// $ANTLR end "statementList"

	partial void EnterRule_variableStatement();
	partial void LeaveRule_variableStatement();
	// $ANTLR start "variableStatement"
	// JavaScript.g:100:1: variableStatement : 'var' ( LT )* variableDeclarationList ( LT | ';' ) -> ^( 'var' variableDeclarationList ) ;
	[GrammarRule("variableStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableStatement()
	{
		EnterRule_variableStatement();
		EnterRule("variableStatement", 11);
		TraceIn("variableStatement", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal60 = default(IToken);
		IToken LT61 = default(IToken);
		IToken LT63 = default(IToken);
		IToken char_literal64 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationList62 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal60_tree = default(CommonTree);
		CommonTree LT61_tree = default(CommonTree);
		CommonTree LT63_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_variableDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationList");
		try { DebugEnterRule(GrammarFileName, "variableStatement");
		DebugLocation(100, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// JavaScript.g:101:2: ( 'var' ( LT )* variableDeclarationList ( LT | ';' ) -> ^( 'var' variableDeclarationList ) )
			DebugEnterAlt(1);
			// JavaScript.g:101:4: 'var' ( LT )* variableDeclarationList ( LT | ';' )
			{
			DebugLocation(101, 4);
			string_literal60=(IToken)Match(input,106,Follow._106_in_variableStatement565); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_106.Add(string_literal60);

			DebugLocation(101, 10);
			// JavaScript.g:101:10: ( LT )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_1 = input.LA(1);

				if ((LA27_1==LT))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:101:10: LT
					{
					DebugLocation(101, 10);
					LT61=(IToken)Match(input,LT,Follow._LT_in_variableStatement567); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT61);


					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }

			DebugLocation(101, 14);
			PushFollow(Follow._variableDeclarationList_in_variableStatement570);
			variableDeclarationList62=variableDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationList.Add(variableDeclarationList62.Tree);
			DebugLocation(101, 38);
			// JavaScript.g:101:38: ( LT | ';' )
			int alt28=2;
			try { DebugEnterSubRule(28);
			try { DebugEnterDecision(28, false);
			int LA28_1 = input.LA(1);

			if ((LA28_1==LT))
			{
				alt28 = 1;
			}
			else if ((LA28_1==63))
			{
				alt28 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 28, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(28); }
			switch (alt28)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:101:39: LT
				{
				DebugLocation(101, 39);
				LT63=(IToken)Match(input,LT,Follow._LT_in_variableStatement573); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT63);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:101:44: ';'
				{
				DebugLocation(101, 44);
				char_literal64=(IToken)Match(input,63,Follow._63_in_variableStatement577); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal64);


				}
				break;

			}
			} finally { DebugExitSubRule(28); }



			{
			// AST REWRITE
			// elements: 106, variableDeclarationList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 102:3: -> ^( 'var' variableDeclarationList )
			{
				DebugLocation(102, 6);
				// JavaScript.g:102:6: ^( 'var' variableDeclarationList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(102, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new VariableStatement(stream_106.NextToken()), root_1);

				DebugLocation(102, 38);
				adaptor.AddChild(root_1, stream_variableDeclarationList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableStatement", 11);
			LeaveRule("variableStatement", 11);
			LeaveRule_variableStatement();
			if (state.backtracking > 0) { Memoize(input, 11, variableStatement_StartIndex); }

		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "variableStatement"); }
		return retval;

	}
	// $ANTLR end "variableStatement"

	partial void EnterRule_variableDeclarationList();
	partial void LeaveRule_variableDeclarationList();
	// $ANTLR start "variableDeclarationList"
	// JavaScript.g:105:1: variableDeclarationList : variableDeclaration ( ( LT )* ',' ( LT )* variableDeclaration )* -> ( variableDeclaration )+ ;
	[GrammarRule("variableDeclarationList")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationList()
	{
		EnterRule_variableDeclarationList();
		EnterRule("variableDeclarationList", 12);
		TraceIn("variableDeclarationList", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationList_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT66 = default(IToken);
		IToken char_literal67 = default(IToken);
		IToken LT68 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclaration65 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclaration69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT66_tree = default(CommonTree);
		CommonTree char_literal67_tree = default(CommonTree);
		CommonTree LT68_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		try { DebugEnterRule(GrammarFileName, "variableDeclarationList");
		DebugLocation(105, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// JavaScript.g:106:2: ( variableDeclaration ( ( LT )* ',' ( LT )* variableDeclaration )* -> ( variableDeclaration )+ )
			DebugEnterAlt(1);
			// JavaScript.g:106:4: variableDeclaration ( ( LT )* ',' ( LT )* variableDeclaration )*
			{
			DebugLocation(106, 4);
			PushFollow(Follow._variableDeclaration_in_variableDeclarationList606);
			variableDeclaration65=variableDeclaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration65.Tree);
			DebugLocation(106, 24);
			// JavaScript.g:106:24: ( ( LT )* ',' ( LT )* variableDeclaration )*
			try { DebugEnterSubRule(31);
			while (true)
			{
				int alt31=2;
				try { DebugEnterDecision(31, false);
				try
				{
					alt31 = dfa31.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(31); }
				switch ( alt31 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:106:25: ( LT )* ',' ( LT )* variableDeclaration
					{
					DebugLocation(106, 25);
					// JavaScript.g:106:25: ( LT )*
					try { DebugEnterSubRule(29);
					while (true)
					{
						int alt29=2;
						try { DebugEnterDecision(29, false);
						int LA29_1 = input.LA(1);

						if ((LA29_1==LT))
						{
							alt29 = 1;
						}


						} finally { DebugExitDecision(29); }
						switch ( alt29 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:106:25: LT
							{
							DebugLocation(106, 25);
							LT66=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationList609); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT66);


							}
							break;

						default:
							goto loop29;
						}
					}

					loop29:
						;

					} finally { DebugExitSubRule(29); }

					DebugLocation(106, 29);
					char_literal67=(IToken)Match(input,55,Follow._55_in_variableDeclarationList612); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal67);

					DebugLocation(106, 33);
					// JavaScript.g:106:33: ( LT )*
					try { DebugEnterSubRule(30);
					while (true)
					{
						int alt30=2;
						try { DebugEnterDecision(30, false);
						int LA30_1 = input.LA(1);

						if ((LA30_1==LT))
						{
							alt30 = 1;
						}


						} finally { DebugExitDecision(30); }
						switch ( alt30 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:106:33: LT
							{
							DebugLocation(106, 33);
							LT68=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationList614); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT68);


							}
							break;

						default:
							goto loop30;
						}
					}

					loop30:
						;

					} finally { DebugExitSubRule(30); }

					DebugLocation(106, 37);
					PushFollow(Follow._variableDeclaration_in_variableDeclarationList617);
					variableDeclaration69=variableDeclaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration69.Tree);

					}
					break;

				default:
					goto loop31;
				}
			}

			loop31:
				;

			} finally { DebugExitSubRule(31); }



			{
			// AST REWRITE
			// elements: variableDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 106:59: -> ( variableDeclaration )+
			{
				DebugLocation(106, 62);
				if (!(stream_variableDeclaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclaration.HasNext )
				{
					DebugLocation(106, 62);
					adaptor.AddChild(root_0, stream_variableDeclaration.NextTree());

				}
				stream_variableDeclaration.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationList", 12);
			LeaveRule("variableDeclarationList", 12);
			LeaveRule_variableDeclarationList();
			if (state.backtracking > 0) { Memoize(input, 12, variableDeclarationList_StartIndex); }

		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationList"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationList"

	partial void EnterRule_variableDeclarationListNoIn();
	partial void LeaveRule_variableDeclarationListNoIn();
	// $ANTLR start "variableDeclarationListNoIn"
	// JavaScript.g:109:1: variableDeclarationListNoIn : variableDeclarationNoIn ( ( LT )* ',' ( LT )* variableDeclarationNoIn )* -> ( variableDeclarationNoIn )+ ;
	[GrammarRule("variableDeclarationListNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationListNoIn()
	{
		EnterRule_variableDeclarationListNoIn();
		EnterRule("variableDeclarationListNoIn", 13);
		TraceIn("variableDeclarationListNoIn", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationListNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT71 = default(IToken);
		IToken char_literal72 = default(IToken);
		IToken LT73 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn70 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn74 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT71_tree = default(CommonTree);
		CommonTree char_literal72_tree = default(CommonTree);
		CommonTree LT73_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_variableDeclarationNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationNoIn");
		try { DebugEnterRule(GrammarFileName, "variableDeclarationListNoIn");
		DebugLocation(109, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// JavaScript.g:110:2: ( variableDeclarationNoIn ( ( LT )* ',' ( LT )* variableDeclarationNoIn )* -> ( variableDeclarationNoIn )+ )
			DebugEnterAlt(1);
			// JavaScript.g:110:4: variableDeclarationNoIn ( ( LT )* ',' ( LT )* variableDeclarationNoIn )*
			{
			DebugLocation(110, 4);
			PushFollow(Follow._variableDeclarationNoIn_in_variableDeclarationListNoIn636);
			variableDeclarationNoIn70=variableDeclarationNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn70.Tree);
			DebugLocation(110, 28);
			// JavaScript.g:110:28: ( ( LT )* ',' ( LT )* variableDeclarationNoIn )*
			try { DebugEnterSubRule(34);
			while (true)
			{
				int alt34=2;
				try { DebugEnterDecision(34, false);
				try
				{
					alt34 = dfa34.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(34); }
				switch ( alt34 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:110:29: ( LT )* ',' ( LT )* variableDeclarationNoIn
					{
					DebugLocation(110, 29);
					// JavaScript.g:110:29: ( LT )*
					try { DebugEnterSubRule(32);
					while (true)
					{
						int alt32=2;
						try { DebugEnterDecision(32, false);
						int LA32_1 = input.LA(1);

						if ((LA32_1==LT))
						{
							alt32 = 1;
						}


						} finally { DebugExitDecision(32); }
						switch ( alt32 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:110:29: LT
							{
							DebugLocation(110, 29);
							LT71=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationListNoIn639); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT71);


							}
							break;

						default:
							goto loop32;
						}
					}

					loop32:
						;

					} finally { DebugExitSubRule(32); }

					DebugLocation(110, 33);
					char_literal72=(IToken)Match(input,55,Follow._55_in_variableDeclarationListNoIn642); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal72);

					DebugLocation(110, 37);
					// JavaScript.g:110:37: ( LT )*
					try { DebugEnterSubRule(33);
					while (true)
					{
						int alt33=2;
						try { DebugEnterDecision(33, false);
						int LA33_1 = input.LA(1);

						if ((LA33_1==LT))
						{
							alt33 = 1;
						}


						} finally { DebugExitDecision(33); }
						switch ( alt33 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:110:37: LT
							{
							DebugLocation(110, 37);
							LT73=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationListNoIn644); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT73);


							}
							break;

						default:
							goto loop33;
						}
					}

					loop33:
						;

					} finally { DebugExitSubRule(33); }

					DebugLocation(110, 41);
					PushFollow(Follow._variableDeclarationNoIn_in_variableDeclarationListNoIn647);
					variableDeclarationNoIn74=variableDeclarationNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn74.Tree);

					}
					break;

				default:
					goto loop34;
				}
			}

			loop34:
				;

			} finally { DebugExitSubRule(34); }



			{
			// AST REWRITE
			// elements: variableDeclarationNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 110:67: -> ( variableDeclarationNoIn )+
			{
				DebugLocation(110, 70);
				if (!(stream_variableDeclarationNoIn.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclarationNoIn.HasNext )
				{
					DebugLocation(110, 70);
					adaptor.AddChild(root_0, stream_variableDeclarationNoIn.NextTree());

				}
				stream_variableDeclarationNoIn.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationListNoIn", 13);
			LeaveRule("variableDeclarationListNoIn", 13);
			LeaveRule_variableDeclarationListNoIn();
			if (state.backtracking > 0) { Memoize(input, 13, variableDeclarationListNoIn_StartIndex); }

		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationListNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationListNoIn"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();
	// $ANTLR start "variableDeclaration"
	// JavaScript.g:113:1: variableDeclaration : Identifier ( LT )* ( initialiser )? -> ^( VARIABLEDECL Identifier ( initialiser )? ) ;
	[GrammarRule("variableDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 14);
		TraceIn("variableDeclaration", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier75 = default(IToken);
		IToken LT76 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> initialiser77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Identifier75_tree = default(CommonTree);
		CommonTree LT76_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_initialiser=new RewriteRuleSubtreeStream(adaptor,"rule initialiser");
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(113, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// JavaScript.g:114:2: ( Identifier ( LT )* ( initialiser )? -> ^( VARIABLEDECL Identifier ( initialiser )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:114:4: Identifier ( LT )* ( initialiser )?
			{
			DebugLocation(114, 4);
			Identifier75=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration666); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier75);

			DebugLocation(114, 15);
			// JavaScript.g:114:15: ( LT )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				int LA35_1 = input.LA(1);

				if ((LA35_1==LT))
				{
					int LA35_2 = input.LA(2);

					if ((EvaluatePredicate(synpred47_JavaScript_fragment)))
					{
						alt35 = 1;
					}


				}


				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:114:15: LT
					{
					DebugLocation(114, 15);
					LT76=(IToken)Match(input,LT,Follow._LT_in_variableDeclaration668); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT76);


					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }

			DebugLocation(114, 19);
			// JavaScript.g:114:19: ( initialiser )?
			int alt36=2;
			try { DebugEnterSubRule(36);
			try { DebugEnterDecision(36, false);
			int LA36_1 = input.LA(1);

			if ((LA36_1==68))
			{
				alt36 = 1;
			}
			} finally { DebugExitDecision(36); }
			switch (alt36)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:114:19: initialiser
				{
				DebugLocation(114, 19);
				PushFollow(Follow._initialiser_in_variableDeclaration671);
				initialiser77=initialiser();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_initialiser.Add(initialiser77.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(36); }



			{
			// AST REWRITE
			// elements: Identifier, initialiser
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 115:3: -> ^( VARIABLEDECL Identifier ( initialiser )? )
			{
				DebugLocation(115, 6);
				// JavaScript.g:115:6: ^( VARIABLEDECL Identifier ( initialiser )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(115, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new VariableDeclaration(VARIABLEDECL), root_1);

				DebugLocation(116, 5);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(117, 5);
				// JavaScript.g:117:5: ( initialiser )?
				if (stream_initialiser.HasNext)
				{
					DebugLocation(117, 5);
					adaptor.AddChild(root_1, stream_initialiser.NextTree());

				}
				stream_initialiser.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 14);
			LeaveRule("variableDeclaration", 14);
			LeaveRule_variableDeclaration();
			if (state.backtracking > 0) { Memoize(input, 14, variableDeclaration_StartIndex); }

		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_variableDeclarationNoIn();
	partial void LeaveRule_variableDeclarationNoIn();
	// $ANTLR start "variableDeclarationNoIn"
	// JavaScript.g:120:1: variableDeclarationNoIn : Identifier ( LT )* ( initialiserNoIn )? -> ^( VARIABLEDECL Identifier ( initialiserNoIn )? ) ;
	[GrammarRule("variableDeclarationNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn()
	{
		EnterRule_variableDeclarationNoIn();
		EnterRule("variableDeclarationNoIn", 15);
		TraceIn("variableDeclarationNoIn", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier78 = default(IToken);
		IToken LT79 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> initialiserNoIn80 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Identifier78_tree = default(CommonTree);
		CommonTree LT79_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_initialiserNoIn=new RewriteRuleSubtreeStream(adaptor,"rule initialiserNoIn");
		try { DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
		DebugLocation(120, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// JavaScript.g:121:2: ( Identifier ( LT )* ( initialiserNoIn )? -> ^( VARIABLEDECL Identifier ( initialiserNoIn )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:121:4: Identifier ( LT )* ( initialiserNoIn )?
			{
			DebugLocation(121, 4);
			Identifier78=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclarationNoIn718); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier78);

			DebugLocation(121, 15);
			// JavaScript.g:121:15: ( LT )*
			try { DebugEnterSubRule(37);
			while (true)
			{
				int alt37=2;
				try { DebugEnterDecision(37, false);
				int LA37_1 = input.LA(1);

				if ((LA37_1==LT))
				{
					int LA37_2 = input.LA(2);

					if ((EvaluatePredicate(synpred49_JavaScript_fragment)))
					{
						alt37 = 1;
					}


				}


				} finally { DebugExitDecision(37); }
				switch ( alt37 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:121:15: LT
					{
					DebugLocation(121, 15);
					LT79=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationNoIn720); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT79);


					}
					break;

				default:
					goto loop37;
				}
			}

			loop37:
				;

			} finally { DebugExitSubRule(37); }

			DebugLocation(121, 19);
			// JavaScript.g:121:19: ( initialiserNoIn )?
			int alt38=2;
			try { DebugEnterSubRule(38);
			try { DebugEnterDecision(38, false);
			int LA38_1 = input.LA(1);

			if ((LA38_1==68))
			{
				alt38 = 1;
			}
			} finally { DebugExitDecision(38); }
			switch (alt38)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:121:19: initialiserNoIn
				{
				DebugLocation(121, 19);
				PushFollow(Follow._initialiserNoIn_in_variableDeclarationNoIn723);
				initialiserNoIn80=initialiserNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_initialiserNoIn.Add(initialiserNoIn80.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(38); }



			{
			// AST REWRITE
			// elements: Identifier, initialiserNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 122:3: -> ^( VARIABLEDECL Identifier ( initialiserNoIn )? )
			{
				DebugLocation(122, 6);
				// JavaScript.g:122:6: ^( VARIABLEDECL Identifier ( initialiserNoIn )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(122, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new VariableDeclaration(VARIABLEDECL), root_1);

				DebugLocation(123, 5);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(124, 5);
				// JavaScript.g:124:5: ( initialiserNoIn )?
				if (stream_initialiserNoIn.HasNext)
				{
					DebugLocation(124, 5);
					adaptor.AddChild(root_1, stream_initialiserNoIn.NextTree());

				}
				stream_initialiserNoIn.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationNoIn", 15);
			LeaveRule("variableDeclarationNoIn", 15);
			LeaveRule_variableDeclarationNoIn();
			if (state.backtracking > 0) { Memoize(input, 15, variableDeclarationNoIn_StartIndex); }

		}
		DebugLocation(125, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationNoIn"

	partial void EnterRule_initialiser();
	partial void LeaveRule_initialiser();
	// $ANTLR start "initialiser"
	// JavaScript.g:127:1: initialiser : '=' ( LT )* assignmentExpression -> assignmentExpression ;
	[GrammarRule("initialiser")]
	private AstParserRuleReturnScope<CommonTree, IToken> initialiser()
	{
		EnterRule_initialiser();
		EnterRule("initialiser", 16);
		TraceIn("initialiser", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int initialiser_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal81 = default(IToken);
		IToken LT82 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression83 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal81_tree = default(CommonTree);
		CommonTree LT82_tree = default(CommonTree);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "initialiser");
		DebugLocation(127, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// JavaScript.g:128:2: ( '=' ( LT )* assignmentExpression -> assignmentExpression )
			DebugEnterAlt(1);
			// JavaScript.g:128:4: '=' ( LT )* assignmentExpression
			{
			DebugLocation(128, 4);
			char_literal81=(IToken)Match(input,68,Follow._68_in_initialiser768); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(char_literal81);

			DebugLocation(128, 8);
			// JavaScript.g:128:8: ( LT )*
			try { DebugEnterSubRule(39);
			while (true)
			{
				int alt39=2;
				try { DebugEnterDecision(39, false);
				int LA39_1 = input.LA(1);

				if ((LA39_1==LT))
				{
					alt39 = 1;
				}


				} finally { DebugExitDecision(39); }
				switch ( alt39 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:128:8: LT
					{
					DebugLocation(128, 8);
					LT82=(IToken)Match(input,LT,Follow._LT_in_initialiser770); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT82);


					}
					break;

				default:
					goto loop39;
				}
			}

			loop39:
				;

			} finally { DebugExitSubRule(39); }

			DebugLocation(128, 12);
			PushFollow(Follow._assignmentExpression_in_initialiser773);
			assignmentExpression83=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression83.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 128:33: -> assignmentExpression
			{
				DebugLocation(128, 36);
				adaptor.AddChild(root_0, stream_assignmentExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initialiser", 16);
			LeaveRule("initialiser", 16);
			LeaveRule_initialiser();
			if (state.backtracking > 0) { Memoize(input, 16, initialiser_StartIndex); }

		}
		DebugLocation(129, 4);
		} finally { DebugExitRule(GrammarFileName, "initialiser"); }
		return retval;

	}
	// $ANTLR end "initialiser"

	partial void EnterRule_initialiserNoIn();
	partial void LeaveRule_initialiserNoIn();
	// $ANTLR start "initialiserNoIn"
	// JavaScript.g:131:1: initialiserNoIn : '=' ( LT )* assignmentExpressionNoIn -> assignmentExpressionNoIn ;
	[GrammarRule("initialiserNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> initialiserNoIn()
	{
		EnterRule_initialiserNoIn();
		EnterRule("initialiserNoIn", 17);
		TraceIn("initialiserNoIn", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int initialiserNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal84 = default(IToken);
		IToken LT85 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn86 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal84_tree = default(CommonTree);
		CommonTree LT85_tree = default(CommonTree);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "initialiserNoIn");
		DebugLocation(131, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// JavaScript.g:132:2: ( '=' ( LT )* assignmentExpressionNoIn -> assignmentExpressionNoIn )
			DebugEnterAlt(1);
			// JavaScript.g:132:4: '=' ( LT )* assignmentExpressionNoIn
			{
			DebugLocation(132, 4);
			char_literal84=(IToken)Match(input,68,Follow._68_in_initialiserNoIn792); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(char_literal84);

			DebugLocation(132, 8);
			// JavaScript.g:132:8: ( LT )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==LT))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:132:8: LT
					{
					DebugLocation(132, 8);
					LT85=(IToken)Match(input,LT,Follow._LT_in_initialiserNoIn794); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT85);


					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(132, 12);
			PushFollow(Follow._assignmentExpressionNoIn_in_initialiserNoIn797);
			assignmentExpressionNoIn86=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(assignmentExpressionNoIn86.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpressionNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 132:37: -> assignmentExpressionNoIn
			{
				DebugLocation(132, 40);
				adaptor.AddChild(root_0, stream_assignmentExpressionNoIn.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initialiserNoIn", 17);
			LeaveRule("initialiserNoIn", 17);
			LeaveRule_initialiserNoIn();
			if (state.backtracking > 0) { Memoize(input, 17, initialiserNoIn_StartIndex); }

		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "initialiserNoIn"); }
		return retval;

	}
	// $ANTLR end "initialiserNoIn"

	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();
	// $ANTLR start "emptyStatement"
	// JavaScript.g:135:1: emptyStatement : ';' -> ';' ;
	[GrammarRule("emptyStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 18);
		TraceIn("emptyStatement", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int emptyStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal87 = default(IToken);

		CommonTree char_literal87_tree = default(CommonTree);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(135, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// JavaScript.g:136:2: ( ';' -> ';' )
			DebugEnterAlt(1);
			// JavaScript.g:136:4: ';'
			{
			DebugLocation(136, 4);
			char_literal87=(IToken)Match(input,63,Follow._63_in_emptyStatement813); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal87);



			{
			// AST REWRITE
			// elements: 63
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 136:8: -> ';'
			{
				DebugLocation(136, 11);
				adaptor.AddChild(root_0, new EmptyStatement(stream_63.NextToken()));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("emptyStatement", 18);
			LeaveRule("emptyStatement", 18);
			LeaveRule_emptyStatement();
			if (state.backtracking > 0) { Memoize(input, 18, emptyStatement_StartIndex); }

		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		return retval;

	}
	// $ANTLR end "emptyStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();
	// $ANTLR start "expressionStatement"
	// JavaScript.g:139:1: expressionStatement : expression ( LT | ';' ) -> expression ;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 19);
		TraceIn("expressionStatement", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expressionStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT89 = default(IToken);
		IToken char_literal90 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression88 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT89_tree = default(CommonTree);
		CommonTree char_literal90_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(139, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// JavaScript.g:140:2: ( expression ( LT | ';' ) -> expression )
			DebugEnterAlt(1);
			// JavaScript.g:140:4: expression ( LT | ';' )
			{
			DebugLocation(140, 4);
			PushFollow(Follow._expression_in_expressionStatement834);
			expression88=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression88.Tree);
			DebugLocation(140, 15);
			// JavaScript.g:140:15: ( LT | ';' )
			int alt41=2;
			try { DebugEnterSubRule(41);
			try { DebugEnterDecision(41, false);
			int LA41_1 = input.LA(1);

			if ((LA41_1==LT))
			{
				alt41 = 1;
			}
			else if ((LA41_1==63))
			{
				alt41 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 41, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(41); }
			switch (alt41)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:140:16: LT
				{
				DebugLocation(140, 16);
				LT89=(IToken)Match(input,LT,Follow._LT_in_expressionStatement837); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT89);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:140:21: ';'
				{
				DebugLocation(140, 21);
				char_literal90=(IToken)Match(input,63,Follow._63_in_expressionStatement841); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal90);


				}
				break;

			}
			} finally { DebugExitSubRule(41); }



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 140:26: -> expression
			{
				DebugLocation(140, 29);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionStatement", 19);
			LeaveRule("expressionStatement", 19);
			LeaveRule_expressionStatement();
			if (state.backtracking > 0) { Memoize(input, 19, expressionStatement_StartIndex); }

		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// JavaScript.g:143:1: ifStatement : 'if' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* ifstmt= statement ( ( LT )* 'else' ( LT )* elsestmt= statement )? -> ^( 'if' expression $ifstmt ( $elsestmt)? ) ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 20);
		TraceIn("ifStatement", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int ifStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal91 = default(IToken);
		IToken LT92 = default(IToken);
		IToken char_literal93 = default(IToken);
		IToken LT94 = default(IToken);
		IToken LT96 = default(IToken);
		IToken char_literal97 = default(IToken);
		IToken LT98 = default(IToken);
		IToken LT99 = default(IToken);
		IToken string_literal100 = default(IToken);
		IToken LT101 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ifstmt = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elsestmt = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression95 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal91_tree = default(CommonTree);
		CommonTree LT92_tree = default(CommonTree);
		CommonTree char_literal93_tree = default(CommonTree);
		CommonTree LT94_tree = default(CommonTree);
		CommonTree LT96_tree = default(CommonTree);
		CommonTree char_literal97_tree = default(CommonTree);
		CommonTree LT98_tree = default(CommonTree);
		CommonTree LT99_tree = default(CommonTree);
		CommonTree string_literal100_tree = default(CommonTree);
		CommonTree LT101_tree = default(CommonTree);
		RewriteRuleITokenStream stream_94=new RewriteRuleITokenStream(adaptor,"token 94");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(143, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// JavaScript.g:144:2: ( 'if' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* ifstmt= statement ( ( LT )* 'else' ( LT )* elsestmt= statement )? -> ^( 'if' expression $ifstmt ( $elsestmt)? ) )
			DebugEnterAlt(1);
			// JavaScript.g:144:4: 'if' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* ifstmt= statement ( ( LT )* 'else' ( LT )* elsestmt= statement )?
			{
			DebugLocation(144, 4);
			string_literal91=(IToken)Match(input,94,Follow._94_in_ifStatement858); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_94.Add(string_literal91);

			DebugLocation(144, 9);
			// JavaScript.g:144:9: ( LT )*
			try { DebugEnterSubRule(42);
			while (true)
			{
				int alt42=2;
				try { DebugEnterDecision(42, false);
				int LA42_1 = input.LA(1);

				if ((LA42_1==LT))
				{
					alt42 = 1;
				}


				} finally { DebugExitDecision(42); }
				switch ( alt42 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:9: LT
					{
					DebugLocation(144, 9);
					LT92=(IToken)Match(input,LT,Follow._LT_in_ifStatement860); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT92);


					}
					break;

				default:
					goto loop42;
				}
			}

			loop42:
				;

			} finally { DebugExitSubRule(42); }

			DebugLocation(144, 13);
			char_literal93=(IToken)Match(input,48,Follow._48_in_ifStatement863); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal93);

			DebugLocation(144, 17);
			// JavaScript.g:144:17: ( LT )*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==LT))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:17: LT
					{
					DebugLocation(144, 17);
					LT94=(IToken)Match(input,LT,Follow._LT_in_ifStatement865); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT94);


					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }

			DebugLocation(144, 21);
			PushFollow(Follow._expression_in_ifStatement868);
			expression95=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression95.Tree);
			DebugLocation(144, 32);
			// JavaScript.g:144:32: ( LT )*
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1==LT))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch ( alt44 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:32: LT
					{
					DebugLocation(144, 32);
					LT96=(IToken)Match(input,LT,Follow._LT_in_ifStatement870); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT96);


					}
					break;

				default:
					goto loop44;
				}
			}

			loop44:
				;

			} finally { DebugExitSubRule(44); }

			DebugLocation(144, 36);
			char_literal97=(IToken)Match(input,49,Follow._49_in_ifStatement873); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal97);

			DebugLocation(144, 40);
			// JavaScript.g:144:40: ( LT )*
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=2;
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==LT))
				{
					alt45 = 1;
				}


				} finally { DebugExitDecision(45); }
				switch ( alt45 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:40: LT
					{
					DebugLocation(144, 40);
					LT98=(IToken)Match(input,LT,Follow._LT_in_ifStatement875); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT98);


					}
					break;

				default:
					goto loop45;
				}
			}

			loop45:
				;

			} finally { DebugExitSubRule(45); }

			DebugLocation(144, 50);
			PushFollow(Follow._statement_in_ifStatement880);
			ifstmt=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(ifstmt.Tree);
			DebugLocation(144, 61);
			// JavaScript.g:144:61: ( ( LT )* 'else' ( LT )* elsestmt= statement )?
			int alt48=2;
			try { DebugEnterSubRule(48);
			try { DebugEnterDecision(48, false);
			int LA48_1 = input.LA(1);

			if ((LA48_1==LT))
			{
				int LA48_2 = input.LA(2);

				if ((EvaluatePredicate(synpred60_JavaScript_fragment)))
				{
					alt48 = 1;
				}
			}
			else if ((LA48_1==89))
			{
				int LA48_2 = input.LA(2);

				if ((EvaluatePredicate(synpred60_JavaScript_fragment)))
				{
					alt48 = 1;
				}
			}
			} finally { DebugExitDecision(48); }
			switch (alt48)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:144:62: ( LT )* 'else' ( LT )* elsestmt= statement
				{
				DebugLocation(144, 62);
				// JavaScript.g:144:62: ( LT )*
				try { DebugEnterSubRule(46);
				while (true)
				{
					int alt46=2;
					try { DebugEnterDecision(46, false);
					int LA46_1 = input.LA(1);

					if ((LA46_1==LT))
					{
						alt46 = 1;
					}


					} finally { DebugExitDecision(46); }
					switch ( alt46 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:144:62: LT
						{
						DebugLocation(144, 62);
						LT99=(IToken)Match(input,LT,Follow._LT_in_ifStatement883); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT99);


						}
						break;

					default:
						goto loop46;
					}
				}

				loop46:
					;

				} finally { DebugExitSubRule(46); }

				DebugLocation(144, 66);
				string_literal100=(IToken)Match(input,89,Follow._89_in_ifStatement886); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_89.Add(string_literal100);

				DebugLocation(144, 73);
				// JavaScript.g:144:73: ( LT )*
				try { DebugEnterSubRule(47);
				while (true)
				{
					int alt47=2;
					try { DebugEnterDecision(47, false);
					int LA47_1 = input.LA(1);

					if ((LA47_1==LT))
					{
						alt47 = 1;
					}


					} finally { DebugExitDecision(47); }
					switch ( alt47 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:144:73: LT
						{
						DebugLocation(144, 73);
						LT101=(IToken)Match(input,LT,Follow._LT_in_ifStatement888); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT101);


						}
						break;

					default:
						goto loop47;
					}
				}

				loop47:
					;

				} finally { DebugExitSubRule(47); }

				DebugLocation(144, 85);
				PushFollow(Follow._statement_in_ifStatement893);
				elsestmt=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(elsestmt.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(48); }



			{
			// AST REWRITE
			// elements: 94, expression, ifstmt, elsestmt
			// token labels: 
			// rule labels: ifstmt, elsestmt, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_ifstmt=new RewriteRuleSubtreeStream(adaptor,"rule ifstmt",ifstmt!=null?ifstmt.Tree:null);
			RewriteRuleSubtreeStream stream_elsestmt=new RewriteRuleSubtreeStream(adaptor,"rule elsestmt",elsestmt!=null?elsestmt.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 145:3: -> ^( 'if' expression $ifstmt ( $elsestmt)? )
			{
				DebugLocation(145, 6);
				// JavaScript.g:145:6: ^( 'if' expression $ifstmt ( $elsestmt)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(145, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new IfStatement(stream_94.NextToken()), root_1);

				DebugLocation(145, 31);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(145, 43);
				adaptor.AddChild(root_1, stream_ifstmt.NextTree());
				DebugLocation(145, 51);
				// JavaScript.g:145:51: ( $elsestmt)?
				if (stream_elsestmt.HasNext)
				{
					DebugLocation(145, 51);
					adaptor.AddChild(root_1, stream_elsestmt.NextTree());

				}
				stream_elsestmt.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 20);
			LeaveRule("ifStatement", 20);
			LeaveRule_ifStatement();
			if (state.backtracking > 0) { Memoize(input, 20, ifStatement_StartIndex); }

		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_iterationStatement();
	partial void LeaveRule_iterationStatement();
	// $ANTLR start "iterationStatement"
	// JavaScript.g:148:1: iterationStatement : ( doWhileStatement | whileStatement | forStatement | forInStatement );
	[GrammarRule("iterationStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> iterationStatement()
	{
		EnterRule_iterationStatement();
		EnterRule("iterationStatement", 21);
		TraceIn("iterationStatement", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int iterationStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> doWhileStatement102 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement103 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forStatement104 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forInStatement105 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "iterationStatement");
		DebugLocation(148, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// JavaScript.g:149:2: ( doWhileStatement | whileStatement | forStatement | forInStatement )
			int alt49=4;
			try { DebugEnterDecision(49, false);
			switch (input.LA(1))
			{
			case 88:
				{
				alt49 = 1;
				}
				break;
			case 108:
				{
				alt49 = 2;
				}
				break;
			case 92:
				{
				int LA49_2 = input.LA(2);

				if ((EvaluatePredicate(synpred63_JavaScript_fragment)))
				{
					alt49 = 3;
				}
				else if ((true))
				{
					alt49 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 49, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 49, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:149:4: doWhileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(149, 4);
				PushFollow(Follow._doWhileStatement_in_iterationStatement929);
				doWhileStatement102=doWhileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doWhileStatement102.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:150:4: whileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(150, 4);
				PushFollow(Follow._whileStatement_in_iterationStatement934);
				whileStatement103=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement103.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:151:4: forStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(151, 4);
				PushFollow(Follow._forStatement_in_iterationStatement939);
				forStatement104=forStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forStatement104.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:152:4: forInStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(152, 4);
				PushFollow(Follow._forInStatement_in_iterationStatement944);
				forInStatement105=forInStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forInStatement105.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("iterationStatement", 21);
			LeaveRule("iterationStatement", 21);
			LeaveRule_iterationStatement();
			if (state.backtracking > 0) { Memoize(input, 21, iterationStatement_StartIndex); }

		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
		return retval;

	}
	// $ANTLR end "iterationStatement"

	partial void EnterRule_doWhileStatement();
	partial void LeaveRule_doWhileStatement();
	// $ANTLR start "doWhileStatement"
	// JavaScript.g:155:1: doWhileStatement : 'do' ( LT )* statement ( LT )* 'while' ( LT )* '(' expression ')' ( LT | ';' ) -> ^( 'do' statement expression ) ;
	[GrammarRule("doWhileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> doWhileStatement()
	{
		EnterRule_doWhileStatement();
		EnterRule("doWhileStatement", 22);
		TraceIn("doWhileStatement", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int doWhileStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal106 = default(IToken);
		IToken LT107 = default(IToken);
		IToken LT109 = default(IToken);
		IToken string_literal110 = default(IToken);
		IToken LT111 = default(IToken);
		IToken char_literal112 = default(IToken);
		IToken char_literal114 = default(IToken);
		IToken LT115 = default(IToken);
		IToken char_literal116 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement108 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression113 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal106_tree = default(CommonTree);
		CommonTree LT107_tree = default(CommonTree);
		CommonTree LT109_tree = default(CommonTree);
		CommonTree string_literal110_tree = default(CommonTree);
		CommonTree LT111_tree = default(CommonTree);
		CommonTree char_literal112_tree = default(CommonTree);
		CommonTree char_literal114_tree = default(CommonTree);
		CommonTree LT115_tree = default(CommonTree);
		CommonTree char_literal116_tree = default(CommonTree);
		RewriteRuleITokenStream stream_88=new RewriteRuleITokenStream(adaptor,"token 88");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_108=new RewriteRuleITokenStream(adaptor,"token 108");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "doWhileStatement");
		DebugLocation(155, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// JavaScript.g:156:2: ( 'do' ( LT )* statement ( LT )* 'while' ( LT )* '(' expression ')' ( LT | ';' ) -> ^( 'do' statement expression ) )
			DebugEnterAlt(1);
			// JavaScript.g:156:4: 'do' ( LT )* statement ( LT )* 'while' ( LT )* '(' expression ')' ( LT | ';' )
			{
			DebugLocation(156, 4);
			string_literal106=(IToken)Match(input,88,Follow._88_in_doWhileStatement956); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_88.Add(string_literal106);

			DebugLocation(156, 9);
			// JavaScript.g:156:9: ( LT )*
			try { DebugEnterSubRule(50);
			while (true)
			{
				int alt50=2;
				try { DebugEnterDecision(50, false);
				int LA50_1 = input.LA(1);

				if ((LA50_1==LT))
				{
					alt50 = 1;
				}


				} finally { DebugExitDecision(50); }
				switch ( alt50 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:156:9: LT
					{
					DebugLocation(156, 9);
					LT107=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement958); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT107);


					}
					break;

				default:
					goto loop50;
				}
			}

			loop50:
				;

			} finally { DebugExitSubRule(50); }

			DebugLocation(156, 13);
			PushFollow(Follow._statement_in_doWhileStatement961);
			statement108=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement108.Tree);
			DebugLocation(156, 23);
			// JavaScript.g:156:23: ( LT )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==LT))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:156:23: LT
					{
					DebugLocation(156, 23);
					LT109=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement963); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT109);


					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }

			DebugLocation(156, 27);
			string_literal110=(IToken)Match(input,108,Follow._108_in_doWhileStatement966); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_108.Add(string_literal110);

			DebugLocation(156, 35);
			// JavaScript.g:156:35: ( LT )*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, false);
				int LA52_1 = input.LA(1);

				if ((LA52_1==LT))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:156:35: LT
					{
					DebugLocation(156, 35);
					LT111=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement968); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT111);


					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }

			DebugLocation(156, 39);
			char_literal112=(IToken)Match(input,48,Follow._48_in_doWhileStatement971); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal112);

			DebugLocation(156, 43);
			PushFollow(Follow._expression_in_doWhileStatement973);
			expression113=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression113.Tree);
			DebugLocation(156, 54);
			char_literal114=(IToken)Match(input,49,Follow._49_in_doWhileStatement975); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal114);

			DebugLocation(156, 58);
			// JavaScript.g:156:58: ( LT | ';' )
			int alt53=2;
			try { DebugEnterSubRule(53);
			try { DebugEnterDecision(53, false);
			int LA53_1 = input.LA(1);

			if ((LA53_1==LT))
			{
				alt53 = 1;
			}
			else if ((LA53_1==63))
			{
				alt53 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 53, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(53); }
			switch (alt53)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:156:59: LT
				{
				DebugLocation(156, 59);
				LT115=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement978); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT115);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:156:64: ';'
				{
				DebugLocation(156, 64);
				char_literal116=(IToken)Match(input,63,Follow._63_in_doWhileStatement982); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal116);


				}
				break;

			}
			} finally { DebugExitSubRule(53); }



			{
			// AST REWRITE
			// elements: 88, statement, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 157:3: -> ^( 'do' statement expression )
			{
				DebugLocation(157, 6);
				// JavaScript.g:157:6: ^( 'do' statement expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(157, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new DoWhileStatement(stream_88.NextToken()), root_1);

				DebugLocation(157, 36);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(157, 46);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doWhileStatement", 22);
			LeaveRule("doWhileStatement", 22);
			LeaveRule_doWhileStatement();
			if (state.backtracking > 0) { Memoize(input, 22, doWhileStatement_StartIndex); }

		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "doWhileStatement"); }
		return retval;

	}
	// $ANTLR end "doWhileStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// JavaScript.g:160:1: whileStatement : 'while' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'while' expression statement ) ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 23);
		TraceIn("whileStatement", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int whileStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal117 = default(IToken);
		IToken LT118 = default(IToken);
		IToken char_literal119 = default(IToken);
		IToken LT120 = default(IToken);
		IToken LT122 = default(IToken);
		IToken char_literal123 = default(IToken);
		IToken LT124 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression121 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement125 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal117_tree = default(CommonTree);
		CommonTree LT118_tree = default(CommonTree);
		CommonTree char_literal119_tree = default(CommonTree);
		CommonTree LT120_tree = default(CommonTree);
		CommonTree LT122_tree = default(CommonTree);
		CommonTree char_literal123_tree = default(CommonTree);
		CommonTree LT124_tree = default(CommonTree);
		RewriteRuleITokenStream stream_108=new RewriteRuleITokenStream(adaptor,"token 108");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(160, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }

			// JavaScript.g:161:2: ( 'while' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'while' expression statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:161:4: 'while' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement
			{
			DebugLocation(161, 4);
			string_literal117=(IToken)Match(input,108,Follow._108_in_whileStatement1012); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_108.Add(string_literal117);

			DebugLocation(161, 12);
			// JavaScript.g:161:12: ( LT )*
			try { DebugEnterSubRule(54);
			while (true)
			{
				int alt54=2;
				try { DebugEnterDecision(54, false);
				int LA54_1 = input.LA(1);

				if ((LA54_1==LT))
				{
					alt54 = 1;
				}


				} finally { DebugExitDecision(54); }
				switch ( alt54 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:12: LT
					{
					DebugLocation(161, 12);
					LT118=(IToken)Match(input,LT,Follow._LT_in_whileStatement1014); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT118);


					}
					break;

				default:
					goto loop54;
				}
			}

			loop54:
				;

			} finally { DebugExitSubRule(54); }

			DebugLocation(161, 16);
			char_literal119=(IToken)Match(input,48,Follow._48_in_whileStatement1017); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal119);

			DebugLocation(161, 20);
			// JavaScript.g:161:20: ( LT )*
			try { DebugEnterSubRule(55);
			while (true)
			{
				int alt55=2;
				try { DebugEnterDecision(55, false);
				int LA55_1 = input.LA(1);

				if ((LA55_1==LT))
				{
					alt55 = 1;
				}


				} finally { DebugExitDecision(55); }
				switch ( alt55 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:20: LT
					{
					DebugLocation(161, 20);
					LT120=(IToken)Match(input,LT,Follow._LT_in_whileStatement1019); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT120);


					}
					break;

				default:
					goto loop55;
				}
			}

			loop55:
				;

			} finally { DebugExitSubRule(55); }

			DebugLocation(161, 24);
			PushFollow(Follow._expression_in_whileStatement1022);
			expression121=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression121.Tree);
			DebugLocation(161, 35);
			// JavaScript.g:161:35: ( LT )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==LT))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:35: LT
					{
					DebugLocation(161, 35);
					LT122=(IToken)Match(input,LT,Follow._LT_in_whileStatement1024); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT122);


					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }

			DebugLocation(161, 39);
			char_literal123=(IToken)Match(input,49,Follow._49_in_whileStatement1027); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal123);

			DebugLocation(161, 43);
			// JavaScript.g:161:43: ( LT )*
			try { DebugEnterSubRule(57);
			while (true)
			{
				int alt57=2;
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==LT))
				{
					alt57 = 1;
				}


				} finally { DebugExitDecision(57); }
				switch ( alt57 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:43: LT
					{
					DebugLocation(161, 43);
					LT124=(IToken)Match(input,LT,Follow._LT_in_whileStatement1029); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT124);


					}
					break;

				default:
					goto loop57;
				}
			}

			loop57:
				;

			} finally { DebugExitSubRule(57); }

			DebugLocation(161, 47);
			PushFollow(Follow._statement_in_whileStatement1032);
			statement125=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement125.Tree);


			{
			// AST REWRITE
			// elements: 108, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 162:3: -> ^( 'while' expression statement )
			{
				DebugLocation(162, 6);
				// JavaScript.g:162:6: ^( 'while' expression statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(162, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new WhileStatement(stream_108.NextToken()), root_1);

				DebugLocation(162, 37);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(162, 48);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 23);
			LeaveRule("whileStatement", 23);
			LeaveRule_whileStatement();
			if (state.backtracking > 0) { Memoize(input, 23, whileStatement_StartIndex); }

		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// JavaScript.g:165:1: forStatement : 'for' ( LT )* '(' ( ( LT )* forStatementInitialiserPart )? ( LT )* ';' ( ( LT )* condition= expression )? ( LT )* ';' ( ( LT )* incr= expression )? ( LT )* ')' ( LT )* statement -> ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement ) ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 24);
		TraceIn("forStatement", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal126 = default(IToken);
		IToken LT127 = default(IToken);
		IToken char_literal128 = default(IToken);
		IToken LT129 = default(IToken);
		IToken LT131 = default(IToken);
		IToken char_literal132 = default(IToken);
		IToken LT133 = default(IToken);
		IToken LT134 = default(IToken);
		IToken char_literal135 = default(IToken);
		IToken LT136 = default(IToken);
		IToken LT137 = default(IToken);
		IToken char_literal138 = default(IToken);
		IToken LT139 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> incr = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forStatementInitialiserPart130 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement140 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal126_tree = default(CommonTree);
		CommonTree LT127_tree = default(CommonTree);
		CommonTree char_literal128_tree = default(CommonTree);
		CommonTree LT129_tree = default(CommonTree);
		CommonTree LT131_tree = default(CommonTree);
		CommonTree char_literal132_tree = default(CommonTree);
		CommonTree LT133_tree = default(CommonTree);
		CommonTree LT134_tree = default(CommonTree);
		CommonTree char_literal135_tree = default(CommonTree);
		CommonTree LT136_tree = default(CommonTree);
		CommonTree LT137_tree = default(CommonTree);
		CommonTree char_literal138_tree = default(CommonTree);
		CommonTree LT139_tree = default(CommonTree);
		RewriteRuleITokenStream stream_92=new RewriteRuleITokenStream(adaptor,"token 92");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_forStatementInitialiserPart=new RewriteRuleSubtreeStream(adaptor,"rule forStatementInitialiserPart");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(165, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }

			// JavaScript.g:166:2: ( 'for' ( LT )* '(' ( ( LT )* forStatementInitialiserPart )? ( LT )* ';' ( ( LT )* condition= expression )? ( LT )* ';' ( ( LT )* incr= expression )? ( LT )* ')' ( LT )* statement -> ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:166:4: 'for' ( LT )* '(' ( ( LT )* forStatementInitialiserPart )? ( LT )* ';' ( ( LT )* condition= expression )? ( LT )* ';' ( ( LT )* incr= expression )? ( LT )* ')' ( LT )* statement
			{
			DebugLocation(166, 4);
			string_literal126=(IToken)Match(input,92,Follow._92_in_forStatement1062); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_92.Add(string_literal126);

			DebugLocation(166, 10);
			// JavaScript.g:166:10: ( LT )*
			try { DebugEnterSubRule(58);
			while (true)
			{
				int alt58=2;
				try { DebugEnterDecision(58, false);
				int LA58_1 = input.LA(1);

				if ((LA58_1==LT))
				{
					alt58 = 1;
				}


				} finally { DebugExitDecision(58); }
				switch ( alt58 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:10: LT
					{
					DebugLocation(166, 10);
					LT127=(IToken)Match(input,LT,Follow._LT_in_forStatement1064); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT127);


					}
					break;

				default:
					goto loop58;
				}
			}

			loop58:
				;

			} finally { DebugExitSubRule(58); }

			DebugLocation(166, 14);
			char_literal128=(IToken)Match(input,48,Follow._48_in_forStatement1067); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal128);

			DebugLocation(166, 18);
			// JavaScript.g:166:18: ( ( LT )* forStatementInitialiserPart )?
			int alt60=2;
			try { DebugEnterSubRule(60);
			try { DebugEnterDecision(60, false);
			try
			{
				alt60 = dfa60.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(60); }
			switch (alt60)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:166:19: ( LT )* forStatementInitialiserPart
				{
				DebugLocation(166, 19);
				// JavaScript.g:166:19: ( LT )*
				try { DebugEnterSubRule(59);
				while (true)
				{
					int alt59=2;
					try { DebugEnterDecision(59, false);
					int LA59_1 = input.LA(1);

					if ((LA59_1==LT))
					{
						alt59 = 1;
					}


					} finally { DebugExitDecision(59); }
					switch ( alt59 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:166:19: LT
						{
						DebugLocation(166, 19);
						LT129=(IToken)Match(input,LT,Follow._LT_in_forStatement1070); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT129);


						}
						break;

					default:
						goto loop59;
					}
				}

				loop59:
					;

				} finally { DebugExitSubRule(59); }

				DebugLocation(166, 23);
				PushFollow(Follow._forStatementInitialiserPart_in_forStatement1073);
				forStatementInitialiserPart130=forStatementInitialiserPart();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_forStatementInitialiserPart.Add(forStatementInitialiserPart130.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(60); }

			DebugLocation(166, 53);
			// JavaScript.g:166:53: ( LT )*
			try { DebugEnterSubRule(61);
			while (true)
			{
				int alt61=2;
				try { DebugEnterDecision(61, false);
				int LA61_1 = input.LA(1);

				if ((LA61_1==LT))
				{
					alt61 = 1;
				}


				} finally { DebugExitDecision(61); }
				switch ( alt61 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:53: LT
					{
					DebugLocation(166, 53);
					LT131=(IToken)Match(input,LT,Follow._LT_in_forStatement1077); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT131);


					}
					break;

				default:
					goto loop61;
				}
			}

			loop61:
				;

			} finally { DebugExitSubRule(61); }

			DebugLocation(166, 57);
			char_literal132=(IToken)Match(input,63,Follow._63_in_forStatement1080); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal132);

			DebugLocation(166, 61);
			// JavaScript.g:166:61: ( ( LT )* condition= expression )?
			int alt63=2;
			try { DebugEnterSubRule(63);
			try { DebugEnterDecision(63, false);
			try
			{
				alt63 = dfa63.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(63); }
			switch (alt63)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:166:62: ( LT )* condition= expression
				{
				DebugLocation(166, 62);
				// JavaScript.g:166:62: ( LT )*
				try { DebugEnterSubRule(62);
				while (true)
				{
					int alt62=2;
					try { DebugEnterDecision(62, false);
					int LA62_1 = input.LA(1);

					if ((LA62_1==LT))
					{
						alt62 = 1;
					}


					} finally { DebugExitDecision(62); }
					switch ( alt62 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:166:62: LT
						{
						DebugLocation(166, 62);
						LT133=(IToken)Match(input,LT,Follow._LT_in_forStatement1083); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT133);


						}
						break;

					default:
						goto loop62;
					}
				}

				loop62:
					;

				} finally { DebugExitSubRule(62); }

				DebugLocation(166, 75);
				PushFollow(Follow._expression_in_forStatement1088);
				condition=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(condition.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(63); }

			DebugLocation(166, 89);
			// JavaScript.g:166:89: ( LT )*
			try { DebugEnterSubRule(64);
			while (true)
			{
				int alt64=2;
				try { DebugEnterDecision(64, false);
				int LA64_1 = input.LA(1);

				if ((LA64_1==LT))
				{
					alt64 = 1;
				}


				} finally { DebugExitDecision(64); }
				switch ( alt64 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:89: LT
					{
					DebugLocation(166, 89);
					LT134=(IToken)Match(input,LT,Follow._LT_in_forStatement1092); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT134);


					}
					break;

				default:
					goto loop64;
				}
			}

			loop64:
				;

			} finally { DebugExitSubRule(64); }

			DebugLocation(166, 93);
			char_literal135=(IToken)Match(input,63,Follow._63_in_forStatement1095); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal135);

			DebugLocation(166, 97);
			// JavaScript.g:166:97: ( ( LT )* incr= expression )?
			int alt66=2;
			try { DebugEnterSubRule(66);
			try { DebugEnterDecision(66, false);
			try
			{
				alt66 = dfa66.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(66); }
			switch (alt66)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:166:98: ( LT )* incr= expression
				{
				DebugLocation(166, 98);
				// JavaScript.g:166:98: ( LT )*
				try { DebugEnterSubRule(65);
				while (true)
				{
					int alt65=2;
					try { DebugEnterDecision(65, false);
					int LA65_1 = input.LA(1);

					if ((LA65_1==LT))
					{
						alt65 = 1;
					}


					} finally { DebugExitDecision(65); }
					switch ( alt65 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:166:98: LT
						{
						DebugLocation(166, 98);
						LT136=(IToken)Match(input,LT,Follow._LT_in_forStatement1098); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT136);


						}
						break;

					default:
						goto loop65;
					}
				}

				loop65:
					;

				} finally { DebugExitSubRule(65); }

				DebugLocation(166, 106);
				PushFollow(Follow._expression_in_forStatement1103);
				incr=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(incr.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(66); }

			DebugLocation(166, 120);
			// JavaScript.g:166:120: ( LT )*
			try { DebugEnterSubRule(67);
			while (true)
			{
				int alt67=2;
				try { DebugEnterDecision(67, false);
				int LA67_1 = input.LA(1);

				if ((LA67_1==LT))
				{
					alt67 = 1;
				}


				} finally { DebugExitDecision(67); }
				switch ( alt67 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:120: LT
					{
					DebugLocation(166, 120);
					LT137=(IToken)Match(input,LT,Follow._LT_in_forStatement1107); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT137);


					}
					break;

				default:
					goto loop67;
				}
			}

			loop67:
				;

			} finally { DebugExitSubRule(67); }

			DebugLocation(166, 124);
			char_literal138=(IToken)Match(input,49,Follow._49_in_forStatement1110); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal138);

			DebugLocation(166, 128);
			// JavaScript.g:166:128: ( LT )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==LT))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:128: LT
					{
					DebugLocation(166, 128);
					LT139=(IToken)Match(input,LT,Follow._LT_in_forStatement1112); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT139);


					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }

			DebugLocation(166, 132);
			PushFollow(Follow._statement_in_forStatement1115);
			statement140=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement140.Tree);


			{
			// AST REWRITE
			// elements: 92, forStatementInitialiserPart, condition, incr, statement
			// token labels: 
			// rule labels: condition, incr, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition",condition!=null?condition.Tree:null);
			RewriteRuleSubtreeStream stream_incr=new RewriteRuleSubtreeStream(adaptor,"rule incr",incr!=null?incr.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 167:3: -> ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement )
			{
				DebugLocation(167, 6);
				// JavaScript.g:167:6: ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(167, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ForStatement(stream_92.NextToken()), root_1);

				DebugLocation(168, 8);
				// JavaScript.g:168:8: ^( FORSTMTINIT ( forStatementInitialiserPart )? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(168, 10);
				root_2 = (CommonTree)adaptor.BecomeRoot(new ForStatementInitializer(FORSTMTINIT), root_2);

				DebugLocation(168, 52);
				// JavaScript.g:168:52: ( forStatementInitialiserPart )?
				if (stream_forStatementInitialiserPart.HasNext)
				{
					DebugLocation(168, 52);
					adaptor.AddChild(root_2, stream_forStatementInitialiserPart.NextTree());

				}
				stream_forStatementInitialiserPart.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(169, 8);
				// JavaScript.g:169:8: ^( FORSTMTCOND ( $condition)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(169, 10);
				root_2 = (CommonTree)adaptor.BecomeRoot(new ForStatementCondition(FORSTMTCOND), root_2);

				DebugLocation(169, 51);
				// JavaScript.g:169:51: ( $condition)?
				if (stream_condition.HasNext)
				{
					DebugLocation(169, 51);
					adaptor.AddChild(root_2, stream_condition.NextTree());

				}
				stream_condition.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(170, 8);
				// JavaScript.g:170:8: ^( FORSTMTINCR ( $incr)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(170, 10);
				root_2 = (CommonTree)adaptor.BecomeRoot(new ForStatementIncrementer(FORSTMTINCR), root_2);

				DebugLocation(170, 53);
				// JavaScript.g:170:53: ( $incr)?
				if (stream_incr.HasNext)
				{
					DebugLocation(170, 53);
					adaptor.AddChild(root_2, stream_incr.NextTree());

				}
				stream_incr.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(171, 8);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 24);
			LeaveRule("forStatement", 24);
			LeaveRule_forStatement();
			if (state.backtracking > 0) { Memoize(input, 24, forStatement_StartIndex); }

		}
		DebugLocation(172, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_forStatementInitialiserPart();
	partial void LeaveRule_forStatementInitialiserPart();
	// $ANTLR start "forStatementInitialiserPart"
	// JavaScript.g:174:1: forStatementInitialiserPart : ( expressionNoIn | 'var' ( LT )* variableDeclarationListNoIn -> ^( 'var' variableDeclarationListNoIn ) );
	[GrammarRule("forStatementInitialiserPart")]
	private AstParserRuleReturnScope<CommonTree, IToken> forStatementInitialiserPart()
	{
		EnterRule_forStatementInitialiserPart();
		EnterRule("forStatementInitialiserPart", 25);
		TraceIn("forStatementInitialiserPart", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forStatementInitialiserPart_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal142 = default(IToken);
		IToken LT143 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expressionNoIn141 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationListNoIn144 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal142_tree = default(CommonTree);
		CommonTree LT143_tree = default(CommonTree);
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_variableDeclarationListNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationListNoIn");
		try { DebugEnterRule(GrammarFileName, "forStatementInitialiserPart");
		DebugLocation(174, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }

			// JavaScript.g:175:2: ( expressionNoIn | 'var' ( LT )* variableDeclarationListNoIn -> ^( 'var' variableDeclarationListNoIn ) )
			int alt70=2;
			try { DebugEnterDecision(70, false);
			int LA70_1 = input.LA(1);

			if ((LA70_1==Identifier||LA70_1==NumericLiteral||LA70_1==StringLiteral||LA70_1==40||LA70_1==48||(LA70_1>=52 && LA70_1<=53)||(LA70_1>=56 && LA70_1<=57)||LA70_1==78||LA70_1==87||LA70_1==90||LA70_1==93||(LA70_1>=97 && LA70_1<=98)||LA70_1==101||LA70_1==103||LA70_1==105||LA70_1==107||LA70_1==110||LA70_1==115))
			{
				alt70 = 1;
			}
			else if ((LA70_1==106))
			{
				alt70 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 70, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(70); }
			switch (alt70)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:175:4: expressionNoIn
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(175, 4);
				PushFollow(Follow._expressionNoIn_in_forStatementInitialiserPart1211);
				expressionNoIn141=expressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionNoIn141.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:176:4: 'var' ( LT )* variableDeclarationListNoIn
				{
				DebugLocation(176, 4);
				string_literal142=(IToken)Match(input,106,Follow._106_in_forStatementInitialiserPart1216); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_106.Add(string_literal142);

				DebugLocation(176, 10);
				// JavaScript.g:176:10: ( LT )*
				try { DebugEnterSubRule(69);
				while (true)
				{
					int alt69=2;
					try { DebugEnterDecision(69, false);
					int LA69_1 = input.LA(1);

					if ((LA69_1==LT))
					{
						alt69 = 1;
					}


					} finally { DebugExitDecision(69); }
					switch ( alt69 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:176:10: LT
						{
						DebugLocation(176, 10);
						LT143=(IToken)Match(input,LT,Follow._LT_in_forStatementInitialiserPart1218); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT143);


						}
						break;

					default:
						goto loop69;
					}
				}

				loop69:
					;

				} finally { DebugExitSubRule(69); }

				DebugLocation(176, 14);
				PushFollow(Follow._variableDeclarationListNoIn_in_forStatementInitialiserPart1221);
				variableDeclarationListNoIn144=variableDeclarationListNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDeclarationListNoIn.Add(variableDeclarationListNoIn144.Tree);


				{
				// AST REWRITE
				// elements: 106, variableDeclarationListNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 177:3: -> ^( 'var' variableDeclarationListNoIn )
				{
					DebugLocation(177, 6);
					// JavaScript.g:177:6: ^( 'var' variableDeclarationListNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(177, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot(new VariableStatement(stream_106.NextToken()), root_1);

					DebugLocation(177, 38);
					adaptor.AddChild(root_1, stream_variableDeclarationListNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatementInitialiserPart", 25);
			LeaveRule("forStatementInitialiserPart", 25);
			LeaveRule_forStatementInitialiserPart();
			if (state.backtracking > 0) { Memoize(input, 25, forStatementInitialiserPart_StartIndex); }

		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatementInitialiserPart"); }
		return retval;

	}
	// $ANTLR end "forStatementInitialiserPart"

	partial void EnterRule_forInStatement();
	partial void LeaveRule_forInStatement();
	// $ANTLR start "forInStatement"
	// JavaScript.g:180:1: forInStatement : 'for' ( LT )* '(' ( LT )* forInStatementInitialiserPart ( LT )* 'in' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'for' forInStatementInitialiserPart expression statement ) ;
	[GrammarRule("forInStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInStatement()
	{
		EnterRule_forInStatement();
		EnterRule("forInStatement", 26);
		TraceIn("forInStatement", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forInStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal145 = default(IToken);
		IToken LT146 = default(IToken);
		IToken char_literal147 = default(IToken);
		IToken LT148 = default(IToken);
		IToken LT150 = default(IToken);
		IToken string_literal151 = default(IToken);
		IToken LT152 = default(IToken);
		IToken LT154 = default(IToken);
		IToken char_literal155 = default(IToken);
		IToken LT156 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> forInStatementInitialiserPart149 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression153 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement157 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal145_tree = default(CommonTree);
		CommonTree LT146_tree = default(CommonTree);
		CommonTree char_literal147_tree = default(CommonTree);
		CommonTree LT148_tree = default(CommonTree);
		CommonTree LT150_tree = default(CommonTree);
		CommonTree string_literal151_tree = default(CommonTree);
		CommonTree LT152_tree = default(CommonTree);
		CommonTree LT154_tree = default(CommonTree);
		CommonTree char_literal155_tree = default(CommonTree);
		CommonTree LT156_tree = default(CommonTree);
		RewriteRuleITokenStream stream_92=new RewriteRuleITokenStream(adaptor,"token 92");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_forInStatementInitialiserPart=new RewriteRuleSubtreeStream(adaptor,"rule forInStatementInitialiserPart");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "forInStatement");
		DebugLocation(180, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }

			// JavaScript.g:181:2: ( 'for' ( LT )* '(' ( LT )* forInStatementInitialiserPart ( LT )* 'in' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'for' forInStatementInitialiserPart expression statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:181:4: 'for' ( LT )* '(' ( LT )* forInStatementInitialiserPart ( LT )* 'in' ( LT )* expression ( LT )* ')' ( LT )* statement
			{
			DebugLocation(181, 4);
			string_literal145=(IToken)Match(input,92,Follow._92_in_forInStatement1249); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_92.Add(string_literal145);

			DebugLocation(181, 10);
			// JavaScript.g:181:10: ( LT )*
			try { DebugEnterSubRule(71);
			while (true)
			{
				int alt71=2;
				try { DebugEnterDecision(71, false);
				int LA71_1 = input.LA(1);

				if ((LA71_1==LT))
				{
					alt71 = 1;
				}


				} finally { DebugExitDecision(71); }
				switch ( alt71 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:10: LT
					{
					DebugLocation(181, 10);
					LT146=(IToken)Match(input,LT,Follow._LT_in_forInStatement1251); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT146);


					}
					break;

				default:
					goto loop71;
				}
			}

			loop71:
				;

			} finally { DebugExitSubRule(71); }

			DebugLocation(181, 14);
			char_literal147=(IToken)Match(input,48,Follow._48_in_forInStatement1254); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal147);

			DebugLocation(181, 18);
			// JavaScript.g:181:18: ( LT )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==LT))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:18: LT
					{
					DebugLocation(181, 18);
					LT148=(IToken)Match(input,LT,Follow._LT_in_forInStatement1256); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT148);


					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }

			DebugLocation(181, 22);
			PushFollow(Follow._forInStatementInitialiserPart_in_forInStatement1259);
			forInStatementInitialiserPart149=forInStatementInitialiserPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_forInStatementInitialiserPart.Add(forInStatementInitialiserPart149.Tree);
			DebugLocation(181, 52);
			// JavaScript.g:181:52: ( LT )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==LT))
				{
					alt73 = 1;
				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:52: LT
					{
					DebugLocation(181, 52);
					LT150=(IToken)Match(input,LT,Follow._LT_in_forInStatement1261); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT150);


					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }

			DebugLocation(181, 56);
			string_literal151=(IToken)Match(input,95,Follow._95_in_forInStatement1264); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_95.Add(string_literal151);

			DebugLocation(181, 61);
			// JavaScript.g:181:61: ( LT )*
			try { DebugEnterSubRule(74);
			while (true)
			{
				int alt74=2;
				try { DebugEnterDecision(74, false);
				int LA74_1 = input.LA(1);

				if ((LA74_1==LT))
				{
					alt74 = 1;
				}


				} finally { DebugExitDecision(74); }
				switch ( alt74 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:61: LT
					{
					DebugLocation(181, 61);
					LT152=(IToken)Match(input,LT,Follow._LT_in_forInStatement1266); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT152);


					}
					break;

				default:
					goto loop74;
				}
			}

			loop74:
				;

			} finally { DebugExitSubRule(74); }

			DebugLocation(181, 65);
			PushFollow(Follow._expression_in_forInStatement1269);
			expression153=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression153.Tree);
			DebugLocation(181, 76);
			// JavaScript.g:181:76: ( LT )*
			try { DebugEnterSubRule(75);
			while (true)
			{
				int alt75=2;
				try { DebugEnterDecision(75, false);
				int LA75_1 = input.LA(1);

				if ((LA75_1==LT))
				{
					alt75 = 1;
				}


				} finally { DebugExitDecision(75); }
				switch ( alt75 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:76: LT
					{
					DebugLocation(181, 76);
					LT154=(IToken)Match(input,LT,Follow._LT_in_forInStatement1271); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT154);


					}
					break;

				default:
					goto loop75;
				}
			}

			loop75:
				;

			} finally { DebugExitSubRule(75); }

			DebugLocation(181, 80);
			char_literal155=(IToken)Match(input,49,Follow._49_in_forInStatement1274); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal155);

			DebugLocation(181, 84);
			// JavaScript.g:181:84: ( LT )*
			try { DebugEnterSubRule(76);
			while (true)
			{
				int alt76=2;
				try { DebugEnterDecision(76, false);
				int LA76_1 = input.LA(1);

				if ((LA76_1==LT))
				{
					alt76 = 1;
				}


				} finally { DebugExitDecision(76); }
				switch ( alt76 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:84: LT
					{
					DebugLocation(181, 84);
					LT156=(IToken)Match(input,LT,Follow._LT_in_forInStatement1276); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT156);


					}
					break;

				default:
					goto loop76;
				}
			}

			loop76:
				;

			} finally { DebugExitSubRule(76); }

			DebugLocation(181, 88);
			PushFollow(Follow._statement_in_forInStatement1279);
			statement157=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement157.Tree);


			{
			// AST REWRITE
			// elements: 92, forInStatementInitialiserPart, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 182:3: -> ^( 'for' forInStatementInitialiserPart expression statement )
			{
				DebugLocation(182, 6);
				// JavaScript.g:182:6: ^( 'for' forInStatementInitialiserPart expression statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(182, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ForInStatement(stream_92.NextToken()), root_1);

				DebugLocation(183, 4);
				adaptor.AddChild(root_1, stream_forInStatementInitialiserPart.NextTree());
				DebugLocation(184, 4);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(185, 4);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInStatement", 26);
			LeaveRule("forInStatement", 26);
			LeaveRule_forInStatement();
			if (state.backtracking > 0) { Memoize(input, 26, forInStatement_StartIndex); }

		}
		DebugLocation(186, 1);
		} finally { DebugExitRule(GrammarFileName, "forInStatement"); }
		return retval;

	}
	// $ANTLR end "forInStatement"

	partial void EnterRule_forInStatementInitialiserPart();
	partial void LeaveRule_forInStatementInitialiserPart();
	// $ANTLR start "forInStatementInitialiserPart"
	// JavaScript.g:188:1: forInStatementInitialiserPart : ( leftHandSideExpression | 'var' ( LT )* variableDeclarationNoIn -> variableDeclarationNoIn );
	[GrammarRule("forInStatementInitialiserPart")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInStatementInitialiserPart()
	{
		EnterRule_forInStatementInitialiserPart();
		EnterRule("forInStatementInitialiserPart", 27);
		TraceIn("forInStatementInitialiserPart", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forInStatementInitialiserPart_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal159 = default(IToken);
		IToken LT160 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> leftHandSideExpression158 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn161 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal159_tree = default(CommonTree);
		CommonTree LT160_tree = default(CommonTree);
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_variableDeclarationNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationNoIn");
		try { DebugEnterRule(GrammarFileName, "forInStatementInitialiserPart");
		DebugLocation(188, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }

			// JavaScript.g:189:2: ( leftHandSideExpression | 'var' ( LT )* variableDeclarationNoIn -> variableDeclarationNoIn )
			int alt78=2;
			try { DebugEnterDecision(78, false);
			int LA78_1 = input.LA(1);

			if ((LA78_1==Identifier||LA78_1==NumericLiteral||LA78_1==StringLiteral||LA78_1==48||LA78_1==78||LA78_1==90||LA78_1==93||(LA78_1>=97 && LA78_1<=98)||LA78_1==101||LA78_1==103||LA78_1==110))
			{
				alt78 = 1;
			}
			else if ((LA78_1==106))
			{
				alt78 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 78, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(78); }
			switch (alt78)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:189:4: leftHandSideExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(189, 4);
				PushFollow(Follow._leftHandSideExpression_in_forInStatementInitialiserPart1321);
				leftHandSideExpression158=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression158.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:190:4: 'var' ( LT )* variableDeclarationNoIn
				{
				DebugLocation(190, 4);
				string_literal159=(IToken)Match(input,106,Follow._106_in_forInStatementInitialiserPart1326); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_106.Add(string_literal159);

				DebugLocation(190, 10);
				// JavaScript.g:190:10: ( LT )*
				try { DebugEnterSubRule(77);
				while (true)
				{
					int alt77=2;
					try { DebugEnterDecision(77, false);
					int LA77_1 = input.LA(1);

					if ((LA77_1==LT))
					{
						alt77 = 1;
					}


					} finally { DebugExitDecision(77); }
					switch ( alt77 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:190:10: LT
						{
						DebugLocation(190, 10);
						LT160=(IToken)Match(input,LT,Follow._LT_in_forInStatementInitialiserPart1328); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT160);


						}
						break;

					default:
						goto loop77;
					}
				}

				loop77:
					;

				} finally { DebugExitSubRule(77); }

				DebugLocation(190, 14);
				PushFollow(Follow._variableDeclarationNoIn_in_forInStatementInitialiserPart1331);
				variableDeclarationNoIn161=variableDeclarationNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn161.Tree);


				{
				// AST REWRITE
				// elements: variableDeclarationNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 190:38: -> variableDeclarationNoIn
				{
					DebugLocation(190, 41);
					adaptor.AddChild(root_0, stream_variableDeclarationNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInStatementInitialiserPart", 27);
			LeaveRule("forInStatementInitialiserPart", 27);
			LeaveRule_forInStatementInitialiserPart();
			if (state.backtracking > 0) { Memoize(input, 27, forInStatementInitialiserPart_StartIndex); }

		}
		DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "forInStatementInitialiserPart"); }
		return retval;

	}
	// $ANTLR end "forInStatementInitialiserPart"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// JavaScript.g:193:1: continueStatement : 'continue' ( Identifier )? ( LT | ';' ) -> ^( 'continue' ( Identifier )? ) ;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 28);
		TraceIn("continueStatement", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int continueStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal162 = default(IToken);
		IToken Identifier163 = default(IToken);
		IToken LT164 = default(IToken);
		IToken char_literal165 = default(IToken);

		CommonTree string_literal162_tree = default(CommonTree);
		CommonTree Identifier163_tree = default(CommonTree);
		CommonTree LT164_tree = default(CommonTree);
		CommonTree char_literal165_tree = default(CommonTree);
		RewriteRuleITokenStream stream_85=new RewriteRuleITokenStream(adaptor,"token 85");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(193, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }

			// JavaScript.g:194:2: ( 'continue' ( Identifier )? ( LT | ';' ) -> ^( 'continue' ( Identifier )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:194:4: 'continue' ( Identifier )? ( LT | ';' )
			{
			DebugLocation(194, 4);
			string_literal162=(IToken)Match(input,85,Follow._85_in_continueStatement1346); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_85.Add(string_literal162);

			DebugLocation(194, 15);
			// JavaScript.g:194:15: ( Identifier )?
			int alt79=2;
			try { DebugEnterSubRule(79);
			try { DebugEnterDecision(79, false);
			int LA79_1 = input.LA(1);

			if ((LA79_1==Identifier))
			{
				alt79 = 1;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:194:15: Identifier
				{
				DebugLocation(194, 15);
				Identifier163=(IToken)Match(input,Identifier,Follow._Identifier_in_continueStatement1348); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier163);


				}
				break;

			}
			} finally { DebugExitSubRule(79); }

			DebugLocation(194, 27);
			// JavaScript.g:194:27: ( LT | ';' )
			int alt80=2;
			try { DebugEnterSubRule(80);
			try { DebugEnterDecision(80, false);
			int LA80_1 = input.LA(1);

			if ((LA80_1==LT))
			{
				alt80 = 1;
			}
			else if ((LA80_1==63))
			{
				alt80 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 80, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:194:28: LT
				{
				DebugLocation(194, 28);
				LT164=(IToken)Match(input,LT,Follow._LT_in_continueStatement1352); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT164);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:194:33: ';'
				{
				DebugLocation(194, 33);
				char_literal165=(IToken)Match(input,63,Follow._63_in_continueStatement1356); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal165);


				}
				break;

			}
			} finally { DebugExitSubRule(80); }



			{
			// AST REWRITE
			// elements: 85, Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 195:3: -> ^( 'continue' ( Identifier )? )
			{
				DebugLocation(195, 6);
				// JavaScript.g:195:6: ^( 'continue' ( Identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(195, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ContinueStatement(stream_85.NextToken()), root_1);

				DebugLocation(195, 43);
				// JavaScript.g:195:43: ( Identifier )?
				if (stream_Identifier.HasNext)
				{
					DebugLocation(195, 43);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continueStatement", 28);
			LeaveRule("continueStatement", 28);
			LeaveRule_continueStatement();
			if (state.backtracking > 0) { Memoize(input, 28, continueStatement_StartIndex); }

		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// JavaScript.g:198:1: breakStatement : 'break' ( Identifier )? ( LT | ';' ) -> ^( 'break' ( Identifier )? ) ;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 29);
		TraceIn("breakStatement", 29);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int breakStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal166 = default(IToken);
		IToken Identifier167 = default(IToken);
		IToken LT168 = default(IToken);
		IToken char_literal169 = default(IToken);

		CommonTree string_literal166_tree = default(CommonTree);
		CommonTree Identifier167_tree = default(CommonTree);
		CommonTree LT168_tree = default(CommonTree);
		CommonTree char_literal169_tree = default(CommonTree);
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(198, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }

			// JavaScript.g:199:2: ( 'break' ( Identifier )? ( LT | ';' ) -> ^( 'break' ( Identifier )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:199:4: 'break' ( Identifier )? ( LT | ';' )
			{
			DebugLocation(199, 4);
			string_literal166=(IToken)Match(input,82,Follow._82_in_breakStatement1390); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_82.Add(string_literal166);

			DebugLocation(199, 12);
			// JavaScript.g:199:12: ( Identifier )?
			int alt81=2;
			try { DebugEnterSubRule(81);
			try { DebugEnterDecision(81, false);
			int LA81_1 = input.LA(1);

			if ((LA81_1==Identifier))
			{
				alt81 = 1;
			}
			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:199:12: Identifier
				{
				DebugLocation(199, 12);
				Identifier167=(IToken)Match(input,Identifier,Follow._Identifier_in_breakStatement1392); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier167);


				}
				break;

			}
			} finally { DebugExitSubRule(81); }

			DebugLocation(199, 24);
			// JavaScript.g:199:24: ( LT | ';' )
			int alt82=2;
			try { DebugEnterSubRule(82);
			try { DebugEnterDecision(82, false);
			int LA82_1 = input.LA(1);

			if ((LA82_1==LT))
			{
				alt82 = 1;
			}
			else if ((LA82_1==63))
			{
				alt82 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 82, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:199:25: LT
				{
				DebugLocation(199, 25);
				LT168=(IToken)Match(input,LT,Follow._LT_in_breakStatement1396); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT168);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:199:30: ';'
				{
				DebugLocation(199, 30);
				char_literal169=(IToken)Match(input,63,Follow._63_in_breakStatement1400); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal169);


				}
				break;

			}
			} finally { DebugExitSubRule(82); }



			{
			// AST REWRITE
			// elements: 82, Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 199:35: -> ^( 'break' ( Identifier )? )
			{
				DebugLocation(199, 38);
				// JavaScript.g:199:38: ^( 'break' ( Identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(199, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(new BreakStatement(stream_82.NextToken()), root_1);

				DebugLocation(199, 69);
				// JavaScript.g:199:69: ( Identifier )?
				if (stream_Identifier.HasNext)
				{
					DebugLocation(199, 69);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("breakStatement", 29);
			LeaveRule("breakStatement", 29);
			LeaveRule_breakStatement();
			if (state.backtracking > 0) { Memoize(input, 29, breakStatement_StartIndex); }

		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// JavaScript.g:202:1: returnStatement : 'return' ( expression )? ( LT | ';' ) -> ^( 'return' ( expression )? ) ;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 30);
		TraceIn("returnStatement", 30);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int returnStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal170 = default(IToken);
		IToken LT172 = default(IToken);
		IToken char_literal173 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression171 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal170_tree = default(CommonTree);
		CommonTree LT172_tree = default(CommonTree);
		CommonTree char_literal173_tree = default(CommonTree);
		RewriteRuleITokenStream stream_99=new RewriteRuleITokenStream(adaptor,"token 99");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(202, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }

			// JavaScript.g:203:2: ( 'return' ( expression )? ( LT | ';' ) -> ^( 'return' ( expression )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:203:4: 'return' ( expression )? ( LT | ';' )
			{
			DebugLocation(203, 4);
			string_literal170=(IToken)Match(input,99,Follow._99_in_returnStatement1431); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_99.Add(string_literal170);

			DebugLocation(203, 13);
			// JavaScript.g:203:13: ( expression )?
			int alt83=2;
			try { DebugEnterSubRule(83);
			try { DebugEnterDecision(83, false);
			int LA83_1 = input.LA(1);

			if ((LA83_1==Identifier||LA83_1==NumericLiteral||LA83_1==StringLiteral||LA83_1==40||LA83_1==48||(LA83_1>=52 && LA83_1<=53)||(LA83_1>=56 && LA83_1<=57)||LA83_1==78||LA83_1==87||LA83_1==90||LA83_1==93||(LA83_1>=97 && LA83_1<=98)||LA83_1==101||LA83_1==103||LA83_1==105||LA83_1==107||LA83_1==110||LA83_1==115))
			{
				alt83 = 1;
			}
			} finally { DebugExitDecision(83); }
			switch (alt83)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:203:13: expression
				{
				DebugLocation(203, 13);
				PushFollow(Follow._expression_in_returnStatement1433);
				expression171=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression171.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(83); }

			DebugLocation(203, 25);
			// JavaScript.g:203:25: ( LT | ';' )
			int alt84=2;
			try { DebugEnterSubRule(84);
			try { DebugEnterDecision(84, false);
			int LA84_1 = input.LA(1);

			if ((LA84_1==LT))
			{
				alt84 = 1;
			}
			else if ((LA84_1==63))
			{
				alt84 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 84, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(84); }
			switch (alt84)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:203:26: LT
				{
				DebugLocation(203, 26);
				LT172=(IToken)Match(input,LT,Follow._LT_in_returnStatement1437); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT172);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:203:31: ';'
				{
				DebugLocation(203, 31);
				char_literal173=(IToken)Match(input,63,Follow._63_in_returnStatement1441); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal173);


				}
				break;

			}
			} finally { DebugExitSubRule(84); }



			{
			// AST REWRITE
			// elements: 99, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 203:36: -> ^( 'return' ( expression )? )
			{
				DebugLocation(203, 39);
				// JavaScript.g:203:39: ^( 'return' ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(203, 41);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ReturnStatement(stream_99.NextToken()), root_1);

				DebugLocation(203, 72);
				// JavaScript.g:203:72: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(203, 72);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnStatement", 30);
			LeaveRule("returnStatement", 30);
			LeaveRule_returnStatement();
			if (state.backtracking > 0) { Memoize(input, 30, returnStatement_StartIndex); }

		}
		DebugLocation(204, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// JavaScript.g:206:1: withStatement : 'with' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'with' expression statement ) ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 31);
		TraceIn("withStatement", 31);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int withStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal174 = default(IToken);
		IToken LT175 = default(IToken);
		IToken char_literal176 = default(IToken);
		IToken LT177 = default(IToken);
		IToken LT179 = default(IToken);
		IToken char_literal180 = default(IToken);
		IToken LT181 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression178 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement182 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal174_tree = default(CommonTree);
		CommonTree LT175_tree = default(CommonTree);
		CommonTree char_literal176_tree = default(CommonTree);
		CommonTree LT177_tree = default(CommonTree);
		CommonTree LT179_tree = default(CommonTree);
		CommonTree char_literal180_tree = default(CommonTree);
		CommonTree LT181_tree = default(CommonTree);
		RewriteRuleITokenStream stream_109=new RewriteRuleITokenStream(adaptor,"token 109");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(206, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }

			// JavaScript.g:207:2: ( 'with' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'with' expression statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:207:4: 'with' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement
			{
			DebugLocation(207, 4);
			string_literal174=(IToken)Match(input,109,Follow._109_in_withStatement1468); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_109.Add(string_literal174);

			DebugLocation(207, 11);
			// JavaScript.g:207:11: ( LT )*
			try { DebugEnterSubRule(85);
			while (true)
			{
				int alt85=2;
				try { DebugEnterDecision(85, false);
				int LA85_1 = input.LA(1);

				if ((LA85_1==LT))
				{
					alt85 = 1;
				}


				} finally { DebugExitDecision(85); }
				switch ( alt85 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:11: LT
					{
					DebugLocation(207, 11);
					LT175=(IToken)Match(input,LT,Follow._LT_in_withStatement1470); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT175);


					}
					break;

				default:
					goto loop85;
				}
			}

			loop85:
				;

			} finally { DebugExitSubRule(85); }

			DebugLocation(207, 15);
			char_literal176=(IToken)Match(input,48,Follow._48_in_withStatement1473); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal176);

			DebugLocation(207, 19);
			// JavaScript.g:207:19: ( LT )*
			try { DebugEnterSubRule(86);
			while (true)
			{
				int alt86=2;
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==LT))
				{
					alt86 = 1;
				}


				} finally { DebugExitDecision(86); }
				switch ( alt86 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:19: LT
					{
					DebugLocation(207, 19);
					LT177=(IToken)Match(input,LT,Follow._LT_in_withStatement1475); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT177);


					}
					break;

				default:
					goto loop86;
				}
			}

			loop86:
				;

			} finally { DebugExitSubRule(86); }

			DebugLocation(207, 23);
			PushFollow(Follow._expression_in_withStatement1478);
			expression178=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression178.Tree);
			DebugLocation(207, 34);
			// JavaScript.g:207:34: ( LT )*
			try { DebugEnterSubRule(87);
			while (true)
			{
				int alt87=2;
				try { DebugEnterDecision(87, false);
				int LA87_1 = input.LA(1);

				if ((LA87_1==LT))
				{
					alt87 = 1;
				}


				} finally { DebugExitDecision(87); }
				switch ( alt87 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:34: LT
					{
					DebugLocation(207, 34);
					LT179=(IToken)Match(input,LT,Follow._LT_in_withStatement1480); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT179);


					}
					break;

				default:
					goto loop87;
				}
			}

			loop87:
				;

			} finally { DebugExitSubRule(87); }

			DebugLocation(207, 38);
			char_literal180=(IToken)Match(input,49,Follow._49_in_withStatement1483); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal180);

			DebugLocation(207, 42);
			// JavaScript.g:207:42: ( LT )*
			try { DebugEnterSubRule(88);
			while (true)
			{
				int alt88=2;
				try { DebugEnterDecision(88, false);
				int LA88_1 = input.LA(1);

				if ((LA88_1==LT))
				{
					alt88 = 1;
				}


				} finally { DebugExitDecision(88); }
				switch ( alt88 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:42: LT
					{
					DebugLocation(207, 42);
					LT181=(IToken)Match(input,LT,Follow._LT_in_withStatement1485); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT181);


					}
					break;

				default:
					goto loop88;
				}
			}

			loop88:
				;

			} finally { DebugExitSubRule(88); }

			DebugLocation(207, 46);
			PushFollow(Follow._statement_in_withStatement1488);
			statement182=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement182.Tree);


			{
			// AST REWRITE
			// elements: 109, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 208:3: -> ^( 'with' expression statement )
			{
				DebugLocation(208, 6);
				// JavaScript.g:208:6: ^( 'with' expression statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(208, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new WithStatement(stream_109.NextToken()), root_1);

				DebugLocation(208, 35);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(208, 46);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withStatement", 31);
			LeaveRule("withStatement", 31);
			LeaveRule_withStatement();
			if (state.backtracking > 0) { Memoize(input, 31, withStatement_StartIndex); }

		}
		DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();
	// $ANTLR start "labelledStatement"
	// JavaScript.g:211:1: labelledStatement : Identifier ( LT )* ':' ( LT )* statement -> ^( ':' Identifier statement ) ;
	[GrammarRule("labelledStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 32);
		TraceIn("labelledStatement", 32);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int labelledStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier183 = default(IToken);
		IToken LT184 = default(IToken);
		IToken char_literal185 = default(IToken);
		IToken LT186 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement187 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Identifier183_tree = default(CommonTree);
		CommonTree LT184_tree = default(CommonTree);
		CommonTree char_literal185_tree = default(CommonTree);
		CommonTree LT186_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(211, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }

			// JavaScript.g:212:2: ( Identifier ( LT )* ':' ( LT )* statement -> ^( ':' Identifier statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:212:4: Identifier ( LT )* ':' ( LT )* statement
			{
			DebugLocation(212, 4);
			Identifier183=(IToken)Match(input,Identifier,Follow._Identifier_in_labelledStatement1517); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier183);

			DebugLocation(212, 15);
			// JavaScript.g:212:15: ( LT )*
			try { DebugEnterSubRule(89);
			while (true)
			{
				int alt89=2;
				try { DebugEnterDecision(89, false);
				int LA89_1 = input.LA(1);

				if ((LA89_1==LT))
				{
					alt89 = 1;
				}


				} finally { DebugExitDecision(89); }
				switch ( alt89 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:212:15: LT
					{
					DebugLocation(212, 15);
					LT184=(IToken)Match(input,LT,Follow._LT_in_labelledStatement1519); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT184);


					}
					break;

				default:
					goto loop89;
				}
			}

			loop89:
				;

			} finally { DebugExitSubRule(89); }

			DebugLocation(212, 19);
			char_literal185=(IToken)Match(input,62,Follow._62_in_labelledStatement1522); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal185);

			DebugLocation(212, 23);
			// JavaScript.g:212:23: ( LT )*
			try { DebugEnterSubRule(90);
			while (true)
			{
				int alt90=2;
				try { DebugEnterDecision(90, false);
				int LA90_1 = input.LA(1);

				if ((LA90_1==LT))
				{
					alt90 = 1;
				}


				} finally { DebugExitDecision(90); }
				switch ( alt90 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:212:23: LT
					{
					DebugLocation(212, 23);
					LT186=(IToken)Match(input,LT,Follow._LT_in_labelledStatement1524); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT186);


					}
					break;

				default:
					goto loop90;
				}
			}

			loop90:
				;

			} finally { DebugExitSubRule(90); }

			DebugLocation(212, 27);
			PushFollow(Follow._statement_in_labelledStatement1527);
			statement187=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement187.Tree);


			{
			// AST REWRITE
			// elements: 62, Identifier, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 213:9: -> ^( ':' Identifier statement )
			{
				DebugLocation(213, 12);
				// JavaScript.g:213:12: ^( ':' Identifier statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(213, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot(new LabeledStatement(stream_62.NextToken()), root_1);

				DebugLocation(213, 41);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(213, 69);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("labelledStatement", 32);
			LeaveRule("labelledStatement", 32);
			LeaveRule_labelledStatement();
			if (state.backtracking > 0) { Memoize(input, 32, labelledStatement_StartIndex); }

		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return retval;

	}
	// $ANTLR end "labelledStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// JavaScript.g:216:1: switchStatement : 'switch' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* caseBlock -> ^( 'switch' expression caseBlock ) ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 33);
		TraceIn("switchStatement", 33);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int switchStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal188 = default(IToken);
		IToken LT189 = default(IToken);
		IToken char_literal190 = default(IToken);
		IToken LT191 = default(IToken);
		IToken LT193 = default(IToken);
		IToken char_literal194 = default(IToken);
		IToken LT195 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression192 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> caseBlock196 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal188_tree = default(CommonTree);
		CommonTree LT189_tree = default(CommonTree);
		CommonTree char_literal190_tree = default(CommonTree);
		CommonTree LT191_tree = default(CommonTree);
		CommonTree LT193_tree = default(CommonTree);
		CommonTree char_literal194_tree = default(CommonTree);
		CommonTree LT195_tree = default(CommonTree);
		RewriteRuleITokenStream stream_100=new RewriteRuleITokenStream(adaptor,"token 100");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_caseBlock=new RewriteRuleSubtreeStream(adaptor,"rule caseBlock");
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(216, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 33)) { return retval; }

			// JavaScript.g:217:2: ( 'switch' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* caseBlock -> ^( 'switch' expression caseBlock ) )
			DebugEnterAlt(1);
			// JavaScript.g:217:4: 'switch' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* caseBlock
			{
			DebugLocation(217, 4);
			string_literal188=(IToken)Match(input,100,Follow._100_in_switchStatement1568); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_100.Add(string_literal188);

			DebugLocation(217, 13);
			// JavaScript.g:217:13: ( LT )*
			try { DebugEnterSubRule(91);
			while (true)
			{
				int alt91=2;
				try { DebugEnterDecision(91, false);
				int LA91_1 = input.LA(1);

				if ((LA91_1==LT))
				{
					alt91 = 1;
				}


				} finally { DebugExitDecision(91); }
				switch ( alt91 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:13: LT
					{
					DebugLocation(217, 13);
					LT189=(IToken)Match(input,LT,Follow._LT_in_switchStatement1570); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT189);


					}
					break;

				default:
					goto loop91;
				}
			}

			loop91:
				;

			} finally { DebugExitSubRule(91); }

			DebugLocation(217, 17);
			char_literal190=(IToken)Match(input,48,Follow._48_in_switchStatement1573); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal190);

			DebugLocation(217, 21);
			// JavaScript.g:217:21: ( LT )*
			try { DebugEnterSubRule(92);
			while (true)
			{
				int alt92=2;
				try { DebugEnterDecision(92, false);
				int LA92_1 = input.LA(1);

				if ((LA92_1==LT))
				{
					alt92 = 1;
				}


				} finally { DebugExitDecision(92); }
				switch ( alt92 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:21: LT
					{
					DebugLocation(217, 21);
					LT191=(IToken)Match(input,LT,Follow._LT_in_switchStatement1575); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT191);


					}
					break;

				default:
					goto loop92;
				}
			}

			loop92:
				;

			} finally { DebugExitSubRule(92); }

			DebugLocation(217, 25);
			PushFollow(Follow._expression_in_switchStatement1578);
			expression192=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression192.Tree);
			DebugLocation(217, 36);
			// JavaScript.g:217:36: ( LT )*
			try { DebugEnterSubRule(93);
			while (true)
			{
				int alt93=2;
				try { DebugEnterDecision(93, false);
				int LA93_1 = input.LA(1);

				if ((LA93_1==LT))
				{
					alt93 = 1;
				}


				} finally { DebugExitDecision(93); }
				switch ( alt93 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:36: LT
					{
					DebugLocation(217, 36);
					LT193=(IToken)Match(input,LT,Follow._LT_in_switchStatement1580); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT193);


					}
					break;

				default:
					goto loop93;
				}
			}

			loop93:
				;

			} finally { DebugExitSubRule(93); }

			DebugLocation(217, 40);
			char_literal194=(IToken)Match(input,49,Follow._49_in_switchStatement1583); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal194);

			DebugLocation(217, 44);
			// JavaScript.g:217:44: ( LT )*
			try { DebugEnterSubRule(94);
			while (true)
			{
				int alt94=2;
				try { DebugEnterDecision(94, false);
				int LA94_1 = input.LA(1);

				if ((LA94_1==LT))
				{
					alt94 = 1;
				}


				} finally { DebugExitDecision(94); }
				switch ( alt94 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:44: LT
					{
					DebugLocation(217, 44);
					LT195=(IToken)Match(input,LT,Follow._LT_in_switchStatement1585); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT195);


					}
					break;

				default:
					goto loop94;
				}
			}

			loop94:
				;

			} finally { DebugExitSubRule(94); }

			DebugLocation(217, 48);
			PushFollow(Follow._caseBlock_in_switchStatement1588);
			caseBlock196=caseBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_caseBlock.Add(caseBlock196.Tree);


			{
			// AST REWRITE
			// elements: 100, expression, caseBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 218:3: -> ^( 'switch' expression caseBlock )
			{
				DebugLocation(218, 6);
				// JavaScript.g:218:6: ^( 'switch' expression caseBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(218, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new SwitchStatement(stream_100.NextToken()), root_1);

				DebugLocation(218, 39);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(218, 50);
				adaptor.AddChild(root_1, stream_caseBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 33);
			LeaveRule("switchStatement", 33);
			LeaveRule_switchStatement();
			if (state.backtracking > 0) { Memoize(input, 33, switchStatement_StartIndex); }

		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_caseBlock();
	partial void LeaveRule_caseBlock();
	// $ANTLR start "caseBlock"
	// JavaScript.g:221:1: caseBlock : '{' ! ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' !;
	[GrammarRule("caseBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> caseBlock()
	{
		EnterRule_caseBlock();
		EnterRule("caseBlock", 34);
		TraceIn("caseBlock", 34);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int caseBlock_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal197 = default(IToken);
		IToken LT198 = default(IToken);
		IToken LT200 = default(IToken);
		IToken LT202 = default(IToken);
		IToken LT204 = default(IToken);
		IToken char_literal205 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> caseClause199 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> defaultClause201 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> caseClause203 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal197_tree = default(CommonTree);
		CommonTree LT198_tree = default(CommonTree);
		CommonTree LT200_tree = default(CommonTree);
		CommonTree LT202_tree = default(CommonTree);
		CommonTree LT204_tree = default(CommonTree);
		CommonTree char_literal205_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "caseBlock");
		DebugLocation(221, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 34)) { return retval; }

			// JavaScript.g:222:2: ( '{' ! ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' !)
			DebugEnterAlt(1);
			// JavaScript.g:222:4: '{' ! ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(222, 7);
			char_literal197=(IToken)Match(input,110,Follow._110_in_caseBlock1617); if (state.failed) return retval;
			DebugLocation(222, 9);
			// JavaScript.g:222:9: ( ( LT !)* caseClause )*
			try { DebugEnterSubRule(96);
			while (true)
			{
				int alt96=2;
				try { DebugEnterDecision(96, false);
				try
				{
					alt96 = dfa96.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(96); }
				switch ( alt96 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:222:10: ( LT !)* caseClause
					{
					DebugLocation(222, 12);
					// JavaScript.g:222:12: ( LT !)*
					try { DebugEnterSubRule(95);
					while (true)
					{
						int alt95=2;
						try { DebugEnterDecision(95, false);
						int LA95_1 = input.LA(1);

						if ((LA95_1==LT))
						{
							alt95 = 1;
						}


						} finally { DebugExitDecision(95); }
						switch ( alt95 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:222:12: LT !
							{
							DebugLocation(222, 12);
							LT198=(IToken)Match(input,LT,Follow._LT_in_caseBlock1621); if (state.failed) return retval;

							}
							break;

						default:
							goto loop95;
						}
					}

					loop95:
						;

					} finally { DebugExitSubRule(95); }

					DebugLocation(222, 15);
					PushFollow(Follow._caseClause_in_caseBlock1625);
					caseClause199=caseClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, caseClause199.Tree);

					}
					break;

				default:
					goto loop96;
				}
			}

			loop96:
				;

			} finally { DebugExitSubRule(96); }

			DebugLocation(222, 28);
			// JavaScript.g:222:28: ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )?
			int alt100=2;
			try { DebugEnterSubRule(100);
			try { DebugEnterDecision(100, false);
			try
			{
				alt100 = dfa100.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(100); }
			switch (alt100)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:222:29: ( LT !)* defaultClause ( ( LT !)* caseClause )*
				{
				DebugLocation(222, 31);
				// JavaScript.g:222:31: ( LT !)*
				try { DebugEnterSubRule(97);
				while (true)
				{
					int alt97=2;
					try { DebugEnterDecision(97, false);
					int LA97_1 = input.LA(1);

					if ((LA97_1==LT))
					{
						alt97 = 1;
					}


					} finally { DebugExitDecision(97); }
					switch ( alt97 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:222:31: LT !
						{
						DebugLocation(222, 31);
						LT200=(IToken)Match(input,LT,Follow._LT_in_caseBlock1630); if (state.failed) return retval;

						}
						break;

					default:
						goto loop97;
					}
				}

				loop97:
					;

				} finally { DebugExitSubRule(97); }

				DebugLocation(222, 34);
				PushFollow(Follow._defaultClause_in_caseBlock1634);
				defaultClause201=defaultClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, defaultClause201.Tree);
				DebugLocation(222, 48);
				// JavaScript.g:222:48: ( ( LT !)* caseClause )*
				try { DebugEnterSubRule(99);
				while (true)
				{
					int alt99=2;
					try { DebugEnterDecision(99, false);
					try
					{
						alt99 = dfa99.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(99); }
					switch ( alt99 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:222:49: ( LT !)* caseClause
						{
						DebugLocation(222, 51);
						// JavaScript.g:222:51: ( LT !)*
						try { DebugEnterSubRule(98);
						while (true)
						{
							int alt98=2;
							try { DebugEnterDecision(98, false);
							int LA98_1 = input.LA(1);

							if ((LA98_1==LT))
							{
								alt98 = 1;
							}


							} finally { DebugExitDecision(98); }
							switch ( alt98 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:222:51: LT !
								{
								DebugLocation(222, 51);
								LT202=(IToken)Match(input,LT,Follow._LT_in_caseBlock1637); if (state.failed) return retval;

								}
								break;

							default:
								goto loop98;
							}
						}

						loop98:
							;

						} finally { DebugExitSubRule(98); }

						DebugLocation(222, 54);
						PushFollow(Follow._caseClause_in_caseBlock1641);
						caseClause203=caseClause();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, caseClause203.Tree);

						}
						break;

					default:
						goto loop99;
					}
				}

				loop99:
					;

				} finally { DebugExitSubRule(99); }


				}
				break;

			}
			} finally { DebugExitSubRule(100); }

			DebugLocation(222, 71);
			// JavaScript.g:222:71: ( LT !)*
			try { DebugEnterSubRule(101);
			while (true)
			{
				int alt101=2;
				try { DebugEnterDecision(101, false);
				int LA101_1 = input.LA(1);

				if ((LA101_1==LT))
				{
					alt101 = 1;
				}


				} finally { DebugExitDecision(101); }
				switch ( alt101 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:222:71: LT !
					{
					DebugLocation(222, 71);
					LT204=(IToken)Match(input,LT,Follow._LT_in_caseBlock1647); if (state.failed) return retval;

					}
					break;

				default:
					goto loop101;
				}
			}

			loop101:
				;

			} finally { DebugExitSubRule(101); }

			DebugLocation(222, 77);
			char_literal205=(IToken)Match(input,114,Follow._114_in_caseBlock1651); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseBlock", 34);
			LeaveRule("caseBlock", 34);
			LeaveRule_caseBlock();
			if (state.backtracking > 0) { Memoize(input, 34, caseBlock_StartIndex); }

		}
		DebugLocation(223, 1);
		} finally { DebugExitRule(GrammarFileName, "caseBlock"); }
		return retval;

	}
	// $ANTLR end "caseBlock"

	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();
	// $ANTLR start "caseClause"
	// JavaScript.g:225:1: caseClause : 'case' ( LT )* expression ( LT )* ':' ( LT )* ( statementList )? -> ^( 'case' expression ( statementList )? ) ;
	[GrammarRule("caseClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 35);
		TraceIn("caseClause", 35);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int caseClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal206 = default(IToken);
		IToken LT207 = default(IToken);
		IToken LT209 = default(IToken);
		IToken char_literal210 = default(IToken);
		IToken LT211 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression208 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statementList212 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal206_tree = default(CommonTree);
		CommonTree LT207_tree = default(CommonTree);
		CommonTree LT209_tree = default(CommonTree);
		CommonTree char_literal210_tree = default(CommonTree);
		CommonTree LT211_tree = default(CommonTree);
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statementList=new RewriteRuleSubtreeStream(adaptor,"rule statementList");
		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(225, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 35)) { return retval; }

			// JavaScript.g:226:2: ( 'case' ( LT )* expression ( LT )* ':' ( LT )* ( statementList )? -> ^( 'case' expression ( statementList )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:226:4: 'case' ( LT )* expression ( LT )* ':' ( LT )* ( statementList )?
			{
			DebugLocation(226, 4);
			string_literal206=(IToken)Match(input,83,Follow._83_in_caseClause1663); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_83.Add(string_literal206);

			DebugLocation(226, 11);
			// JavaScript.g:226:11: ( LT )*
			try { DebugEnterSubRule(102);
			while (true)
			{
				int alt102=2;
				try { DebugEnterDecision(102, false);
				int LA102_1 = input.LA(1);

				if ((LA102_1==LT))
				{
					alt102 = 1;
				}


				} finally { DebugExitDecision(102); }
				switch ( alt102 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:226:11: LT
					{
					DebugLocation(226, 11);
					LT207=(IToken)Match(input,LT,Follow._LT_in_caseClause1665); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT207);


					}
					break;

				default:
					goto loop102;
				}
			}

			loop102:
				;

			} finally { DebugExitSubRule(102); }

			DebugLocation(226, 15);
			PushFollow(Follow._expression_in_caseClause1668);
			expression208=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression208.Tree);
			DebugLocation(226, 26);
			// JavaScript.g:226:26: ( LT )*
			try { DebugEnterSubRule(103);
			while (true)
			{
				int alt103=2;
				try { DebugEnterDecision(103, false);
				int LA103_1 = input.LA(1);

				if ((LA103_1==LT))
				{
					alt103 = 1;
				}


				} finally { DebugExitDecision(103); }
				switch ( alt103 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:226:26: LT
					{
					DebugLocation(226, 26);
					LT209=(IToken)Match(input,LT,Follow._LT_in_caseClause1670); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT209);


					}
					break;

				default:
					goto loop103;
				}
			}

			loop103:
				;

			} finally { DebugExitSubRule(103); }

			DebugLocation(226, 30);
			char_literal210=(IToken)Match(input,62,Follow._62_in_caseClause1673); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal210);

			DebugLocation(226, 34);
			// JavaScript.g:226:34: ( LT )*
			try { DebugEnterSubRule(104);
			while (true)
			{
				int alt104=2;
				try { DebugEnterDecision(104, false);
				int LA104_1 = input.LA(1);

				if ((LA104_1==LT))
				{
					int LA104_2 = input.LA(2);

					if ((EvaluatePredicate(synpred118_JavaScript_fragment)))
					{
						alt104 = 1;
					}


				}


				} finally { DebugExitDecision(104); }
				switch ( alt104 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:226:34: LT
					{
					DebugLocation(226, 34);
					LT211=(IToken)Match(input,LT,Follow._LT_in_caseClause1675); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT211);


					}
					break;

				default:
					goto loop104;
				}
			}

			loop104:
				;

			} finally { DebugExitSubRule(104); }

			DebugLocation(226, 38);
			// JavaScript.g:226:38: ( statementList )?
			int alt105=2;
			try { DebugEnterSubRule(105);
			try { DebugEnterDecision(105, false);
			int LA105_1 = input.LA(1);

			if ((LA105_1==Identifier||LA105_1==NumericLiteral||LA105_1==StringLiteral||LA105_1==40||LA105_1==48||(LA105_1>=52 && LA105_1<=53)||(LA105_1>=56 && LA105_1<=57)||LA105_1==63||LA105_1==78||LA105_1==82||LA105_1==85||(LA105_1>=87 && LA105_1<=88)||LA105_1==90||(LA105_1>=92 && LA105_1<=94)||(LA105_1>=97 && LA105_1<=110)||LA105_1==115))
			{
				alt105 = 1;
			}
			} finally { DebugExitDecision(105); }
			switch (alt105)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:226:38: statementList
				{
				DebugLocation(226, 38);
				PushFollow(Follow._statementList_in_caseClause1678);
				statementList212=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statementList.Add(statementList212.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(105); }



			{
			// AST REWRITE
			// elements: 83, expression, statementList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 226:53: -> ^( 'case' expression ( statementList )? )
			{
				DebugLocation(226, 56);
				// JavaScript.g:226:56: ^( 'case' expression ( statementList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(226, 58);
				root_1 = (CommonTree)adaptor.BecomeRoot(new CaseClause(stream_83.NextToken()), root_1);

				DebugLocation(226, 82);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(226, 93);
				// JavaScript.g:226:93: ( statementList )?
				if (stream_statementList.HasNext)
				{
					DebugLocation(226, 93);
					adaptor.AddChild(root_1, stream_statementList.NextTree());

				}
				stream_statementList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseClause", 35);
			LeaveRule("caseClause", 35);
			LeaveRule_caseClause();
			if (state.backtracking > 0) { Memoize(input, 35, caseClause_StartIndex); }

		}
		DebugLocation(227, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return retval;

	}
	// $ANTLR end "caseClause"

	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();
	// $ANTLR start "defaultClause"
	// JavaScript.g:229:1: defaultClause : 'default' ( LT )* ':' ( LT )* ( statementList )? -> ^( 'default' ( statementList )? ) ;
	[GrammarRule("defaultClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 36);
		TraceIn("defaultClause", 36);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int defaultClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal213 = default(IToken);
		IToken LT214 = default(IToken);
		IToken char_literal215 = default(IToken);
		IToken LT216 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementList217 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal213_tree = default(CommonTree);
		CommonTree LT214_tree = default(CommonTree);
		CommonTree char_literal215_tree = default(CommonTree);
		CommonTree LT216_tree = default(CommonTree);
		RewriteRuleITokenStream stream_86=new RewriteRuleITokenStream(adaptor,"token 86");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_statementList=new RewriteRuleSubtreeStream(adaptor,"rule statementList");
		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(229, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 36)) { return retval; }

			// JavaScript.g:230:2: ( 'default' ( LT )* ':' ( LT )* ( statementList )? -> ^( 'default' ( statementList )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:230:4: 'default' ( LT )* ':' ( LT )* ( statementList )?
			{
			DebugLocation(230, 4);
			string_literal213=(IToken)Match(input,86,Follow._86_in_defaultClause1707); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_86.Add(string_literal213);

			DebugLocation(230, 14);
			// JavaScript.g:230:14: ( LT )*
			try { DebugEnterSubRule(106);
			while (true)
			{
				int alt106=2;
				try { DebugEnterDecision(106, false);
				int LA106_1 = input.LA(1);

				if ((LA106_1==LT))
				{
					alt106 = 1;
				}


				} finally { DebugExitDecision(106); }
				switch ( alt106 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:230:14: LT
					{
					DebugLocation(230, 14);
					LT214=(IToken)Match(input,LT,Follow._LT_in_defaultClause1709); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT214);


					}
					break;

				default:
					goto loop106;
				}
			}

			loop106:
				;

			} finally { DebugExitSubRule(106); }

			DebugLocation(230, 18);
			char_literal215=(IToken)Match(input,62,Follow._62_in_defaultClause1712); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal215);

			DebugLocation(230, 22);
			// JavaScript.g:230:22: ( LT )*
			try { DebugEnterSubRule(107);
			while (true)
			{
				int alt107=2;
				try { DebugEnterDecision(107, false);
				int LA107_1 = input.LA(1);

				if ((LA107_1==LT))
				{
					int LA107_2 = input.LA(2);

					if ((EvaluatePredicate(synpred121_JavaScript_fragment)))
					{
						alt107 = 1;
					}


				}


				} finally { DebugExitDecision(107); }
				switch ( alt107 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:230:22: LT
					{
					DebugLocation(230, 22);
					LT216=(IToken)Match(input,LT,Follow._LT_in_defaultClause1714); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT216);


					}
					break;

				default:
					goto loop107;
				}
			}

			loop107:
				;

			} finally { DebugExitSubRule(107); }

			DebugLocation(230, 26);
			// JavaScript.g:230:26: ( statementList )?
			int alt108=2;
			try { DebugEnterSubRule(108);
			try { DebugEnterDecision(108, false);
			int LA108_1 = input.LA(1);

			if ((LA108_1==Identifier||LA108_1==NumericLiteral||LA108_1==StringLiteral||LA108_1==40||LA108_1==48||(LA108_1>=52 && LA108_1<=53)||(LA108_1>=56 && LA108_1<=57)||LA108_1==63||LA108_1==78||LA108_1==82||LA108_1==85||(LA108_1>=87 && LA108_1<=88)||LA108_1==90||(LA108_1>=92 && LA108_1<=94)||(LA108_1>=97 && LA108_1<=110)||LA108_1==115))
			{
				alt108 = 1;
			}
			} finally { DebugExitDecision(108); }
			switch (alt108)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:230:26: statementList
				{
				DebugLocation(230, 26);
				PushFollow(Follow._statementList_in_defaultClause1717);
				statementList217=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statementList.Add(statementList217.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(108); }



			{
			// AST REWRITE
			// elements: 86, statementList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 230:41: -> ^( 'default' ( statementList )? )
			{
				DebugLocation(230, 44);
				// JavaScript.g:230:44: ^( 'default' ( statementList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(230, 46);
				root_1 = (CommonTree)adaptor.BecomeRoot(new DefaultCaseClause(stream_86.NextToken()), root_1);

				DebugLocation(230, 80);
				// JavaScript.g:230:80: ( statementList )?
				if (stream_statementList.HasNext)
				{
					DebugLocation(230, 80);
					adaptor.AddChild(root_1, stream_statementList.NextTree());

				}
				stream_statementList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultClause", 36);
			LeaveRule("defaultClause", 36);
			LeaveRule_defaultClause();
			if (state.backtracking > 0) { Memoize(input, 36, defaultClause_StartIndex); }

		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return retval;

	}
	// $ANTLR end "defaultClause"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// JavaScript.g:233:1: throwStatement : 'throw' expression ( LT | ';' ) -> ^( 'throw' expression ) ;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 37);
		TraceIn("throwStatement", 37);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int throwStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal218 = default(IToken);
		IToken LT220 = default(IToken);
		IToken char_literal221 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression219 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal218_tree = default(CommonTree);
		CommonTree LT220_tree = default(CommonTree);
		CommonTree char_literal221_tree = default(CommonTree);
		RewriteRuleITokenStream stream_102=new RewriteRuleITokenStream(adaptor,"token 102");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(233, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 37)) { return retval; }

			// JavaScript.g:234:2: ( 'throw' expression ( LT | ';' ) -> ^( 'throw' expression ) )
			DebugEnterAlt(1);
			// JavaScript.g:234:4: 'throw' expression ( LT | ';' )
			{
			DebugLocation(234, 4);
			string_literal218=(IToken)Match(input,102,Follow._102_in_throwStatement1744); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_102.Add(string_literal218);

			DebugLocation(234, 12);
			PushFollow(Follow._expression_in_throwStatement1746);
			expression219=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression219.Tree);
			DebugLocation(234, 23);
			// JavaScript.g:234:23: ( LT | ';' )
			int alt109=2;
			try { DebugEnterSubRule(109);
			try { DebugEnterDecision(109, false);
			int LA109_1 = input.LA(1);

			if ((LA109_1==LT))
			{
				alt109 = 1;
			}
			else if ((LA109_1==63))
			{
				alt109 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 109, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(109); }
			switch (alt109)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:234:24: LT
				{
				DebugLocation(234, 24);
				LT220=(IToken)Match(input,LT,Follow._LT_in_throwStatement1749); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT220);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:234:29: ';'
				{
				DebugLocation(234, 29);
				char_literal221=(IToken)Match(input,63,Follow._63_in_throwStatement1753); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal221);


				}
				break;

			}
			} finally { DebugExitSubRule(109); }



			{
			// AST REWRITE
			// elements: 102, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 234:34: -> ^( 'throw' expression )
			{
				DebugLocation(234, 37);
				// JavaScript.g:234:37: ^( 'throw' expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(234, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ThrowStatement(stream_102.NextToken()), root_1);

				DebugLocation(234, 68);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwStatement", 37);
			LeaveRule("throwStatement", 37);
			LeaveRule_throwStatement();
			if (state.backtracking > 0) { Memoize(input, 37, throwStatement_StartIndex); }

		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// JavaScript.g:237:1: tryStatement : 'try' ( LT )* statementBlock ( LT )* ( finallyClause | catchClause ( ( LT )* finallyClause )? ) -> ^( 'try' statementBlock ( catchClause )? ( finallyClause )? ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 38);
		TraceIn("tryStatement", 38);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int tryStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal222 = default(IToken);
		IToken LT223 = default(IToken);
		IToken LT225 = default(IToken);
		IToken LT228 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementBlock224 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> finallyClause226 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> catchClause227 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> finallyClause229 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal222_tree = default(CommonTree);
		CommonTree LT223_tree = default(CommonTree);
		CommonTree LT225_tree = default(CommonTree);
		CommonTree LT228_tree = default(CommonTree);
		RewriteRuleITokenStream stream_104=new RewriteRuleITokenStream(adaptor,"token 104");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_statementBlock=new RewriteRuleSubtreeStream(adaptor,"rule statementBlock");
		RewriteRuleSubtreeStream stream_finallyClause=new RewriteRuleSubtreeStream(adaptor,"rule finallyClause");
		RewriteRuleSubtreeStream stream_catchClause=new RewriteRuleSubtreeStream(adaptor,"rule catchClause");
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(237, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 38)) { return retval; }

			// JavaScript.g:238:2: ( 'try' ( LT )* statementBlock ( LT )* ( finallyClause | catchClause ( ( LT )* finallyClause )? ) -> ^( 'try' statementBlock ( catchClause )? ( finallyClause )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:238:4: 'try' ( LT )* statementBlock ( LT )* ( finallyClause | catchClause ( ( LT )* finallyClause )? )
			{
			DebugLocation(238, 4);
			string_literal222=(IToken)Match(input,104,Follow._104_in_tryStatement1778); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_104.Add(string_literal222);

			DebugLocation(238, 10);
			// JavaScript.g:238:10: ( LT )*
			try { DebugEnterSubRule(110);
			while (true)
			{
				int alt110=2;
				try { DebugEnterDecision(110, false);
				int LA110_1 = input.LA(1);

				if ((LA110_1==LT))
				{
					alt110 = 1;
				}


				} finally { DebugExitDecision(110); }
				switch ( alt110 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:238:10: LT
					{
					DebugLocation(238, 10);
					LT223=(IToken)Match(input,LT,Follow._LT_in_tryStatement1780); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT223);


					}
					break;

				default:
					goto loop110;
				}
			}

			loop110:
				;

			} finally { DebugExitSubRule(110); }

			DebugLocation(238, 14);
			PushFollow(Follow._statementBlock_in_tryStatement1783);
			statementBlock224=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statementBlock.Add(statementBlock224.Tree);
			DebugLocation(238, 29);
			// JavaScript.g:238:29: ( LT )*
			try { DebugEnterSubRule(111);
			while (true)
			{
				int alt111=2;
				try { DebugEnterDecision(111, false);
				int LA111_1 = input.LA(1);

				if ((LA111_1==LT))
				{
					alt111 = 1;
				}


				} finally { DebugExitDecision(111); }
				switch ( alt111 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:238:29: LT
					{
					DebugLocation(238, 29);
					LT225=(IToken)Match(input,LT,Follow._LT_in_tryStatement1785); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT225);


					}
					break;

				default:
					goto loop111;
				}
			}

			loop111:
				;

			} finally { DebugExitSubRule(111); }

			DebugLocation(238, 33);
			// JavaScript.g:238:33: ( finallyClause | catchClause ( ( LT )* finallyClause )? )
			int alt114=2;
			try { DebugEnterSubRule(114);
			try { DebugEnterDecision(114, false);
			int LA114_1 = input.LA(1);

			if ((LA114_1==91))
			{
				alt114 = 1;
			}
			else if ((LA114_1==84))
			{
				alt114 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 114, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(114); }
			switch (alt114)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:238:34: finallyClause
				{
				DebugLocation(238, 34);
				PushFollow(Follow._finallyClause_in_tryStatement1789);
				finallyClause226=finallyClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_finallyClause.Add(finallyClause226.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:238:50: catchClause ( ( LT )* finallyClause )?
				{
				DebugLocation(238, 50);
				PushFollow(Follow._catchClause_in_tryStatement1793);
				catchClause227=catchClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_catchClause.Add(catchClause227.Tree);
				DebugLocation(238, 62);
				// JavaScript.g:238:62: ( ( LT )* finallyClause )?
				int alt113=2;
				try { DebugEnterSubRule(113);
				try { DebugEnterDecision(113, false);
				try
				{
					alt113 = dfa113.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(113); }
				switch (alt113)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:238:63: ( LT )* finallyClause
					{
					DebugLocation(238, 63);
					// JavaScript.g:238:63: ( LT )*
					try { DebugEnterSubRule(112);
					while (true)
					{
						int alt112=2;
						try { DebugEnterDecision(112, false);
						int LA112_1 = input.LA(1);

						if ((LA112_1==LT))
						{
							alt112 = 1;
						}


						} finally { DebugExitDecision(112); }
						switch ( alt112 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:238:63: LT
							{
							DebugLocation(238, 63);
							LT228=(IToken)Match(input,LT,Follow._LT_in_tryStatement1796); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT228);


							}
							break;

						default:
							goto loop112;
						}
					}

					loop112:
						;

					} finally { DebugExitSubRule(112); }

					DebugLocation(238, 67);
					PushFollow(Follow._finallyClause_in_tryStatement1799);
					finallyClause229=finallyClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_finallyClause.Add(finallyClause229.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(113); }


				}
				break;

			}
			} finally { DebugExitSubRule(114); }



			{
			// AST REWRITE
			// elements: 104, statementBlock, catchClause, finallyClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 239:3: -> ^( 'try' statementBlock ( catchClause )? ( finallyClause )? )
			{
				DebugLocation(239, 6);
				// JavaScript.g:239:6: ^( 'try' statementBlock ( catchClause )? ( finallyClause )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(239, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new TryStatement(stream_104.NextToken()), root_1);

				DebugLocation(239, 33);
				adaptor.AddChild(root_1, stream_statementBlock.NextTree());
				DebugLocation(239, 48);
				// JavaScript.g:239:48: ( catchClause )?
				if (stream_catchClause.HasNext)
				{
					DebugLocation(239, 48);
					adaptor.AddChild(root_1, stream_catchClause.NextTree());

				}
				stream_catchClause.Reset();
				DebugLocation(239, 61);
				// JavaScript.g:239:61: ( finallyClause )?
				if (stream_finallyClause.HasNext)
				{
					DebugLocation(239, 61);
					adaptor.AddChild(root_1, stream_finallyClause.NextTree());

				}
				stream_finallyClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryStatement", 38);
			LeaveRule("tryStatement", 38);
			LeaveRule_tryStatement();
			if (state.backtracking > 0) { Memoize(input, 38, tryStatement_StartIndex); }

		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();
	// $ANTLR start "catchClause"
	// JavaScript.g:242:1: catchClause : 'catch' ( LT )* '(' ( LT )* Identifier ( LT )* ')' ( LT )* statementBlock -> ^( 'catch' Identifier statementBlock ) ;
	[GrammarRule("catchClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 39);
		TraceIn("catchClause", 39);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int catchClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal230 = default(IToken);
		IToken LT231 = default(IToken);
		IToken char_literal232 = default(IToken);
		IToken LT233 = default(IToken);
		IToken Identifier234 = default(IToken);
		IToken LT235 = default(IToken);
		IToken char_literal236 = default(IToken);
		IToken LT237 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementBlock238 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal230_tree = default(CommonTree);
		CommonTree LT231_tree = default(CommonTree);
		CommonTree char_literal232_tree = default(CommonTree);
		CommonTree LT233_tree = default(CommonTree);
		CommonTree Identifier234_tree = default(CommonTree);
		CommonTree LT235_tree = default(CommonTree);
		CommonTree char_literal236_tree = default(CommonTree);
		CommonTree LT237_tree = default(CommonTree);
		RewriteRuleITokenStream stream_84=new RewriteRuleITokenStream(adaptor,"token 84");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_statementBlock=new RewriteRuleSubtreeStream(adaptor,"rule statementBlock");
		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(242, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 39)) { return retval; }

			// JavaScript.g:243:2: ( 'catch' ( LT )* '(' ( LT )* Identifier ( LT )* ')' ( LT )* statementBlock -> ^( 'catch' Identifier statementBlock ) )
			DebugEnterAlt(1);
			// JavaScript.g:243:4: 'catch' ( LT )* '(' ( LT )* Identifier ( LT )* ')' ( LT )* statementBlock
			{
			DebugLocation(243, 4);
			string_literal230=(IToken)Match(input,84,Follow._84_in_catchClause1841); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_84.Add(string_literal230);

			DebugLocation(243, 12);
			// JavaScript.g:243:12: ( LT )*
			try { DebugEnterSubRule(115);
			while (true)
			{
				int alt115=2;
				try { DebugEnterDecision(115, false);
				int LA115_1 = input.LA(1);

				if ((LA115_1==LT))
				{
					alt115 = 1;
				}


				} finally { DebugExitDecision(115); }
				switch ( alt115 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:12: LT
					{
					DebugLocation(243, 12);
					LT231=(IToken)Match(input,LT,Follow._LT_in_catchClause1843); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT231);


					}
					break;

				default:
					goto loop115;
				}
			}

			loop115:
				;

			} finally { DebugExitSubRule(115); }

			DebugLocation(243, 16);
			char_literal232=(IToken)Match(input,48,Follow._48_in_catchClause1846); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal232);

			DebugLocation(243, 20);
			// JavaScript.g:243:20: ( LT )*
			try { DebugEnterSubRule(116);
			while (true)
			{
				int alt116=2;
				try { DebugEnterDecision(116, false);
				int LA116_1 = input.LA(1);

				if ((LA116_1==LT))
				{
					alt116 = 1;
				}


				} finally { DebugExitDecision(116); }
				switch ( alt116 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:20: LT
					{
					DebugLocation(243, 20);
					LT233=(IToken)Match(input,LT,Follow._LT_in_catchClause1848); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT233);


					}
					break;

				default:
					goto loop116;
				}
			}

			loop116:
				;

			} finally { DebugExitSubRule(116); }

			DebugLocation(243, 24);
			Identifier234=(IToken)Match(input,Identifier,Follow._Identifier_in_catchClause1851); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier234);

			DebugLocation(243, 35);
			// JavaScript.g:243:35: ( LT )*
			try { DebugEnterSubRule(117);
			while (true)
			{
				int alt117=2;
				try { DebugEnterDecision(117, false);
				int LA117_1 = input.LA(1);

				if ((LA117_1==LT))
				{
					alt117 = 1;
				}


				} finally { DebugExitDecision(117); }
				switch ( alt117 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:35: LT
					{
					DebugLocation(243, 35);
					LT235=(IToken)Match(input,LT,Follow._LT_in_catchClause1853); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT235);


					}
					break;

				default:
					goto loop117;
				}
			}

			loop117:
				;

			} finally { DebugExitSubRule(117); }

			DebugLocation(243, 39);
			char_literal236=(IToken)Match(input,49,Follow._49_in_catchClause1856); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal236);

			DebugLocation(243, 43);
			// JavaScript.g:243:43: ( LT )*
			try { DebugEnterSubRule(118);
			while (true)
			{
				int alt118=2;
				try { DebugEnterDecision(118, false);
				int LA118_1 = input.LA(1);

				if ((LA118_1==LT))
				{
					alt118 = 1;
				}


				} finally { DebugExitDecision(118); }
				switch ( alt118 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:43: LT
					{
					DebugLocation(243, 43);
					LT237=(IToken)Match(input,LT,Follow._LT_in_catchClause1858); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT237);


					}
					break;

				default:
					goto loop118;
				}
			}

			loop118:
				;

			} finally { DebugExitSubRule(118); }

			DebugLocation(243, 47);
			PushFollow(Follow._statementBlock_in_catchClause1861);
			statementBlock238=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statementBlock.Add(statementBlock238.Tree);


			{
			// AST REWRITE
			// elements: 84, Identifier, statementBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 244:3: -> ^( 'catch' Identifier statementBlock )
			{
				DebugLocation(244, 6);
				// JavaScript.g:244:6: ^( 'catch' Identifier statementBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(244, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new CatchClause(stream_84.NextToken()), root_1);

				DebugLocation(244, 34);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(244, 62);
				adaptor.AddChild(root_1, stream_statementBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchClause", 39);
			LeaveRule("catchClause", 39);
			LeaveRule_catchClause();
			if (state.backtracking > 0) { Memoize(input, 39, catchClause_StartIndex); }

		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return retval;

	}
	// $ANTLR end "catchClause"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// JavaScript.g:247:1: finallyClause : 'finally' ( LT )* statementBlock -> ^( 'finally' statementBlock ) ;
	[GrammarRule("finallyClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 40);
		TraceIn("finallyClause", 40);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int finallyClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal239 = default(IToken);
		IToken LT240 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementBlock241 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal239_tree = default(CommonTree);
		CommonTree LT240_tree = default(CommonTree);
		RewriteRuleITokenStream stream_91=new RewriteRuleITokenStream(adaptor,"token 91");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_statementBlock=new RewriteRuleSubtreeStream(adaptor,"rule statementBlock");
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(247, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 40)) { return retval; }

			// JavaScript.g:248:2: ( 'finally' ( LT )* statementBlock -> ^( 'finally' statementBlock ) )
			DebugEnterAlt(1);
			// JavaScript.g:248:4: 'finally' ( LT )* statementBlock
			{
			DebugLocation(248, 4);
			string_literal239=(IToken)Match(input,91,Follow._91_in_finallyClause1895); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_91.Add(string_literal239);

			DebugLocation(248, 14);
			// JavaScript.g:248:14: ( LT )*
			try { DebugEnterSubRule(119);
			while (true)
			{
				int alt119=2;
				try { DebugEnterDecision(119, false);
				int LA119_1 = input.LA(1);

				if ((LA119_1==LT))
				{
					alt119 = 1;
				}


				} finally { DebugExitDecision(119); }
				switch ( alt119 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:248:14: LT
					{
					DebugLocation(248, 14);
					LT240=(IToken)Match(input,LT,Follow._LT_in_finallyClause1897); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT240);


					}
					break;

				default:
					goto loop119;
				}
			}

			loop119:
				;

			} finally { DebugExitSubRule(119); }

			DebugLocation(248, 18);
			PushFollow(Follow._statementBlock_in_finallyClause1900);
			statementBlock241=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statementBlock.Add(statementBlock241.Tree);


			{
			// AST REWRITE
			// elements: 91, statementBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 248:33: -> ^( 'finally' statementBlock )
			{
				DebugLocation(248, 36);
				// JavaScript.g:248:36: ^( 'finally' statementBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(248, 38);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FinallyClause(stream_91.NextToken()), root_1);

				DebugLocation(248, 68);
				adaptor.AddChild(root_1, stream_statementBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyClause", 40);
			LeaveRule("finallyClause", 40);
			LeaveRule_finallyClause();
			if (state.backtracking > 0) { Memoize(input, 40, finallyClause_StartIndex); }

		}
		DebugLocation(249, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return retval;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// JavaScript.g:252:1: expression : assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* -> ( assignmentExpression )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 41);
		TraceIn("expression", 41);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT243 = default(IToken);
		IToken char_literal244 = default(IToken);
		IToken LT245 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression242 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression246 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT243_tree = default(CommonTree);
		CommonTree char_literal244_tree = default(CommonTree);
		CommonTree LT245_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(252, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 41)) { return retval; }

			// JavaScript.g:253:2: ( assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* -> ( assignmentExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:253:4: assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )*
			{
			DebugLocation(253, 4);
			PushFollow(Follow._assignmentExpression_in_expression1925);
			assignmentExpression242=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression242.Tree);
			DebugLocation(253, 25);
			// JavaScript.g:253:25: ( ( LT )* ',' ( LT )* assignmentExpression )*
			try { DebugEnterSubRule(122);
			while (true)
			{
				int alt122=2;
				try { DebugEnterDecision(122, false);
				try
				{
					alt122 = dfa122.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(122); }
				switch ( alt122 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:253:26: ( LT )* ',' ( LT )* assignmentExpression
					{
					DebugLocation(253, 26);
					// JavaScript.g:253:26: ( LT )*
					try { DebugEnterSubRule(120);
					while (true)
					{
						int alt120=2;
						try { DebugEnterDecision(120, false);
						int LA120_1 = input.LA(1);

						if ((LA120_1==LT))
						{
							alt120 = 1;
						}


						} finally { DebugExitDecision(120); }
						switch ( alt120 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:253:26: LT
							{
							DebugLocation(253, 26);
							LT243=(IToken)Match(input,LT,Follow._LT_in_expression1928); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT243);


							}
							break;

						default:
							goto loop120;
						}
					}

					loop120:
						;

					} finally { DebugExitSubRule(120); }

					DebugLocation(253, 30);
					char_literal244=(IToken)Match(input,55,Follow._55_in_expression1931); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal244);

					DebugLocation(253, 34);
					// JavaScript.g:253:34: ( LT )*
					try { DebugEnterSubRule(121);
					while (true)
					{
						int alt121=2;
						try { DebugEnterDecision(121, false);
						int LA121_1 = input.LA(1);

						if ((LA121_1==LT))
						{
							alt121 = 1;
						}


						} finally { DebugExitDecision(121); }
						switch ( alt121 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:253:34: LT
							{
							DebugLocation(253, 34);
							LT245=(IToken)Match(input,LT,Follow._LT_in_expression1933); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT245);


							}
							break;

						default:
							goto loop121;
						}
					}

					loop121:
						;

					} finally { DebugExitSubRule(121); }

					DebugLocation(253, 38);
					PushFollow(Follow._assignmentExpression_in_expression1936);
					assignmentExpression246=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression246.Tree);

					}
					break;

				default:
					goto loop122;
				}
			}

			loop122:
				;

			} finally { DebugExitSubRule(122); }



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 253:61: -> ( assignmentExpression )*
			{
				DebugLocation(253, 64);
				// JavaScript.g:253:64: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(253, 64);
					adaptor.AddChild(root_0, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 41);
			LeaveRule("expression", 41);
			LeaveRule_expression();
			if (state.backtracking > 0) { Memoize(input, 41, expression_StartIndex); }

		}
		DebugLocation(254, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionNoIn();
	partial void LeaveRule_expressionNoIn();
	// $ANTLR start "expressionNoIn"
	// JavaScript.g:256:1: expressionNoIn : assignmentExpressionNoIn ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )* -> ( assignmentExpressionNoIn )* ;
	[GrammarRule("expressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> expressionNoIn()
	{
		EnterRule_expressionNoIn();
		EnterRule("expressionNoIn", 42);
		TraceIn("expressionNoIn", 42);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT248 = default(IToken);
		IToken char_literal249 = default(IToken);
		IToken LT250 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn247 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn251 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT248_tree = default(CommonTree);
		CommonTree char_literal249_tree = default(CommonTree);
		CommonTree LT250_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "expressionNoIn");
		DebugLocation(256, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 42)) { return retval; }

			// JavaScript.g:257:2: ( assignmentExpressionNoIn ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )* -> ( assignmentExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:257:4: assignmentExpressionNoIn ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )*
			{
			DebugLocation(257, 4);
			PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn1955);
			assignmentExpressionNoIn247=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(assignmentExpressionNoIn247.Tree);
			DebugLocation(257, 29);
			// JavaScript.g:257:29: ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )*
			try { DebugEnterSubRule(125);
			while (true)
			{
				int alt125=2;
				try { DebugEnterDecision(125, false);
				try
				{
					alt125 = dfa125.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(125); }
				switch ( alt125 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:257:30: ( LT )* ',' ( LT )* assignmentExpressionNoIn
					{
					DebugLocation(257, 30);
					// JavaScript.g:257:30: ( LT )*
					try { DebugEnterSubRule(123);
					while (true)
					{
						int alt123=2;
						try { DebugEnterDecision(123, false);
						int LA123_1 = input.LA(1);

						if ((LA123_1==LT))
						{
							alt123 = 1;
						}


						} finally { DebugExitDecision(123); }
						switch ( alt123 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:257:30: LT
							{
							DebugLocation(257, 30);
							LT248=(IToken)Match(input,LT,Follow._LT_in_expressionNoIn1958); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT248);


							}
							break;

						default:
							goto loop123;
						}
					}

					loop123:
						;

					} finally { DebugExitSubRule(123); }

					DebugLocation(257, 34);
					char_literal249=(IToken)Match(input,55,Follow._55_in_expressionNoIn1961); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal249);

					DebugLocation(257, 38);
					// JavaScript.g:257:38: ( LT )*
					try { DebugEnterSubRule(124);
					while (true)
					{
						int alt124=2;
						try { DebugEnterDecision(124, false);
						int LA124_1 = input.LA(1);

						if ((LA124_1==LT))
						{
							alt124 = 1;
						}


						} finally { DebugExitDecision(124); }
						switch ( alt124 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:257:38: LT
							{
							DebugLocation(257, 38);
							LT250=(IToken)Match(input,LT,Follow._LT_in_expressionNoIn1963); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT250);


							}
							break;

						default:
							goto loop124;
						}
					}

					loop124:
						;

					} finally { DebugExitSubRule(124); }

					DebugLocation(257, 42);
					PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn1966);
					assignmentExpressionNoIn251=assignmentExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(assignmentExpressionNoIn251.Tree);

					}
					break;

				default:
					goto loop125;
				}
			}

			loop125:
				;

			} finally { DebugExitSubRule(125); }



			{
			// AST REWRITE
			// elements: assignmentExpressionNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 257:69: -> ( assignmentExpressionNoIn )*
			{
				DebugLocation(257, 72);
				// JavaScript.g:257:72: ( assignmentExpressionNoIn )*
				while ( stream_assignmentExpressionNoIn.HasNext )
				{
					DebugLocation(257, 72);
					adaptor.AddChild(root_0, stream_assignmentExpressionNoIn.NextTree());

				}
				stream_assignmentExpressionNoIn.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionNoIn", 42);
			LeaveRule("expressionNoIn", 42);
			LeaveRule_expressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 42, expressionNoIn_StartIndex); }

		}
		DebugLocation(258, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
		return retval;

	}
	// $ANTLR end "expressionNoIn"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();
	// $ANTLR start "assignmentExpression"
	// JavaScript.g:260:1: assignmentExpression : ( conditionalExpression -> conditionalExpression |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpression -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->);
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 43);
		TraceIn("assignmentExpression", 43);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT253 = default(IToken);
		IToken LT254 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> op = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> rh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionalExpression252 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT253_tree = default(CommonTree);
		CommonTree LT254_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_conditionalExpression=new RewriteRuleSubtreeStream(adaptor,"rule conditionalExpression");
		RewriteRuleSubtreeStream stream_leftHandSideExpression=new RewriteRuleSubtreeStream(adaptor,"rule leftHandSideExpression");
		RewriteRuleSubtreeStream stream_assignmentOperator=new RewriteRuleSubtreeStream(adaptor,"rule assignmentOperator");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(260, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 43)) { return retval; }

			// JavaScript.g:261:2: ( conditionalExpression -> conditionalExpression |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpression -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->)
			int alt128=2;
			try { DebugEnterDecision(128, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 98:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 103:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 90:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case StringLiteral:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 78:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 110:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 48:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 93:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				int LA128_2 = input.LA(2);

				if ((EvaluatePredicate(synpred140_JavaScript_fragment)))
				{
					alt128 = 1;
				}
				else if ((true))
				{
					alt128 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 40:
			case 52:
			case 53:
			case 56:
			case 57:
			case 87:
			case 105:
			case 107:
			case 115:
				{
				alt128 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 128, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(128); }
			switch (alt128)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:261:4: conditionalExpression
				{
				DebugLocation(261, 4);
				PushFollow(Follow._conditionalExpression_in_assignmentExpression1985);
				conditionalExpression252=conditionalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionalExpression.Add(conditionalExpression252.Tree);


				{
				// AST REWRITE
				// elements: conditionalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 261:26: -> conditionalExpression
				{
					DebugLocation(261, 29);
					adaptor.AddChild(root_0, stream_conditionalExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:262:4: lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpression
				{
				DebugLocation(262, 6);
				PushFollow(Follow._leftHandSideExpression_in_assignmentExpression1996);
				lh=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_leftHandSideExpression.Add(lh.Tree);
				DebugLocation(262, 30);
				// JavaScript.g:262:30: ( LT )*
				try { DebugEnterSubRule(126);
				while (true)
				{
					int alt126=2;
					try { DebugEnterDecision(126, false);
					int LA126_1 = input.LA(1);

					if ((LA126_1==LT))
					{
						alt126 = 1;
					}


					} finally { DebugExitDecision(126); }
					switch ( alt126 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:262:30: LT
						{
						DebugLocation(262, 30);
						LT253=(IToken)Match(input,LT,Follow._LT_in_assignmentExpression1998); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT253);


						}
						break;

					default:
						goto loop126;
					}
				}

				loop126:
					;

				} finally { DebugExitSubRule(126); }

				DebugLocation(262, 36);
				PushFollow(Follow._assignmentOperator_in_assignmentExpression2003);
				op=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentOperator.Add(op.Tree);
				DebugLocation(262, 56);
				// JavaScript.g:262:56: ( LT )*
				try { DebugEnterSubRule(127);
				while (true)
				{
					int alt127=2;
					try { DebugEnterDecision(127, false);
					int LA127_1 = input.LA(1);

					if ((LA127_1==LT))
					{
						alt127 = 1;
					}


					} finally { DebugExitDecision(127); }
					switch ( alt127 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:262:56: LT
						{
						DebugLocation(262, 56);
						LT254=(IToken)Match(input,LT,Follow._LT_in_assignmentExpression2005); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT254);


						}
						break;

					default:
						goto loop127;
					}
				}

				loop127:
					;

				} finally { DebugExitSubRule(127); }

				DebugLocation(262, 62);
				PushFollow(Follow._assignmentExpression_in_assignmentExpression2010);
				rh=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(rh.Tree);


				{
				// AST REWRITE
				// elements: 68, lh, rh, 51, lh, rh, 61, lh, rh, 44, lh, rh, 54, lh, rh, 58, lh, rh, 66, lh, rh, 74, lh, rh, 76, lh, rh, 47, lh, rh, 81, lh, rh, 112, lh, rh
				// token labels: 
				// rule labels: lh, rh, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_lh=new RewriteRuleSubtreeStream(adaptor,"rule lh",lh!=null?lh.Tree:null);
				RewriteRuleSubtreeStream stream_rh=new RewriteRuleSubtreeStream(adaptor,"rule rh",rh!=null?rh.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 263:9: -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh)
				if (op.Tree.Text == "="    )
				{
					DebugLocation(263, 39);
					// JavaScript.g:263:39: ^( '=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(263, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AssignExpression(68), root_1);

					DebugLocation(263, 69);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(263, 73);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 264:9: -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh)
				if (op.Tree.Text == "*="   )
				{
					DebugLocation(264, 39);
					// JavaScript.g:264:39: ^( '*=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(264, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new MultiplyAndAssignExpression(51), root_1);

					DebugLocation(264, 81);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(264, 85);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 265:3: -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh)
				if (op.Tree.Text == "/="   )
				{
					DebugLocation(265, 33);
					// JavaScript.g:265:33: ^( '/=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(265, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DivideAndAssignExpression(61), root_1);

					DebugLocation(265, 73);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(265, 77);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 266:3: -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh)
				if (op.Tree.Text == "%="  )
				{
					DebugLocation(266, 33);
					// JavaScript.g:266:33: ^( '%=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(266, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ModulusAndAssignExpression(44), root_1);

					DebugLocation(266, 74);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(266, 78);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 267:3: -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh)
				if (op.Tree.Text == "+="   )
				{
					DebugLocation(267, 33);
					// JavaScript.g:267:33: ^( '+=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(267, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AddAndAssignExpression(54), root_1);

					DebugLocation(267, 70);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(267, 74);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 268:3: -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh)
				if (op.Tree.Text == "-="   )
				{
					DebugLocation(268, 33);
					// JavaScript.g:268:33: ^( '-=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(268, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new SubtractAndAssignExpression(58), root_1);

					DebugLocation(268, 75);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(268, 79);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 269:3: -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh)
				if (op.Tree.Text == "<<="  )
				{
					DebugLocation(269, 33);
					// JavaScript.g:269:33: ^( '<<=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(269, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftLeftAndAssignExpression(66), root_1);

					DebugLocation(269, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(269, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 270:3: -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh)
				if (op.Tree.Text == ">>="  )
				{
					DebugLocation(270, 33);
					// JavaScript.g:270:33: ^( '>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(270, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftRightAndAssignExpression(74), root_1);

					DebugLocation(270, 78);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(270, 82);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 271:3: -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh)
				if (op.Tree.Text == ">>>=" )
				{
					DebugLocation(271, 33);
					// JavaScript.g:271:33: ^( '>>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(271, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new RotateRightAndAssignExpression(76), root_1);

					DebugLocation(271, 80);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(271, 84);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 272:3: -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh)
				if (op.Tree.Text == "&="   )
				{
					DebugLocation(272, 33);
					// JavaScript.g:272:33: ^( '&=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(272, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndAndAssignExpression(47), root_1);

					DebugLocation(272, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(272, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 273:3: -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh)
				if (op.Tree.Text == "^="   )
				{
					DebugLocation(273, 33);
					// JavaScript.g:273:33: ^( '^=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(273, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorAndAssignExpression(81), root_1);

					DebugLocation(273, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(273, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 274:3: -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh)
				if (op.Tree.Text == "|="   )
				{
					DebugLocation(274, 33);
					// JavaScript.g:274:33: ^( '|=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(274, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrAndAssignExpression(112), root_1);

					DebugLocation(274, 76);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(274, 80);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 275:9: ->
				{
					DebugLocation(276, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 43);
			LeaveRule("assignmentExpression", 43);
			LeaveRule_assignmentExpression();
			if (state.backtracking > 0) { Memoize(input, 43, assignmentExpression_StartIndex); }

		}
		DebugLocation(276, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentExpressionNoIn();
	partial void LeaveRule_assignmentExpressionNoIn();
	// $ANTLR start "assignmentExpressionNoIn"
	// JavaScript.g:278:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn -> conditionalExpressionNoIn |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpressionNoIn -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->);
	[GrammarRule("assignmentExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn()
	{
		EnterRule_assignmentExpressionNoIn();
		EnterRule("assignmentExpressionNoIn", 44);
		TraceIn("assignmentExpressionNoIn", 44);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT256 = default(IToken);
		IToken LT257 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> op = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> rh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionalExpressionNoIn255 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT256_tree = default(CommonTree);
		CommonTree LT257_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_conditionalExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule conditionalExpressionNoIn");
		RewriteRuleSubtreeStream stream_leftHandSideExpression=new RewriteRuleSubtreeStream(adaptor,"rule leftHandSideExpression");
		RewriteRuleSubtreeStream stream_assignmentOperator=new RewriteRuleSubtreeStream(adaptor,"rule assignmentOperator");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
		DebugLocation(278, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 44)) { return retval; }

			// JavaScript.g:279:2: ( conditionalExpressionNoIn -> conditionalExpressionNoIn |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpressionNoIn -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->)
			int alt131=2;
			try { DebugEnterDecision(131, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 98:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 103:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 90:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case StringLiteral:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 78:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 110:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 48:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 93:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				int LA131_2 = input.LA(2);

				if ((EvaluatePredicate(synpred143_JavaScript_fragment)))
				{
					alt131 = 1;
				}
				else if ((true))
				{
					alt131 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 40:
			case 52:
			case 53:
			case 56:
			case 57:
			case 87:
			case 105:
			case 107:
			case 115:
				{
				alt131 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 131, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(131); }
			switch (alt131)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:279:4: conditionalExpressionNoIn
				{
				DebugLocation(279, 4);
				PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn2297);
				conditionalExpressionNoIn255=conditionalExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionalExpressionNoIn.Add(conditionalExpressionNoIn255.Tree);


				{
				// AST REWRITE
				// elements: conditionalExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 279:30: -> conditionalExpressionNoIn
				{
					DebugLocation(279, 33);
					adaptor.AddChild(root_0, stream_conditionalExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:280:4: lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpressionNoIn
				{
				DebugLocation(280, 6);
				PushFollow(Follow._leftHandSideExpression_in_assignmentExpressionNoIn2308);
				lh=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_leftHandSideExpression.Add(lh.Tree);
				DebugLocation(280, 30);
				// JavaScript.g:280:30: ( LT )*
				try { DebugEnterSubRule(129);
				while (true)
				{
					int alt129=2;
					try { DebugEnterDecision(129, false);
					int LA129_1 = input.LA(1);

					if ((LA129_1==LT))
					{
						alt129 = 1;
					}


					} finally { DebugExitDecision(129); }
					switch ( alt129 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:280:30: LT
						{
						DebugLocation(280, 30);
						LT256=(IToken)Match(input,LT,Follow._LT_in_assignmentExpressionNoIn2310); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT256);


						}
						break;

					default:
						goto loop129;
					}
				}

				loop129:
					;

				} finally { DebugExitSubRule(129); }

				DebugLocation(280, 36);
				PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn2315);
				op=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentOperator.Add(op.Tree);
				DebugLocation(280, 56);
				// JavaScript.g:280:56: ( LT )*
				try { DebugEnterSubRule(130);
				while (true)
				{
					int alt130=2;
					try { DebugEnterDecision(130, false);
					int LA130_1 = input.LA(1);

					if ((LA130_1==LT))
					{
						alt130 = 1;
					}


					} finally { DebugExitDecision(130); }
					switch ( alt130 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:280:56: LT
						{
						DebugLocation(280, 56);
						LT257=(IToken)Match(input,LT,Follow._LT_in_assignmentExpressionNoIn2317); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT257);


						}
						break;

					default:
						goto loop130;
					}
				}

				loop130:
					;

				} finally { DebugExitSubRule(130); }

				DebugLocation(280, 62);
				PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn2322);
				rh=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(rh.Tree);


				{
				// AST REWRITE
				// elements: 68, lh, rh, 51, lh, rh, 61, lh, rh, 44, lh, rh, 54, lh, rh, 58, lh, rh, 66, lh, rh, 74, lh, rh, 76, lh, rh, 47, lh, rh, 81, lh, rh, 112, lh, rh
				// token labels: 
				// rule labels: lh, rh, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_lh=new RewriteRuleSubtreeStream(adaptor,"rule lh",lh!=null?lh.Tree:null);
				RewriteRuleSubtreeStream stream_rh=new RewriteRuleSubtreeStream(adaptor,"rule rh",rh!=null?rh.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 281:9: -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh)
				if (op.Tree.Text == "="    )
				{
					DebugLocation(281, 39);
					// JavaScript.g:281:39: ^( '=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(281, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AssignExpression(68), root_1);

					DebugLocation(281, 69);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(281, 73);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 282:9: -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh)
				if (op.Tree.Text == "*="   )
				{
					DebugLocation(282, 39);
					// JavaScript.g:282:39: ^( '*=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(282, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new MultiplyAndAssignExpression(51), root_1);

					DebugLocation(282, 81);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(282, 85);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 283:3: -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh)
				if (op.Tree.Text == "/="   )
				{
					DebugLocation(283, 33);
					// JavaScript.g:283:33: ^( '/=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(283, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DivideAndAssignExpression(61), root_1);

					DebugLocation(283, 73);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(283, 77);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 284:3: -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh)
				if (op.Tree.Text == "%="  )
				{
					DebugLocation(284, 33);
					// JavaScript.g:284:33: ^( '%=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(284, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ModulusAndAssignExpression(44), root_1);

					DebugLocation(284, 74);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(284, 78);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 285:3: -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh)
				if (op.Tree.Text == "+="   )
				{
					DebugLocation(285, 33);
					// JavaScript.g:285:33: ^( '+=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(285, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AddAndAssignExpression(54), root_1);

					DebugLocation(285, 70);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(285, 74);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 286:3: -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh)
				if (op.Tree.Text == "-="   )
				{
					DebugLocation(286, 33);
					// JavaScript.g:286:33: ^( '-=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(286, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new SubtractAndAssignExpression(58), root_1);

					DebugLocation(286, 75);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(286, 79);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 287:3: -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh)
				if (op.Tree.Text == "<<="  )
				{
					DebugLocation(287, 33);
					// JavaScript.g:287:33: ^( '<<=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(287, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftLeftAndAssignExpression(66), root_1);

					DebugLocation(287, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(287, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 288:3: -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh)
				if (op.Tree.Text == ">>="  )
				{
					DebugLocation(288, 33);
					// JavaScript.g:288:33: ^( '>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(288, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftRightAndAssignExpression(74), root_1);

					DebugLocation(288, 78);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(288, 82);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 289:3: -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh)
				if (op.Tree.Text == ">>>=" )
				{
					DebugLocation(289, 33);
					// JavaScript.g:289:33: ^( '>>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(289, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new RotateRightAndAssignExpression(76), root_1);

					DebugLocation(289, 80);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(289, 84);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 290:3: -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh)
				if (op.Tree.Text == "&="   )
				{
					DebugLocation(290, 33);
					// JavaScript.g:290:33: ^( '&=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(290, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndAndAssignExpression(47), root_1);

					DebugLocation(290, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(290, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 291:3: -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh)
				if (op.Tree.Text == "^="   )
				{
					DebugLocation(291, 33);
					// JavaScript.g:291:33: ^( '^=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(291, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorAndAssignExpression(81), root_1);

					DebugLocation(291, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(291, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 292:3: -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh)
				if (op.Tree.Text == "|="   )
				{
					DebugLocation(292, 33);
					// JavaScript.g:292:33: ^( '|=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(292, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrAndAssignExpression(112), root_1);

					DebugLocation(292, 76);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(292, 80);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 293:9: ->
				{
					DebugLocation(294, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpressionNoIn", 44);
			LeaveRule("assignmentExpressionNoIn", 44);
			LeaveRule_assignmentExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 44, assignmentExpressionNoIn_StartIndex); }

		}
		DebugLocation(294, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "assignmentExpressionNoIn"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();
	// $ANTLR start "assignmentOperator"
	// JavaScript.g:296:1: assignmentOperator : ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 45);
		TraceIn("assignmentOperator", 45);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentOperator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set258 = default(IToken);

		CommonTree set258_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(296, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 45)) { return retval; }

			// JavaScript.g:297:2: ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(297, 2);

			set258=(IToken)input.LT(1);
			if (input.LA(1)==44||input.LA(1)==47||input.LA(1)==51||input.LA(1)==54||input.LA(1)==58||input.LA(1)==61||input.LA(1)==66||input.LA(1)==68||input.LA(1)==74||input.LA(1)==76||input.LA(1)==81||input.LA(1)==112)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set258));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentOperator", 45);
			LeaveRule("assignmentOperator", 45);
			LeaveRule_assignmentOperator();
			if (state.backtracking > 0) { Memoize(input, 45, assignmentOperator_StartIndex); }

		}
		DebugLocation(298, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();
	// $ANTLR start "leftHandSideExpression"
	// JavaScript.g:300:1: leftHandSideExpression : ( callExpression | newExpression );
	[GrammarRule("leftHandSideExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 46);
		TraceIn("leftHandSideExpression", 46);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int leftHandSideExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> callExpression259 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> newExpression260 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(300, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 46)) { return retval; }

			// JavaScript.g:301:2: ( callExpression | newExpression )
			int alt132=2;
			try { DebugEnterDecision(132, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 98:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 103:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 90:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case StringLiteral:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 78:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 110:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 48:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 93:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred157_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(132); }
			switch (alt132)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:301:4: callExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(301, 4);
				PushFollow(Follow._callExpression_in_leftHandSideExpression2663);
				callExpression259=callExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, callExpression259.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:302:4: newExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(302, 4);
				PushFollow(Follow._newExpression_in_leftHandSideExpression2668);
				newExpression260=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression260.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("leftHandSideExpression", 46);
			LeaveRule("leftHandSideExpression", 46);
			LeaveRule_leftHandSideExpression();
			if (state.backtracking > 0) { Memoize(input, 46, leftHandSideExpression_StartIndex); }

		}
		DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return retval;

	}
	// $ANTLR end "leftHandSideExpression"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// JavaScript.g:305:1: newExpression : ( memberExpression | 'new' ( LT )* newExpression -> ^( 'new' newExpression ) );
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 47);
		TraceIn("newExpression", 47);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int newExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal262 = default(IToken);
		IToken LT263 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> memberExpression261 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> newExpression264 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal262_tree = default(CommonTree);
		CommonTree LT263_tree = default(CommonTree);
		RewriteRuleITokenStream stream_97=new RewriteRuleITokenStream(adaptor,"token 97");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_newExpression=new RewriteRuleSubtreeStream(adaptor,"rule newExpression");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(305, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 47)) { return retval; }

			// JavaScript.g:306:2: ( memberExpression | 'new' ( LT )* newExpression -> ^( 'new' newExpression ) )
			int alt134=2;
			try { DebugEnterDecision(134, false);
			int LA134_1 = input.LA(1);

			if ((LA134_1==Identifier||LA134_1==NumericLiteral||LA134_1==StringLiteral||LA134_1==48||LA134_1==78||LA134_1==90||LA134_1==93||LA134_1==98||LA134_1==101||LA134_1==103||LA134_1==110))
			{
				alt134 = 1;
			}
			else if ((LA134_1==97))
			{
				int LA134_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt134 = 1;
				}
				else if ((true))
				{
					alt134 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 134, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 134, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(134); }
			switch (alt134)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:306:4: memberExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(306, 4);
				PushFollow(Follow._memberExpression_in_newExpression2680);
				memberExpression261=memberExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpression261.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:307:4: 'new' ( LT )* newExpression
				{
				DebugLocation(307, 4);
				string_literal262=(IToken)Match(input,97,Follow._97_in_newExpression2685); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_97.Add(string_literal262);

				DebugLocation(307, 10);
				// JavaScript.g:307:10: ( LT )*
				try { DebugEnterSubRule(133);
				while (true)
				{
					int alt133=2;
					try { DebugEnterDecision(133, false);
					int LA133_1 = input.LA(1);

					if ((LA133_1==LT))
					{
						alt133 = 1;
					}


					} finally { DebugExitDecision(133); }
					switch ( alt133 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:307:10: LT
						{
						DebugLocation(307, 10);
						LT263=(IToken)Match(input,LT,Follow._LT_in_newExpression2687); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT263);


						}
						break;

					default:
						goto loop133;
					}
				}

				loop133:
					;

				} finally { DebugExitSubRule(133); }

				DebugLocation(307, 14);
				PushFollow(Follow._newExpression_in_newExpression2690);
				newExpression264=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_newExpression.Add(newExpression264.Tree);


				{
				// AST REWRITE
				// elements: 97, newExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 307:28: -> ^( 'new' newExpression )
				{
					DebugLocation(307, 31);
					// JavaScript.g:307:31: ^( 'new' newExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(307, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NewExpression(stream_97.NextToken()), root_1);

					DebugLocation(307, 59);
					adaptor.AddChild(root_1, stream_newExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 47);
			LeaveRule("newExpression", 47);
			LeaveRule_newExpression();
			if (state.backtracking > 0) { Memoize(input, 47, newExpression_StartIndex); }

		}
		DebugLocation(308, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();
	// $ANTLR start "memberExpression"
	// JavaScript.g:310:1: memberExpression : ( nonMemberExpression -> nonMemberExpression ) ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )* ;
	[GrammarRule("memberExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 48);
		TraceIn("memberExpression", 48);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int memberExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT266 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> nonMemberExpression265 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> indexSuffix267 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propertyReferenceSuffix268 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT266_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_nonMemberExpression=new RewriteRuleSubtreeStream(adaptor,"rule nonMemberExpression");
		RewriteRuleSubtreeStream stream_indexSuffix=new RewriteRuleSubtreeStream(adaptor,"rule indexSuffix");
		RewriteRuleSubtreeStream stream_propertyReferenceSuffix=new RewriteRuleSubtreeStream(adaptor,"rule propertyReferenceSuffix");
		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(310, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 48)) { return retval; }

			// JavaScript.g:311:5: ( ( nonMemberExpression -> nonMemberExpression ) ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )* )
			DebugEnterAlt(1);
			// JavaScript.g:312:9: ( nonMemberExpression -> nonMemberExpression ) ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )*
			{
			DebugLocation(312, 9);
			// JavaScript.g:312:9: ( nonMemberExpression -> nonMemberExpression )
			DebugEnterAlt(1);
			// JavaScript.g:312:10: nonMemberExpression
			{
			DebugLocation(312, 10);
			PushFollow(Follow._nonMemberExpression_in_memberExpression2727);
			nonMemberExpression265=nonMemberExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_nonMemberExpression.Add(nonMemberExpression265.Tree);


			{
			// AST REWRITE
			// elements: nonMemberExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 312:30: -> nonMemberExpression
			{
				DebugLocation(312, 33);
				adaptor.AddChild(root_0, stream_nonMemberExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(313, 9);
			// JavaScript.g:313:9: ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )*
			try { DebugEnterSubRule(137);
			while (true)
			{
				int alt137=2;
				try { DebugEnterDecision(137, false);
				int LA137_1 = input.LA(1);

				if ((LA137_1==LT))
				{
					int LA137_2 = input.LA(2);

					if ((EvaluatePredicate(synpred162_JavaScript_fragment)))
					{
						alt137 = 1;
					}


				}
				else if ((LA137_1==59||LA137_1==78))
				{
					alt137 = 1;
				}


				} finally { DebugExitDecision(137); }
				switch ( alt137 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:314:13: ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) )
					{
					DebugLocation(314, 13);
					// JavaScript.g:314:13: ( LT )*
					try { DebugEnterSubRule(135);
					while (true)
					{
						int alt135=2;
						try { DebugEnterDecision(135, false);
						int LA135_1 = input.LA(1);

						if ((LA135_1==LT))
						{
							alt135 = 1;
						}


						} finally { DebugExitDecision(135); }
						switch ( alt135 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:314:13: LT
							{
							DebugLocation(314, 13);
							LT266=(IToken)Match(input,LT,Follow._LT_in_memberExpression2756); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT266);


							}
							break;

						default:
							goto loop135;
						}
					}

					loop135:
						;

					} finally { DebugExitSubRule(135); }

					DebugLocation(315, 13);
					// JavaScript.g:315:13: ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) )
					int alt136=2;
					try { DebugEnterSubRule(136);
					try { DebugEnterDecision(136, false);
					int LA136_1 = input.LA(1);

					if ((LA136_1==78))
					{
						alt136 = 1;
					}
					else if ((LA136_1==59))
					{
						alt136 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 136, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(136); }
					switch (alt136)
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:316:17: indexSuffix
						{
						DebugLocation(316, 17);
						PushFollow(Follow._indexSuffix_in_memberExpression2790);
						indexSuffix267=indexSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_indexSuffix.Add(indexSuffix267.Tree);


						{
						// AST REWRITE
						// elements: memberExpression, indexSuffix
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 316:57: -> ^( INDEXEXPR $memberExpression indexSuffix )
						{
							DebugLocation(316, 60);
							// JavaScript.g:316:60: ^( INDEXEXPR $memberExpression indexSuffix )
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(316, 62);
							root_1 = (CommonTree)adaptor.BecomeRoot(new IndexExpression(INDEXEXPR), root_1);

							DebugLocation(316, 95);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(316, 112);
							adaptor.AddChild(root_1, stream_indexSuffix.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// JavaScript.g:317:19: propertyReferenceSuffix
						{
						DebugLocation(317, 19);
						PushFollow(Follow._propertyReferenceSuffix_in_memberExpression2854);
						propertyReferenceSuffix268=propertyReferenceSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_propertyReferenceSuffix.Add(propertyReferenceSuffix268.Tree);


						{
						// AST REWRITE
						// elements: memberExpression, propertyReferenceSuffix
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 317:57: -> ^( PROPEXPR $memberExpression propertyReferenceSuffix )
						{
							DebugLocation(317, 60);
							// JavaScript.g:317:60: ^( PROPEXPR $memberExpression propertyReferenceSuffix )
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(317, 62);
							root_1 = (CommonTree)adaptor.BecomeRoot(new PropertyExpression(PROPEXPR), root_1);

							DebugLocation(317, 97);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(317, 114);
							adaptor.AddChild(root_1, stream_propertyReferenceSuffix.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					}
					} finally { DebugExitSubRule(136); }


					}
					break;

				default:
					goto loop137;
				}
			}

			loop137:
				;

			} finally { DebugExitSubRule(137); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberExpression", 48);
			LeaveRule("memberExpression", 48);
			LeaveRule_memberExpression();
			if (state.backtracking > 0) { Memoize(input, 48, memberExpression_StartIndex); }

		}
		DebugLocation(320, 4);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return retval;

	}
	// $ANTLR end "memberExpression"

	partial void EnterRule_nonMemberExpression();
	partial void LeaveRule_nonMemberExpression();
	// $ANTLR start "nonMemberExpression"
	// JavaScript.g:322:1: nonMemberExpression : ( primaryExpression -> primaryExpression | functionExpression -> functionExpression | 'new' ( LT )* memberExpression ( LT )* arguments -> ^( 'new' memberExpression arguments ) );
	[GrammarRule("nonMemberExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> nonMemberExpression()
	{
		EnterRule_nonMemberExpression();
		EnterRule("nonMemberExpression", 49);
		TraceIn("nonMemberExpression", 49);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonMemberExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal271 = default(IToken);
		IToken LT272 = default(IToken);
		IToken LT274 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primaryExpression269 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionExpression270 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> memberExpression273 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arguments275 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal271_tree = default(CommonTree);
		CommonTree LT272_tree = default(CommonTree);
		CommonTree LT274_tree = default(CommonTree);
		RewriteRuleITokenStream stream_97=new RewriteRuleITokenStream(adaptor,"token 97");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		RewriteRuleSubtreeStream stream_functionExpression=new RewriteRuleSubtreeStream(adaptor,"rule functionExpression");
		RewriteRuleSubtreeStream stream_memberExpression=new RewriteRuleSubtreeStream(adaptor,"rule memberExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "nonMemberExpression");
		DebugLocation(322, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 49)) { return retval; }

			// JavaScript.g:323:5: ( primaryExpression -> primaryExpression | functionExpression -> functionExpression | 'new' ( LT )* memberExpression ( LT )* arguments -> ^( 'new' memberExpression arguments ) )
			int alt140=3;
			try { DebugEnterDecision(140, false);
			switch (input.LA(1))
			{
			case Identifier:
			case NumericLiteral:
			case StringLiteral:
			case 48:
			case 78:
			case 90:
			case 98:
			case 101:
			case 103:
			case 110:
				{
				alt140 = 1;
				}
				break;
			case 93:
				{
				alt140 = 2;
				}
				break;
			case 97:
				{
				alt140 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 140, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(140); }
			switch (alt140)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:323:7: primaryExpression
				{
				DebugLocation(323, 7);
				PushFollow(Follow._primaryExpression_in_nonMemberExpression2926);
				primaryExpression269=primaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression269.Tree);


				{
				// AST REWRITE
				// elements: primaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 323:49: -> primaryExpression
				{
					DebugLocation(323, 52);
					adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:324:4: functionExpression
				{
				DebugLocation(324, 4);
				PushFollow(Follow._functionExpression_in_nonMemberExpression2959);
				functionExpression270=functionExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_functionExpression.Add(functionExpression270.Tree);


				{
				// AST REWRITE
				// elements: functionExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 324:46: -> functionExpression
				{
					DebugLocation(324, 49);
					adaptor.AddChild(root_0, stream_functionExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:325:4: 'new' ( LT )* memberExpression ( LT )* arguments
				{
				DebugLocation(325, 4);
				string_literal271=(IToken)Match(input,97,Follow._97_in_nonMemberExpression2991); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_97.Add(string_literal271);

				DebugLocation(325, 10);
				// JavaScript.g:325:10: ( LT )*
				try { DebugEnterSubRule(138);
				while (true)
				{
					int alt138=2;
					try { DebugEnterDecision(138, false);
					int LA138_1 = input.LA(1);

					if ((LA138_1==LT))
					{
						alt138 = 1;
					}


					} finally { DebugExitDecision(138); }
					switch ( alt138 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:325:10: LT
						{
						DebugLocation(325, 10);
						LT272=(IToken)Match(input,LT,Follow._LT_in_nonMemberExpression2993); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT272);


						}
						break;

					default:
						goto loop138;
					}
				}

				loop138:
					;

				} finally { DebugExitSubRule(138); }

				DebugLocation(325, 14);
				PushFollow(Follow._memberExpression_in_nonMemberExpression2996);
				memberExpression273=memberExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_memberExpression.Add(memberExpression273.Tree);
				DebugLocation(325, 32);
				// JavaScript.g:325:32: ( LT )*
				try { DebugEnterSubRule(139);
				while (true)
				{
					int alt139=2;
					try { DebugEnterDecision(139, false);
					int LA139_1 = input.LA(1);

					if ((LA139_1==LT))
					{
						alt139 = 1;
					}


					} finally { DebugExitDecision(139); }
					switch ( alt139 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:325:32: LT
						{
						DebugLocation(325, 32);
						LT274=(IToken)Match(input,LT,Follow._LT_in_nonMemberExpression2999); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT274);


						}
						break;

					default:
						goto loop139;
					}
				}

				loop139:
					;

				} finally { DebugExitSubRule(139); }

				DebugLocation(325, 36);
				PushFollow(Follow._arguments_in_nonMemberExpression3002);
				arguments275=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arguments.Add(arguments275.Tree);


				{
				// AST REWRITE
				// elements: 97, memberExpression, arguments
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 325:46: -> ^( 'new' memberExpression arguments )
				{
					DebugLocation(325, 49);
					// JavaScript.g:325:49: ^( 'new' memberExpression arguments )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(325, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NewExpression(stream_97.NextToken()), root_1);

					DebugLocation(325, 77);
					adaptor.AddChild(root_1, stream_memberExpression.NextTree());
					DebugLocation(325, 94);
					adaptor.AddChild(root_1, stream_arguments.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonMemberExpression", 49);
			LeaveRule("nonMemberExpression", 49);
			LeaveRule_nonMemberExpression();
			if (state.backtracking > 0) { Memoize(input, 49, nonMemberExpression_StartIndex); }

		}
		DebugLocation(326, 4);
		} finally { DebugExitRule(GrammarFileName, "nonMemberExpression"); }
		return retval;

	}
	// $ANTLR end "nonMemberExpression"

	partial void EnterRule_callExpression();
	partial void LeaveRule_callExpression();
	// $ANTLR start "callExpression"
	// JavaScript.g:328:1: callExpression : (pce= primaryCallExpression -> $pce) ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )* ;
	[GrammarRule("callExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> callExpression()
	{
		EnterRule_callExpression();
		EnterRule("callExpression", 50);
		TraceIn("callExpression", 50);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int callExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT276 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> pce = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> args = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> idx = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> prop = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT276_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_primaryCallExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryCallExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_indexSuffix=new RewriteRuleSubtreeStream(adaptor,"rule indexSuffix");
		RewriteRuleSubtreeStream stream_propertyReferenceSuffix=new RewriteRuleSubtreeStream(adaptor,"rule propertyReferenceSuffix");
		try { DebugEnterRule(GrammarFileName, "callExpression");
		DebugLocation(328, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 50)) { return retval; }

			// JavaScript.g:329:2: ( (pce= primaryCallExpression -> $pce) ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )* )
			DebugEnterAlt(1);
			// JavaScript.g:330:9: (pce= primaryCallExpression -> $pce) ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )*
			{
			DebugLocation(330, 9);
			// JavaScript.g:330:9: (pce= primaryCallExpression -> $pce)
			DebugEnterAlt(1);
			// JavaScript.g:330:10: pce= primaryCallExpression
			{
			DebugLocation(330, 13);
			PushFollow(Follow._primaryCallExpression_in_callExpression3043);
			pce=primaryCallExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryCallExpression.Add(pce.Tree);


			{
			// AST REWRITE
			// elements: pce
			// token labels: 
			// rule labels: pce, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_pce=new RewriteRuleSubtreeStream(adaptor,"rule pce",pce!=null?pce.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 330:36: -> $pce
			{
				DebugLocation(330, 40);
				adaptor.AddChild(root_0, stream_pce.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(331, 9);
			// JavaScript.g:331:9: ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )*
			try { DebugEnterSubRule(143);
			while (true)
			{
				int alt143=2;
				try { DebugEnterDecision(143, false);
				int LA143_1 = input.LA(1);

				if ((LA143_1==LT))
				{
					int LA143_2 = input.LA(2);

					if ((EvaluatePredicate(synpred170_JavaScript_fragment)))
					{
						alt143 = 1;
					}


				}
				else if ((LA143_1==48||LA143_1==59||LA143_1==78))
				{
					alt143 = 1;
				}


				} finally { DebugExitDecision(143); }
				switch ( alt143 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:332:13: ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) )
					{
					DebugLocation(332, 13);
					// JavaScript.g:332:13: ( LT )*
					try { DebugEnterSubRule(141);
					while (true)
					{
						int alt141=2;
						try { DebugEnterDecision(141, false);
						int LA141_1 = input.LA(1);

						if ((LA141_1==LT))
						{
							alt141 = 1;
						}


						} finally { DebugExitDecision(141); }
						switch ( alt141 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:332:13: LT
							{
							DebugLocation(332, 13);
							LT276=(IToken)Match(input,LT,Follow._LT_in_callExpression3073); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT276);


							}
							break;

						default:
							goto loop141;
						}
					}

					loop141:
						;

					} finally { DebugExitSubRule(141); }

					DebugLocation(333, 13);
					// JavaScript.g:333:13: (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) )
					int alt142=3;
					try { DebugEnterSubRule(142);
					try { DebugEnterDecision(142, false);
					switch (input.LA(1))
					{
					case 48:
						{
						alt142 = 1;
						}
						break;
					case 78:
						{
						alt142 = 2;
						}
						break;
					case 59:
						{
						alt142 = 3;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 142, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(142); }
					switch (alt142)
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:334:17: args= arguments
						{
						DebugLocation(334, 21);
						PushFollow(Follow._arguments_in_callExpression3109);
						args=arguments();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_arguments.Add(args.Tree);


						{
						// AST REWRITE
						// elements: callExpression, args
						// token labels: 
						// rule labels: args, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args",args!=null?args.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 334:49: -> ^( CALLEXPR $callExpression $args)
						{
							DebugLocation(334, 52);
							// JavaScript.g:334:52: ^( CALLEXPR $callExpression $args)
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(334, 54);
							root_1 = (CommonTree)adaptor.BecomeRoot(new CallExpression(CALLEXPR), root_1);

							DebugLocation(334, 85);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(334, 101);
							adaptor.AddChild(root_1, stream_args.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// JavaScript.g:335:16: idx= indexSuffix
						{
						DebugLocation(335, 19);
						PushFollow(Follow._indexSuffix_in_callExpression3162);
						idx=indexSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_indexSuffix.Add(idx.Tree);


						{
						// AST REWRITE
						// elements: callExpression, idx
						// token labels: 
						// rule labels: idx, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_idx=new RewriteRuleSubtreeStream(adaptor,"rule idx",idx!=null?idx.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 335:46: -> ^( INDEXEXPR $callExpression $idx)
						{
							DebugLocation(335, 49);
							// JavaScript.g:335:49: ^( INDEXEXPR $callExpression $idx)
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(335, 51);
							root_1 = (CommonTree)adaptor.BecomeRoot(new IndexExpression(INDEXEXPR), root_1);

							DebugLocation(335, 84);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(335, 100);
							adaptor.AddChild(root_1, stream_idx.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// JavaScript.g:336:16: prop= propertyReferenceSuffix
						{
						DebugLocation(336, 20);
						PushFollow(Follow._propertyReferenceSuffix_in_callExpression3212);
						prop=propertyReferenceSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_propertyReferenceSuffix.Add(prop.Tree);


						{
						// AST REWRITE
						// elements: callExpression, prop
						// token labels: 
						// rule labels: prop, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_prop=new RewriteRuleSubtreeStream(adaptor,"rule prop",prop!=null?prop.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 336:46: -> ^( PROPEXPR $callExpression $prop)
						{
							DebugLocation(336, 49);
							// JavaScript.g:336:49: ^( PROPEXPR $callExpression $prop)
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(336, 51);
							root_1 = (CommonTree)adaptor.BecomeRoot(new PropertyExpression(PROPEXPR), root_1);

							DebugLocation(336, 86);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(336, 102);
							adaptor.AddChild(root_1, stream_prop.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					}
					} finally { DebugExitSubRule(142); }


					}
					break;

				default:
					goto loop143;
				}
			}

			loop143:
				;

			} finally { DebugExitSubRule(143); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("callExpression", 50);
			LeaveRule("callExpression", 50);
			LeaveRule_callExpression();
			if (state.backtracking > 0) { Memoize(input, 50, callExpression_StartIndex); }

		}
		DebugLocation(339, 4);
		} finally { DebugExitRule(GrammarFileName, "callExpression"); }
		return retval;

	}
	// $ANTLR end "callExpression"

	partial void EnterRule_primaryCallExpression();
	partial void LeaveRule_primaryCallExpression();
	// $ANTLR start "primaryCallExpression"
	// JavaScript.g:341:1: primaryCallExpression : me= memberExpression ( LT )* a= arguments -> ^( CALLEXPR $me $a) ;
	[GrammarRule("primaryCallExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> primaryCallExpression()
	{
		EnterRule_primaryCallExpression();
		EnterRule("primaryCallExpression", 51);
		TraceIn("primaryCallExpression", 51);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primaryCallExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT277 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> me = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT277_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_memberExpression=new RewriteRuleSubtreeStream(adaptor,"rule memberExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "primaryCallExpression");
		DebugLocation(341, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 51)) { return retval; }

			// JavaScript.g:342:5: (me= memberExpression ( LT )* a= arguments -> ^( CALLEXPR $me $a) )
			DebugEnterAlt(1);
			// JavaScript.g:342:7: me= memberExpression ( LT )* a= arguments
			{
			DebugLocation(342, 9);
			PushFollow(Follow._memberExpression_in_primaryCallExpression3274);
			me=memberExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_memberExpression.Add(me.Tree);
			DebugLocation(342, 27);
			// JavaScript.g:342:27: ( LT )*
			try { DebugEnterSubRule(144);
			while (true)
			{
				int alt144=2;
				try { DebugEnterDecision(144, false);
				int LA144_1 = input.LA(1);

				if ((LA144_1==LT))
				{
					alt144 = 1;
				}


				} finally { DebugExitDecision(144); }
				switch ( alt144 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:342:27: LT
					{
					DebugLocation(342, 27);
					LT277=(IToken)Match(input,LT,Follow._LT_in_primaryCallExpression3276); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT277);


					}
					break;

				default:
					goto loop144;
				}
			}

			loop144:
				;

			} finally { DebugExitSubRule(144); }

			DebugLocation(342, 32);
			PushFollow(Follow._arguments_in_primaryCallExpression3281);
			a=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arguments.Add(a.Tree);


			{
			// AST REWRITE
			// elements: me, a
			// token labels: 
			// rule labels: me, a, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_me=new RewriteRuleSubtreeStream(adaptor,"rule me",me!=null?me.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 342:43: -> ^( CALLEXPR $me $a)
			{
				DebugLocation(342, 46);
				// JavaScript.g:342:46: ^( CALLEXPR $me $a)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(342, 48);
				root_1 = (CommonTree)adaptor.BecomeRoot(new CallExpression(CALLEXPR), root_1);

				DebugLocation(342, 79);
				adaptor.AddChild(root_1, stream_me.NextTree());
				DebugLocation(342, 83);
				adaptor.AddChild(root_1, stream_a.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryCallExpression", 51);
			LeaveRule("primaryCallExpression", 51);
			LeaveRule_primaryCallExpression();
			if (state.backtracking > 0) { Memoize(input, 51, primaryCallExpression_StartIndex); }

		}
		DebugLocation(343, 4);
		} finally { DebugExitRule(GrammarFileName, "primaryCallExpression"); }
		return retval;

	}
	// $ANTLR end "primaryCallExpression"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// JavaScript.g:345:1: arguments : '(' ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )? ( LT )* ')' -> ^( '(' ( assignmentExpression )* ) ;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<CommonTree, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 52);
		TraceIn("arguments", 52);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arguments_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal278 = default(IToken);
		IToken LT279 = default(IToken);
		IToken LT281 = default(IToken);
		IToken char_literal282 = default(IToken);
		IToken LT283 = default(IToken);
		IToken LT285 = default(IToken);
		IToken char_literal286 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression280 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression284 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal278_tree = default(CommonTree);
		CommonTree LT279_tree = default(CommonTree);
		CommonTree LT281_tree = default(CommonTree);
		CommonTree char_literal282_tree = default(CommonTree);
		CommonTree LT283_tree = default(CommonTree);
		CommonTree LT285_tree = default(CommonTree);
		CommonTree char_literal286_tree = default(CommonTree);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(345, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 52)) { return retval; }

			// JavaScript.g:346:2: ( '(' ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )? ( LT )* ')' -> ^( '(' ( assignmentExpression )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:346:4: '(' ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )? ( LT )* ')'
			{
			DebugLocation(346, 4);
			char_literal278=(IToken)Match(input,48,Follow._48_in_arguments3313); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal278);

			DebugLocation(346, 8);
			// JavaScript.g:346:8: ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )?
			int alt149=2;
			try { DebugEnterSubRule(149);
			try { DebugEnterDecision(149, false);
			try
			{
				alt149 = dfa149.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(149); }
			switch (alt149)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:346:9: ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )*
				{
				DebugLocation(346, 9);
				// JavaScript.g:346:9: ( LT )*
				try { DebugEnterSubRule(145);
				while (true)
				{
					int alt145=2;
					try { DebugEnterDecision(145, false);
					int LA145_1 = input.LA(1);

					if ((LA145_1==LT))
					{
						alt145 = 1;
					}


					} finally { DebugExitDecision(145); }
					switch ( alt145 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:346:9: LT
						{
						DebugLocation(346, 9);
						LT279=(IToken)Match(input,LT,Follow._LT_in_arguments3316); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT279);


						}
						break;

					default:
						goto loop145;
					}
				}

				loop145:
					;

				} finally { DebugExitSubRule(145); }

				DebugLocation(346, 13);
				PushFollow(Follow._assignmentExpression_in_arguments3319);
				assignmentExpression280=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression280.Tree);
				DebugLocation(346, 34);
				// JavaScript.g:346:34: ( ( LT )* ',' ( LT )* assignmentExpression )*
				try { DebugEnterSubRule(148);
				while (true)
				{
					int alt148=2;
					try { DebugEnterDecision(148, false);
					try
					{
						alt148 = dfa148.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(148); }
					switch ( alt148 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:346:35: ( LT )* ',' ( LT )* assignmentExpression
						{
						DebugLocation(346, 35);
						// JavaScript.g:346:35: ( LT )*
						try { DebugEnterSubRule(146);
						while (true)
						{
							int alt146=2;
							try { DebugEnterDecision(146, false);
							int LA146_1 = input.LA(1);

							if ((LA146_1==LT))
							{
								alt146 = 1;
							}


							} finally { DebugExitDecision(146); }
							switch ( alt146 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:346:35: LT
								{
								DebugLocation(346, 35);
								LT281=(IToken)Match(input,LT,Follow._LT_in_arguments3322); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT281);


								}
								break;

							default:
								goto loop146;
							}
						}

						loop146:
							;

						} finally { DebugExitSubRule(146); }

						DebugLocation(346, 39);
						char_literal282=(IToken)Match(input,55,Follow._55_in_arguments3325); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal282);

						DebugLocation(346, 43);
						// JavaScript.g:346:43: ( LT )*
						try { DebugEnterSubRule(147);
						while (true)
						{
							int alt147=2;
							try { DebugEnterDecision(147, false);
							int LA147_1 = input.LA(1);

							if ((LA147_1==LT))
							{
								alt147 = 1;
							}


							} finally { DebugExitDecision(147); }
							switch ( alt147 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:346:43: LT
								{
								DebugLocation(346, 43);
								LT283=(IToken)Match(input,LT,Follow._LT_in_arguments3327); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT283);


								}
								break;

							default:
								goto loop147;
							}
						}

						loop147:
							;

						} finally { DebugExitSubRule(147); }

						DebugLocation(346, 47);
						PushFollow(Follow._assignmentExpression_in_arguments3330);
						assignmentExpression284=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression284.Tree);

						}
						break;

					default:
						goto loop148;
					}
				}

				loop148:
					;

				} finally { DebugExitSubRule(148); }


				}
				break;

			}
			} finally { DebugExitSubRule(149); }

			DebugLocation(346, 72);
			// JavaScript.g:346:72: ( LT )*
			try { DebugEnterSubRule(150);
			while (true)
			{
				int alt150=2;
				try { DebugEnterDecision(150, false);
				int LA150_1 = input.LA(1);

				if ((LA150_1==LT))
				{
					alt150 = 1;
				}


				} finally { DebugExitDecision(150); }
				switch ( alt150 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:346:72: LT
					{
					DebugLocation(346, 72);
					LT285=(IToken)Match(input,LT,Follow._LT_in_arguments3336); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT285);


					}
					break;

				default:
					goto loop150;
				}
			}

			loop150:
				;

			} finally { DebugExitSubRule(150); }

			DebugLocation(346, 76);
			char_literal286=(IToken)Match(input,49,Follow._49_in_arguments3339); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal286);



			{
			// AST REWRITE
			// elements: 48, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 347:3: -> ^( '(' ( assignmentExpression )* )
			{
				DebugLocation(347, 6);
				// JavaScript.g:347:6: ^( '(' ( assignmentExpression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(347, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ArgumentList(stream_48.NextToken()), root_1);

				DebugLocation(347, 31);
				// JavaScript.g:347:31: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(347, 31);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 52);
			LeaveRule("arguments", 52);
			LeaveRule_arguments();
			if (state.backtracking > 0) { Memoize(input, 52, arguments_StartIndex); }

		}
		DebugLocation(348, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_indexSuffix();
	partial void LeaveRule_indexSuffix();
	// $ANTLR start "indexSuffix"
	// JavaScript.g:350:1: indexSuffix : '[' ( LT )* expression ( LT )* ']' -> expression ;
	[GrammarRule("indexSuffix")]
	private AstParserRuleReturnScope<CommonTree, IToken> indexSuffix()
	{
		EnterRule_indexSuffix();
		EnterRule("indexSuffix", 53);
		TraceIn("indexSuffix", 53);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int indexSuffix_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal287 = default(IToken);
		IToken LT288 = default(IToken);
		IToken LT290 = default(IToken);
		IToken char_literal291 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression289 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal287_tree = default(CommonTree);
		CommonTree LT288_tree = default(CommonTree);
		CommonTree LT290_tree = default(CommonTree);
		CommonTree char_literal291_tree = default(CommonTree);
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "indexSuffix");
		DebugLocation(350, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 53)) { return retval; }

			// JavaScript.g:351:2: ( '[' ( LT )* expression ( LT )* ']' -> expression )
			DebugEnterAlt(1);
			// JavaScript.g:351:4: '[' ( LT )* expression ( LT )* ']'
			{
			DebugLocation(351, 4);
			char_literal287=(IToken)Match(input,78,Follow._78_in_indexSuffix3367); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_78.Add(char_literal287);

			DebugLocation(351, 8);
			// JavaScript.g:351:8: ( LT )*
			try { DebugEnterSubRule(151);
			while (true)
			{
				int alt151=2;
				try { DebugEnterDecision(151, false);
				int LA151_1 = input.LA(1);

				if ((LA151_1==LT))
				{
					alt151 = 1;
				}


				} finally { DebugExitDecision(151); }
				switch ( alt151 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:351:8: LT
					{
					DebugLocation(351, 8);
					LT288=(IToken)Match(input,LT,Follow._LT_in_indexSuffix3369); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT288);


					}
					break;

				default:
					goto loop151;
				}
			}

			loop151:
				;

			} finally { DebugExitSubRule(151); }

			DebugLocation(351, 12);
			PushFollow(Follow._expression_in_indexSuffix3372);
			expression289=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression289.Tree);
			DebugLocation(351, 23);
			// JavaScript.g:351:23: ( LT )*
			try { DebugEnterSubRule(152);
			while (true)
			{
				int alt152=2;
				try { DebugEnterDecision(152, false);
				int LA152_1 = input.LA(1);

				if ((LA152_1==LT))
				{
					alt152 = 1;
				}


				} finally { DebugExitDecision(152); }
				switch ( alt152 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:351:23: LT
					{
					DebugLocation(351, 23);
					LT290=(IToken)Match(input,LT,Follow._LT_in_indexSuffix3374); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT290);


					}
					break;

				default:
					goto loop152;
				}
			}

			loop152:
				;

			} finally { DebugExitSubRule(152); }

			DebugLocation(351, 27);
			char_literal291=(IToken)Match(input,79,Follow._79_in_indexSuffix3377); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_79.Add(char_literal291);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 351:31: -> expression
			{
				DebugLocation(351, 34);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indexSuffix", 53);
			LeaveRule("indexSuffix", 53);
			LeaveRule_indexSuffix();
			if (state.backtracking > 0) { Memoize(input, 53, indexSuffix_StartIndex); }

		}
		DebugLocation(352, 1);
		} finally { DebugExitRule(GrammarFileName, "indexSuffix"); }
		return retval;

	}
	// $ANTLR end "indexSuffix"

	partial void EnterRule_propertyReferenceSuffix();
	partial void LeaveRule_propertyReferenceSuffix();
	// $ANTLR start "propertyReferenceSuffix"
	// JavaScript.g:354:1: propertyReferenceSuffix : '.' ( LT )* Identifier -> Identifier ;
	[GrammarRule("propertyReferenceSuffix")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyReferenceSuffix()
	{
		EnterRule_propertyReferenceSuffix();
		EnterRule("propertyReferenceSuffix", 54);
		TraceIn("propertyReferenceSuffix", 54);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyReferenceSuffix_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal292 = default(IToken);
		IToken LT293 = default(IToken);
		IToken Identifier294 = default(IToken);

		CommonTree char_literal292_tree = default(CommonTree);
		CommonTree LT293_tree = default(CommonTree);
		CommonTree Identifier294_tree = default(CommonTree);
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		try { DebugEnterRule(GrammarFileName, "propertyReferenceSuffix");
		DebugLocation(354, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 54)) { return retval; }

			// JavaScript.g:355:2: ( '.' ( LT )* Identifier -> Identifier )
			DebugEnterAlt(1);
			// JavaScript.g:355:4: '.' ( LT )* Identifier
			{
			DebugLocation(355, 4);
			char_literal292=(IToken)Match(input,59,Follow._59_in_propertyReferenceSuffix3394); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(char_literal292);

			DebugLocation(355, 8);
			// JavaScript.g:355:8: ( LT )*
			try { DebugEnterSubRule(153);
			while (true)
			{
				int alt153=2;
				try { DebugEnterDecision(153, false);
				int LA153_1 = input.LA(1);

				if ((LA153_1==LT))
				{
					alt153 = 1;
				}


				} finally { DebugExitDecision(153); }
				switch ( alt153 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:355:8: LT
					{
					DebugLocation(355, 8);
					LT293=(IToken)Match(input,LT,Follow._LT_in_propertyReferenceSuffix3396); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT293);


					}
					break;

				default:
					goto loop153;
				}
			}

			loop153:
				;

			} finally { DebugExitSubRule(153); }

			DebugLocation(355, 12);
			Identifier294=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyReferenceSuffix3399); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier294);



			{
			// AST REWRITE
			// elements: Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 355:23: -> Identifier
			{
				DebugLocation(355, 26);
				adaptor.AddChild(root_0, new Identifier(stream_Identifier.NextToken()));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyReferenceSuffix", 54);
			LeaveRule("propertyReferenceSuffix", 54);
			LeaveRule_propertyReferenceSuffix();
			if (state.backtracking > 0) { Memoize(input, 54, propertyReferenceSuffix_StartIndex); }

		}
		DebugLocation(356, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyReferenceSuffix"); }
		return retval;

	}
	// $ANTLR end "propertyReferenceSuffix"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// JavaScript.g:358:1: conditionalExpression : logicalORExpression ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression ) ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 55);
		TraceIn("conditionalExpression", 55);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditionalExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT296 = default(IToken);
		IToken char_literal297 = default(IToken);
		IToken LT298 = default(IToken);
		IToken LT299 = default(IToken);
		IToken char_literal300 = default(IToken);
		IToken LT301 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> iftrue = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> iffalse = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpression295 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT296_tree = default(CommonTree);
		CommonTree char_literal297_tree = default(CommonTree);
		CommonTree LT298_tree = default(CommonTree);
		CommonTree LT299_tree = default(CommonTree);
		CommonTree char_literal300_tree = default(CommonTree);
		CommonTree LT301_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_logicalORExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpression");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(358, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 55)) { return retval; }

			// JavaScript.g:359:2: ( logicalORExpression ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:360:3: logicalORExpression ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression )
			{
			DebugLocation(360, 3);
			PushFollow(Follow._logicalORExpression_in_conditionalExpression3421);
			logicalORExpression295=logicalORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalORExpression.Add(logicalORExpression295.Tree);
			DebugLocation(361, 3);
			// JavaScript.g:361:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression )
			int alt158=2;
			try { DebugEnterSubRule(158);
			try { DebugEnterDecision(158, false);
			try
			{
				alt158 = dfa158.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(158); }
			switch (alt158)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:362:4: ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression
				{
				DebugLocation(362, 4);
				// JavaScript.g:362:4: ( LT )*
				try { DebugEnterSubRule(154);
				while (true)
				{
					int alt154=2;
					try { DebugEnterDecision(154, false);
					int LA154_1 = input.LA(1);

					if ((LA154_1==LT))
					{
						alt154 = 1;
					}


					} finally { DebugExitDecision(154); }
					switch ( alt154 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:4: LT
						{
						DebugLocation(362, 4);
						LT296=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3431); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT296);


						}
						break;

					default:
						goto loop154;
					}
				}

				loop154:
					;

				} finally { DebugExitSubRule(154); }

				DebugLocation(362, 8);
				char_literal297=(IToken)Match(input,77,Follow._77_in_conditionalExpression3434); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_77.Add(char_literal297);

				DebugLocation(362, 12);
				// JavaScript.g:362:12: ( LT )*
				try { DebugEnterSubRule(155);
				while (true)
				{
					int alt155=2;
					try { DebugEnterDecision(155, false);
					int LA155_1 = input.LA(1);

					if ((LA155_1==LT))
					{
						alt155 = 1;
					}


					} finally { DebugExitDecision(155); }
					switch ( alt155 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:12: LT
						{
						DebugLocation(362, 12);
						LT298=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3436); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT298);


						}
						break;

					default:
						goto loop155;
					}
				}

				loop155:
					;

				} finally { DebugExitSubRule(155); }

				DebugLocation(362, 22);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression3441);
				iftrue=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(iftrue.Tree);
				DebugLocation(362, 44);
				// JavaScript.g:362:44: ( LT )*
				try { DebugEnterSubRule(156);
				while (true)
				{
					int alt156=2;
					try { DebugEnterDecision(156, false);
					int LA156_1 = input.LA(1);

					if ((LA156_1==LT))
					{
						alt156 = 1;
					}


					} finally { DebugExitDecision(156); }
					switch ( alt156 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:44: LT
						{
						DebugLocation(362, 44);
						LT299=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3443); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT299);


						}
						break;

					default:
						goto loop156;
					}
				}

				loop156:
					;

				} finally { DebugExitSubRule(156); }

				DebugLocation(362, 48);
				char_literal300=(IToken)Match(input,62,Follow._62_in_conditionalExpression3446); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal300);

				DebugLocation(362, 52);
				// JavaScript.g:362:52: ( LT )*
				try { DebugEnterSubRule(157);
				while (true)
				{
					int alt157=2;
					try { DebugEnterDecision(157, false);
					int LA157_1 = input.LA(1);

					if ((LA157_1==LT))
					{
						alt157 = 1;
					}


					} finally { DebugExitDecision(157); }
					switch ( alt157 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:52: LT
						{
						DebugLocation(362, 52);
						LT301=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3448); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT301);


						}
						break;

					default:
						goto loop157;
					}
				}

				loop157:
					;

				} finally { DebugExitSubRule(157); }

				DebugLocation(362, 63);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression3453);
				iffalse=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(iffalse.Tree);


				{
				// AST REWRITE
				// elements: 77, logicalORExpression, iftrue, iffalse
				// token labels: 
				// rule labels: iftrue, iffalse, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_iftrue=new RewriteRuleSubtreeStream(adaptor,"rule iftrue",iftrue!=null?iftrue.Tree:null);
				RewriteRuleSubtreeStream stream_iffalse=new RewriteRuleSubtreeStream(adaptor,"rule iffalse",iffalse!=null?iffalse.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 363:5: -> ^( '?' logicalORExpression $iftrue $iffalse)
				{
					DebugLocation(363, 8);
					// JavaScript.g:363:8: ^( '?' logicalORExpression $iftrue $iffalse)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(363, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ConditionalExpression(stream_77.NextToken()), root_1);

					DebugLocation(363, 42);
					adaptor.AddChild(root_1, stream_logicalORExpression.NextTree());
					DebugLocation(363, 63);
					adaptor.AddChild(root_1, stream_iftrue.NextTree());
					DebugLocation(363, 71);
					adaptor.AddChild(root_1, stream_iffalse.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:364:6: 
				{

				{
				// AST REWRITE
				// elements: logicalORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 364:6: -> logicalORExpression
				{
					DebugLocation(364, 9);
					adaptor.AddChild(root_0, stream_logicalORExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(158); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 55);
			LeaveRule("conditionalExpression", 55);
			LeaveRule_conditionalExpression();
			if (state.backtracking > 0) { Memoize(input, 55, conditionalExpression_StartIndex); }

		}
		DebugLocation(366, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalExpressionNoIn();
	partial void LeaveRule_conditionalExpressionNoIn();
	// $ANTLR start "conditionalExpressionNoIn"
	// JavaScript.g:368:1: conditionalExpressionNoIn : logicalORExpressionNoIn ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn ) ;
	[GrammarRule("conditionalExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditionalExpressionNoIn()
	{
		EnterRule_conditionalExpressionNoIn();
		EnterRule("conditionalExpressionNoIn", 56);
		TraceIn("conditionalExpressionNoIn", 56);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditionalExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT303 = default(IToken);
		IToken char_literal304 = default(IToken);
		IToken LT305 = default(IToken);
		IToken LT306 = default(IToken);
		IToken char_literal307 = default(IToken);
		IToken LT308 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> iftrue = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> iffalse = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpressionNoIn302 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT303_tree = default(CommonTree);
		CommonTree char_literal304_tree = default(CommonTree);
		CommonTree LT305_tree = default(CommonTree);
		CommonTree LT306_tree = default(CommonTree);
		CommonTree char_literal307_tree = default(CommonTree);
		CommonTree LT308_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_logicalORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpressionNoIn");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
		DebugLocation(368, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 56)) { return retval; }

			// JavaScript.g:369:2: ( logicalORExpressionNoIn ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:370:3: logicalORExpressionNoIn ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn )
			{
			DebugLocation(370, 3);
			PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn3503);
			logicalORExpressionNoIn302=logicalORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalORExpressionNoIn.Add(logicalORExpressionNoIn302.Tree);
			DebugLocation(371, 3);
			// JavaScript.g:371:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn )
			int alt163=2;
			try { DebugEnterSubRule(163);
			try { DebugEnterDecision(163, false);
			try
			{
				alt163 = dfa163.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(163); }
			switch (alt163)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:372:4: ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn
				{
				DebugLocation(372, 4);
				// JavaScript.g:372:4: ( LT )*
				try { DebugEnterSubRule(159);
				while (true)
				{
					int alt159=2;
					try { DebugEnterDecision(159, false);
					int LA159_1 = input.LA(1);

					if ((LA159_1==LT))
					{
						alt159 = 1;
					}


					} finally { DebugExitDecision(159); }
					switch ( alt159 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:4: LT
						{
						DebugLocation(372, 4);
						LT303=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3513); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT303);


						}
						break;

					default:
						goto loop159;
					}
				}

				loop159:
					;

				} finally { DebugExitSubRule(159); }

				DebugLocation(372, 8);
				char_literal304=(IToken)Match(input,77,Follow._77_in_conditionalExpressionNoIn3516); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_77.Add(char_literal304);

				DebugLocation(372, 12);
				// JavaScript.g:372:12: ( LT )*
				try { DebugEnterSubRule(160);
				while (true)
				{
					int alt160=2;
					try { DebugEnterDecision(160, false);
					int LA160_1 = input.LA(1);

					if ((LA160_1==LT))
					{
						alt160 = 1;
					}


					} finally { DebugExitDecision(160); }
					switch ( alt160 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:12: LT
						{
						DebugLocation(372, 12);
						LT305=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3518); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT305);


						}
						break;

					default:
						goto loop160;
					}
				}

				loop160:
					;

				} finally { DebugExitSubRule(160); }

				DebugLocation(372, 22);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn3523);
				iftrue=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(iftrue.Tree);
				DebugLocation(372, 48);
				// JavaScript.g:372:48: ( LT )*
				try { DebugEnterSubRule(161);
				while (true)
				{
					int alt161=2;
					try { DebugEnterDecision(161, false);
					int LA161_1 = input.LA(1);

					if ((LA161_1==LT))
					{
						alt161 = 1;
					}


					} finally { DebugExitDecision(161); }
					switch ( alt161 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:48: LT
						{
						DebugLocation(372, 48);
						LT306=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3525); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT306);


						}
						break;

					default:
						goto loop161;
					}
				}

				loop161:
					;

				} finally { DebugExitSubRule(161); }

				DebugLocation(372, 52);
				char_literal307=(IToken)Match(input,62,Follow._62_in_conditionalExpressionNoIn3528); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal307);

				DebugLocation(372, 56);
				// JavaScript.g:372:56: ( LT )*
				try { DebugEnterSubRule(162);
				while (true)
				{
					int alt162=2;
					try { DebugEnterDecision(162, false);
					int LA162_1 = input.LA(1);

					if ((LA162_1==LT))
					{
						alt162 = 1;
					}


					} finally { DebugExitDecision(162); }
					switch ( alt162 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:56: LT
						{
						DebugLocation(372, 56);
						LT308=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3530); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT308);


						}
						break;

					default:
						goto loop162;
					}
				}

				loop162:
					;

				} finally { DebugExitSubRule(162); }

				DebugLocation(372, 67);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn3535);
				iffalse=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(iffalse.Tree);


				{
				// AST REWRITE
				// elements: 77, logicalORExpressionNoIn, iftrue, iffalse
				// token labels: 
				// rule labels: iftrue, iffalse, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_iftrue=new RewriteRuleSubtreeStream(adaptor,"rule iftrue",iftrue!=null?iftrue.Tree:null);
				RewriteRuleSubtreeStream stream_iffalse=new RewriteRuleSubtreeStream(adaptor,"rule iffalse",iffalse!=null?iffalse.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 373:5: -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse)
				{
					DebugLocation(373, 8);
					// JavaScript.g:373:8: ^( '?' logicalORExpressionNoIn $iftrue $iffalse)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(373, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ConditionalExpression(stream_77.NextToken()), root_1);

					DebugLocation(373, 43);
					adaptor.AddChild(root_1, stream_logicalORExpressionNoIn.NextTree());
					DebugLocation(373, 68);
					adaptor.AddChild(root_1, stream_iftrue.NextTree());
					DebugLocation(373, 76);
					adaptor.AddChild(root_1, stream_iffalse.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:374:6: 
				{

				{
				// AST REWRITE
				// elements: logicalORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 374:6: -> logicalORExpressionNoIn
				{
					DebugLocation(374, 9);
					adaptor.AddChild(root_0, stream_logicalORExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(163); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpressionNoIn", 56);
			LeaveRule("conditionalExpressionNoIn", 56);
			LeaveRule_conditionalExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 56, conditionalExpressionNoIn_StartIndex); }

		}
		DebugLocation(376, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "conditionalExpressionNoIn"

	partial void EnterRule_logicalORExpression();
	partial void LeaveRule_logicalORExpression();
	// $ANTLR start "logicalORExpression"
	// JavaScript.g:378:1: logicalORExpression : logicalANDExpression ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression ) ;
	[GrammarRule("logicalORExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalORExpression()
	{
		EnterRule_logicalORExpression();
		EnterRule("logicalORExpression", 57);
		TraceIn("logicalORExpression", 57);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalORExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT310 = default(IToken);
		IToken string_literal311 = default(IToken);
		IToken LT312 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpression309 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpression313 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT310_tree = default(CommonTree);
		CommonTree string_literal311_tree = default(CommonTree);
		CommonTree LT312_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_113=new RewriteRuleITokenStream(adaptor,"token 113");
		RewriteRuleSubtreeStream stream_logicalANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpression");
		RewriteRuleSubtreeStream stream_logicalORExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpression");
		try { DebugEnterRule(GrammarFileName, "logicalORExpression");
		DebugLocation(378, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 57)) { return retval; }

			// JavaScript.g:379:2: ( logicalANDExpression ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:380:3: logicalANDExpression ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression )
			{
			DebugLocation(380, 3);
			PushFollow(Follow._logicalANDExpression_in_logicalORExpression3586);
			logicalANDExpression309=logicalANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalANDExpression.Add(logicalANDExpression309.Tree);
			DebugLocation(381, 3);
			// JavaScript.g:381:3: ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression )
			int alt166=2;
			try { DebugEnterSubRule(166);
			try { DebugEnterDecision(166, false);
			try
			{
				alt166 = dfa166.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(166); }
			switch (alt166)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:382:4: ( ( LT )* '||' ( LT )* logicalORExpression )
				{
				DebugLocation(382, 4);
				// JavaScript.g:382:4: ( ( LT )* '||' ( LT )* logicalORExpression )
				DebugEnterAlt(1);
				// JavaScript.g:382:5: ( LT )* '||' ( LT )* logicalORExpression
				{
				DebugLocation(382, 5);
				// JavaScript.g:382:5: ( LT )*
				try { DebugEnterSubRule(164);
				while (true)
				{
					int alt164=2;
					try { DebugEnterDecision(164, false);
					int LA164_1 = input.LA(1);

					if ((LA164_1==LT))
					{
						alt164 = 1;
					}


					} finally { DebugExitDecision(164); }
					switch ( alt164 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:382:5: LT
						{
						DebugLocation(382, 5);
						LT310=(IToken)Match(input,LT,Follow._LT_in_logicalORExpression3597); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT310);


						}
						break;

					default:
						goto loop164;
					}
				}

				loop164:
					;

				} finally { DebugExitSubRule(164); }

				DebugLocation(382, 9);
				string_literal311=(IToken)Match(input,113,Follow._113_in_logicalORExpression3600); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_113.Add(string_literal311);

				DebugLocation(382, 14);
				// JavaScript.g:382:14: ( LT )*
				try { DebugEnterSubRule(165);
				while (true)
				{
					int alt165=2;
					try { DebugEnterDecision(165, false);
					int LA165_1 = input.LA(1);

					if ((LA165_1==LT))
					{
						alt165 = 1;
					}


					} finally { DebugExitDecision(165); }
					switch ( alt165 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:382:14: LT
						{
						DebugLocation(382, 14);
						LT312=(IToken)Match(input,LT,Follow._LT_in_logicalORExpression3602); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT312);


						}
						break;

					default:
						goto loop165;
					}
				}

				loop165:
					;

				} finally { DebugExitSubRule(165); }

				DebugLocation(382, 18);
				PushFollow(Follow._logicalORExpression_in_logicalORExpression3605);
				logicalORExpression313=logicalORExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalORExpression.Add(logicalORExpression313.Tree);

				}



				{
				// AST REWRITE
				// elements: 113, logicalANDExpression, logicalORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 383:5: -> ^( '||' logicalANDExpression logicalORExpression )
				{
					DebugLocation(383, 8);
					// JavaScript.g:383:8: ^( '||' logicalANDExpression logicalORExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(383, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalOrExpression(stream_113.NextToken()), root_1);

					DebugLocation(383, 41);
					adaptor.AddChild(root_1, stream_logicalANDExpression.NextTree());
					DebugLocation(383, 62);
					adaptor.AddChild(root_1, stream_logicalORExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:384:6: 
				{

				{
				// AST REWRITE
				// elements: logicalANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 384:6: -> logicalANDExpression
				{
					DebugLocation(384, 9);
					adaptor.AddChild(root_0, stream_logicalANDExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(166); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpression", 57);
			LeaveRule("logicalORExpression", 57);
			LeaveRule_logicalORExpression();
			if (state.backtracking > 0) { Memoize(input, 57, logicalORExpression_StartIndex); }

		}
		DebugLocation(386, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
		return retval;

	}
	// $ANTLR end "logicalORExpression"

	partial void EnterRule_logicalORExpressionNoIn();
	partial void LeaveRule_logicalORExpressionNoIn();
	// $ANTLR start "logicalORExpressionNoIn"
	// JavaScript.g:388:1: logicalORExpressionNoIn : logicalANDExpressionNoIn ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn ) ;
	[GrammarRule("logicalORExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalORExpressionNoIn()
	{
		EnterRule_logicalORExpressionNoIn();
		EnterRule("logicalORExpressionNoIn", 58);
		TraceIn("logicalORExpressionNoIn", 58);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalORExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT315 = default(IToken);
		IToken string_literal316 = default(IToken);
		IToken LT317 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpressionNoIn314 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpressionNoIn318 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT315_tree = default(CommonTree);
		CommonTree string_literal316_tree = default(CommonTree);
		CommonTree LT317_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_113=new RewriteRuleITokenStream(adaptor,"token 113");
		RewriteRuleSubtreeStream stream_logicalANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpressionNoIn");
		RewriteRuleSubtreeStream stream_logicalORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
		DebugLocation(388, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 58)) { return retval; }

			// JavaScript.g:389:2: ( logicalANDExpressionNoIn ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:390:3: logicalANDExpressionNoIn ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn )
			{
			DebugLocation(390, 3);
			PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn3653);
			logicalANDExpressionNoIn314=logicalANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalANDExpressionNoIn.Add(logicalANDExpressionNoIn314.Tree);
			DebugLocation(391, 3);
			// JavaScript.g:391:3: ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn )
			int alt169=2;
			try { DebugEnterSubRule(169);
			try { DebugEnterDecision(169, false);
			try
			{
				alt169 = dfa169.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(169); }
			switch (alt169)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:392:4: ( ( LT )* '||' ( LT )* logicalORExpressionNoIn )
				{
				DebugLocation(392, 4);
				// JavaScript.g:392:4: ( ( LT )* '||' ( LT )* logicalORExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:392:5: ( LT )* '||' ( LT )* logicalORExpressionNoIn
				{
				DebugLocation(392, 5);
				// JavaScript.g:392:5: ( LT )*
				try { DebugEnterSubRule(167);
				while (true)
				{
					int alt167=2;
					try { DebugEnterDecision(167, false);
					int LA167_1 = input.LA(1);

					if ((LA167_1==LT))
					{
						alt167 = 1;
					}


					} finally { DebugExitDecision(167); }
					switch ( alt167 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:392:5: LT
						{
						DebugLocation(392, 5);
						LT315=(IToken)Match(input,LT,Follow._LT_in_logicalORExpressionNoIn3663); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT315);


						}
						break;

					default:
						goto loop167;
					}
				}

				loop167:
					;

				} finally { DebugExitSubRule(167); }

				DebugLocation(392, 9);
				string_literal316=(IToken)Match(input,113,Follow._113_in_logicalORExpressionNoIn3666); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_113.Add(string_literal316);

				DebugLocation(392, 14);
				// JavaScript.g:392:14: ( LT )*
				try { DebugEnterSubRule(168);
				while (true)
				{
					int alt168=2;
					try { DebugEnterDecision(168, false);
					int LA168_1 = input.LA(1);

					if ((LA168_1==LT))
					{
						alt168 = 1;
					}


					} finally { DebugExitDecision(168); }
					switch ( alt168 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:392:14: LT
						{
						DebugLocation(392, 14);
						LT317=(IToken)Match(input,LT,Follow._LT_in_logicalORExpressionNoIn3668); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT317);


						}
						break;

					default:
						goto loop168;
					}
				}

				loop168:
					;

				} finally { DebugExitSubRule(168); }

				DebugLocation(392, 18);
				PushFollow(Follow._logicalORExpressionNoIn_in_logicalORExpressionNoIn3671);
				logicalORExpressionNoIn318=logicalORExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalORExpressionNoIn.Add(logicalORExpressionNoIn318.Tree);

				}



				{
				// AST REWRITE
				// elements: 113, logicalANDExpressionNoIn, logicalORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 393:5: -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn )
				{
					DebugLocation(393, 8);
					// JavaScript.g:393:8: ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(393, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalOrExpression(stream_113.NextToken()), root_1);

					DebugLocation(393, 41);
					adaptor.AddChild(root_1, stream_logicalANDExpressionNoIn.NextTree());
					DebugLocation(393, 66);
					adaptor.AddChild(root_1, stream_logicalORExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:394:6: 
				{

				{
				// AST REWRITE
				// elements: logicalANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 394:6: -> logicalANDExpressionNoIn
				{
					DebugLocation(394, 9);
					adaptor.AddChild(root_0, stream_logicalANDExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(169); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpressionNoIn", 58);
			LeaveRule("logicalORExpressionNoIn", 58);
			LeaveRule_logicalORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 58, logicalORExpressionNoIn_StartIndex); }

		}
		DebugLocation(396, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalORExpressionNoIn"

	partial void EnterRule_logicalANDExpression();
	partial void LeaveRule_logicalANDExpression();
	// $ANTLR start "logicalANDExpression"
	// JavaScript.g:398:1: logicalANDExpression : bitwiseORExpression ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression ) ;
	[GrammarRule("logicalANDExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpression()
	{
		EnterRule_logicalANDExpression();
		EnterRule("logicalANDExpression", 59);
		TraceIn("logicalANDExpression", 59);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalANDExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT320 = default(IToken);
		IToken string_literal321 = default(IToken);
		IToken LT322 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpression319 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpression323 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT320_tree = default(CommonTree);
		CommonTree string_literal321_tree = default(CommonTree);
		CommonTree LT322_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_bitwiseORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpression");
		RewriteRuleSubtreeStream stream_logicalANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpression");
		try { DebugEnterRule(GrammarFileName, "logicalANDExpression");
		DebugLocation(398, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 59)) { return retval; }

			// JavaScript.g:399:2: ( bitwiseORExpression ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:400:3: bitwiseORExpression ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression )
			{
			DebugLocation(400, 3);
			PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression3719);
			bitwiseORExpression319=bitwiseORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseORExpression.Add(bitwiseORExpression319.Tree);
			DebugLocation(401, 3);
			// JavaScript.g:401:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression )
			int alt172=2;
			try { DebugEnterSubRule(172);
			try { DebugEnterDecision(172, false);
			try
			{
				alt172 = dfa172.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(172); }
			switch (alt172)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:402:4: ( ( LT )* '&&' ( LT )* logicalANDExpression )
				{
				DebugLocation(402, 4);
				// JavaScript.g:402:4: ( ( LT )* '&&' ( LT )* logicalANDExpression )
				DebugEnterAlt(1);
				// JavaScript.g:402:5: ( LT )* '&&' ( LT )* logicalANDExpression
				{
				DebugLocation(402, 5);
				// JavaScript.g:402:5: ( LT )*
				try { DebugEnterSubRule(170);
				while (true)
				{
					int alt170=2;
					try { DebugEnterDecision(170, false);
					int LA170_1 = input.LA(1);

					if ((LA170_1==LT))
					{
						alt170 = 1;
					}


					} finally { DebugExitDecision(170); }
					switch ( alt170 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:402:5: LT
						{
						DebugLocation(402, 5);
						LT320=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpression3730); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT320);


						}
						break;

					default:
						goto loop170;
					}
				}

				loop170:
					;

				} finally { DebugExitSubRule(170); }

				DebugLocation(402, 9);
				string_literal321=(IToken)Match(input,45,Follow._45_in_logicalANDExpression3733); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_45.Add(string_literal321);

				DebugLocation(402, 14);
				// JavaScript.g:402:14: ( LT )*
				try { DebugEnterSubRule(171);
				while (true)
				{
					int alt171=2;
					try { DebugEnterDecision(171, false);
					int LA171_1 = input.LA(1);

					if ((LA171_1==LT))
					{
						alt171 = 1;
					}


					} finally { DebugExitDecision(171); }
					switch ( alt171 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:402:14: LT
						{
						DebugLocation(402, 14);
						LT322=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpression3735); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT322);


						}
						break;

					default:
						goto loop171;
					}
				}

				loop171:
					;

				} finally { DebugExitSubRule(171); }

				DebugLocation(402, 18);
				PushFollow(Follow._logicalANDExpression_in_logicalANDExpression3738);
				logicalANDExpression323=logicalANDExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalANDExpression.Add(logicalANDExpression323.Tree);

				}



				{
				// AST REWRITE
				// elements: 45, bitwiseORExpression, logicalANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 403:5: -> ^( '&&' bitwiseORExpression logicalANDExpression )
				{
					DebugLocation(403, 8);
					// JavaScript.g:403:8: ^( '&&' bitwiseORExpression logicalANDExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(403, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalAndExpression(stream_45.NextToken()), root_1);

					DebugLocation(403, 42);
					adaptor.AddChild(root_1, stream_bitwiseORExpression.NextTree());
					DebugLocation(403, 62);
					adaptor.AddChild(root_1, stream_logicalANDExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:404:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 404:6: -> bitwiseORExpression
				{
					DebugLocation(404, 9);
					adaptor.AddChild(root_0, stream_bitwiseORExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(172); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpression", 59);
			LeaveRule("logicalANDExpression", 59);
			LeaveRule_logicalANDExpression();
			if (state.backtracking > 0) { Memoize(input, 59, logicalANDExpression_StartIndex); }

		}
		DebugLocation(406, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpression"

	partial void EnterRule_logicalANDExpressionNoIn();
	partial void LeaveRule_logicalANDExpressionNoIn();
	// $ANTLR start "logicalANDExpressionNoIn"
	// JavaScript.g:408:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn ) ;
	[GrammarRule("logicalANDExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpressionNoIn()
	{
		EnterRule_logicalANDExpressionNoIn();
		EnterRule("logicalANDExpressionNoIn", 60);
		TraceIn("logicalANDExpressionNoIn", 60);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalANDExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT325 = default(IToken);
		IToken string_literal326 = default(IToken);
		IToken LT327 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpressionNoIn324 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpressionNoIn328 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT325_tree = default(CommonTree);
		CommonTree string_literal326_tree = default(CommonTree);
		CommonTree LT327_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_bitwiseORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpressionNoIn");
		RewriteRuleSubtreeStream stream_logicalANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
		DebugLocation(408, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 60)) { return retval; }

			// JavaScript.g:409:2: ( bitwiseORExpressionNoIn ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:410:3: bitwiseORExpressionNoIn ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn )
			{
			DebugLocation(410, 3);
			PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn3786);
			bitwiseORExpressionNoIn324=bitwiseORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseORExpressionNoIn.Add(bitwiseORExpressionNoIn324.Tree);
			DebugLocation(411, 3);
			// JavaScript.g:411:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn )
			int alt175=2;
			try { DebugEnterSubRule(175);
			try { DebugEnterDecision(175, false);
			try
			{
				alt175 = dfa175.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(175); }
			switch (alt175)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:412:4: ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn )
				{
				DebugLocation(412, 4);
				// JavaScript.g:412:4: ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:412:5: ( LT )* '&&' ( LT )* logicalANDExpressionNoIn
				{
				DebugLocation(412, 5);
				// JavaScript.g:412:5: ( LT )*
				try { DebugEnterSubRule(173);
				while (true)
				{
					int alt173=2;
					try { DebugEnterDecision(173, false);
					int LA173_1 = input.LA(1);

					if ((LA173_1==LT))
					{
						alt173 = 1;
					}


					} finally { DebugExitDecision(173); }
					switch ( alt173 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:412:5: LT
						{
						DebugLocation(412, 5);
						LT325=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpressionNoIn3796); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT325);


						}
						break;

					default:
						goto loop173;
					}
				}

				loop173:
					;

				} finally { DebugExitSubRule(173); }

				DebugLocation(412, 9);
				string_literal326=(IToken)Match(input,45,Follow._45_in_logicalANDExpressionNoIn3799); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_45.Add(string_literal326);

				DebugLocation(412, 14);
				// JavaScript.g:412:14: ( LT )*
				try { DebugEnterSubRule(174);
				while (true)
				{
					int alt174=2;
					try { DebugEnterDecision(174, false);
					int LA174_1 = input.LA(1);

					if ((LA174_1==LT))
					{
						alt174 = 1;
					}


					} finally { DebugExitDecision(174); }
					switch ( alt174 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:412:14: LT
						{
						DebugLocation(412, 14);
						LT327=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpressionNoIn3801); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT327);


						}
						break;

					default:
						goto loop174;
					}
				}

				loop174:
					;

				} finally { DebugExitSubRule(174); }

				DebugLocation(412, 18);
				PushFollow(Follow._logicalANDExpressionNoIn_in_logicalANDExpressionNoIn3804);
				logicalANDExpressionNoIn328=logicalANDExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalANDExpressionNoIn.Add(logicalANDExpressionNoIn328.Tree);

				}



				{
				// AST REWRITE
				// elements: 45, bitwiseORExpressionNoIn, logicalANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 413:5: -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn )
				{
					DebugLocation(413, 8);
					// JavaScript.g:413:8: ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(413, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalAndExpression(stream_45.NextToken()), root_1);

					DebugLocation(413, 42);
					adaptor.AddChild(root_1, stream_bitwiseORExpressionNoIn.NextTree());
					DebugLocation(413, 66);
					adaptor.AddChild(root_1, stream_logicalANDExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:414:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 414:6: -> bitwiseORExpressionNoIn
				{
					DebugLocation(414, 9);
					adaptor.AddChild(root_0, stream_bitwiseORExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(175); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpressionNoIn", 60);
			LeaveRule("logicalANDExpressionNoIn", 60);
			LeaveRule_logicalANDExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 60, logicalANDExpressionNoIn_StartIndex); }

		}
		DebugLocation(416, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpressionNoIn"

	partial void EnterRule_bitwiseORExpression();
	partial void LeaveRule_bitwiseORExpression();
	// $ANTLR start "bitwiseORExpression"
	// JavaScript.g:418:1: bitwiseORExpression : bitwiseXORExpression ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression ) ;
	[GrammarRule("bitwiseORExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpression()
	{
		EnterRule_bitwiseORExpression();
		EnterRule("bitwiseORExpression", 61);
		TraceIn("bitwiseORExpression", 61);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseORExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT330 = default(IToken);
		IToken char_literal331 = default(IToken);
		IToken LT332 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpression329 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpression333 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT330_tree = default(CommonTree);
		CommonTree char_literal331_tree = default(CommonTree);
		CommonTree LT332_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_111=new RewriteRuleITokenStream(adaptor,"token 111");
		RewriteRuleSubtreeStream stream_bitwiseXORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpression");
		RewriteRuleSubtreeStream stream_bitwiseORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpression");
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpression");
		DebugLocation(418, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 61)) { return retval; }

			// JavaScript.g:419:2: ( bitwiseXORExpression ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:420:3: bitwiseXORExpression ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression )
			{
			DebugLocation(420, 3);
			PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression3852);
			bitwiseXORExpression329=bitwiseXORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseXORExpression.Add(bitwiseXORExpression329.Tree);
			DebugLocation(421, 3);
			// JavaScript.g:421:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression )
			int alt178=2;
			try { DebugEnterSubRule(178);
			try { DebugEnterDecision(178, false);
			try
			{
				alt178 = dfa178.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(178); }
			switch (alt178)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:422:4: ( ( LT )* '|' ( LT )* bitwiseORExpression )
				{
				DebugLocation(422, 4);
				// JavaScript.g:422:4: ( ( LT )* '|' ( LT )* bitwiseORExpression )
				DebugEnterAlt(1);
				// JavaScript.g:422:5: ( LT )* '|' ( LT )* bitwiseORExpression
				{
				DebugLocation(422, 5);
				// JavaScript.g:422:5: ( LT )*
				try { DebugEnterSubRule(176);
				while (true)
				{
					int alt176=2;
					try { DebugEnterDecision(176, false);
					int LA176_1 = input.LA(1);

					if ((LA176_1==LT))
					{
						alt176 = 1;
					}


					} finally { DebugExitDecision(176); }
					switch ( alt176 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:422:5: LT
						{
						DebugLocation(422, 5);
						LT330=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpression3862); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT330);


						}
						break;

					default:
						goto loop176;
					}
				}

				loop176:
					;

				} finally { DebugExitSubRule(176); }

				DebugLocation(422, 9);
				char_literal331=(IToken)Match(input,111,Follow._111_in_bitwiseORExpression3865); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_111.Add(char_literal331);

				DebugLocation(422, 13);
				// JavaScript.g:422:13: ( LT )*
				try { DebugEnterSubRule(177);
				while (true)
				{
					int alt177=2;
					try { DebugEnterDecision(177, false);
					int LA177_1 = input.LA(1);

					if ((LA177_1==LT))
					{
						alt177 = 1;
					}


					} finally { DebugExitDecision(177); }
					switch ( alt177 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:422:13: LT
						{
						DebugLocation(422, 13);
						LT332=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpression3867); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT332);


						}
						break;

					default:
						goto loop177;
					}
				}

				loop177:
					;

				} finally { DebugExitSubRule(177); }

				DebugLocation(422, 17);
				PushFollow(Follow._bitwiseORExpression_in_bitwiseORExpression3870);
				bitwiseORExpression333=bitwiseORExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseORExpression.Add(bitwiseORExpression333.Tree);

				}



				{
				// AST REWRITE
				// elements: 111, bitwiseXORExpression, bitwiseORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 423:5: -> ^( '|' bitwiseXORExpression bitwiseORExpression )
				{
					DebugLocation(423, 8);
					// JavaScript.g:423:8: ^( '|' bitwiseXORExpression bitwiseORExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(423, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrExpression(stream_111.NextToken()), root_1);

					DebugLocation(423, 40);
					adaptor.AddChild(root_1, stream_bitwiseXORExpression.NextTree());
					DebugLocation(423, 61);
					adaptor.AddChild(root_1, stream_bitwiseORExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:424:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseXORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 424:6: -> bitwiseXORExpression
				{
					DebugLocation(424, 9);
					adaptor.AddChild(root_0, stream_bitwiseXORExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(178); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpression", 61);
			LeaveRule("bitwiseORExpression", 61);
			LeaveRule_bitwiseORExpression();
			if (state.backtracking > 0) { Memoize(input, 61, bitwiseORExpression_StartIndex); }

		}
		DebugLocation(426, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpression"

	partial void EnterRule_bitwiseORExpressionNoIn();
	partial void LeaveRule_bitwiseORExpressionNoIn();
	// $ANTLR start "bitwiseORExpressionNoIn"
	// JavaScript.g:428:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn ) ;
	[GrammarRule("bitwiseORExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpressionNoIn()
	{
		EnterRule_bitwiseORExpressionNoIn();
		EnterRule("bitwiseORExpressionNoIn", 62);
		TraceIn("bitwiseORExpressionNoIn", 62);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseORExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT335 = default(IToken);
		IToken char_literal336 = default(IToken);
		IToken LT337 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpressionNoIn334 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpressionNoIn338 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT335_tree = default(CommonTree);
		CommonTree char_literal336_tree = default(CommonTree);
		CommonTree LT337_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_111=new RewriteRuleITokenStream(adaptor,"token 111");
		RewriteRuleSubtreeStream stream_bitwiseXORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpressionNoIn");
		RewriteRuleSubtreeStream stream_bitwiseORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
		DebugLocation(428, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 62)) { return retval; }

			// JavaScript.g:429:2: ( bitwiseXORExpressionNoIn ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:430:3: bitwiseXORExpressionNoIn ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn )
			{
			DebugLocation(430, 3);
			PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3918);
			bitwiseXORExpressionNoIn334=bitwiseXORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseXORExpressionNoIn.Add(bitwiseXORExpressionNoIn334.Tree);
			DebugLocation(431, 3);
			// JavaScript.g:431:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn )
			int alt181=2;
			try { DebugEnterSubRule(181);
			try { DebugEnterDecision(181, false);
			try
			{
				alt181 = dfa181.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(181); }
			switch (alt181)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:432:4: ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn )
				{
				DebugLocation(432, 4);
				// JavaScript.g:432:4: ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:432:5: ( LT )* '|' ( LT )* bitwiseORExpressionNoIn
				{
				DebugLocation(432, 5);
				// JavaScript.g:432:5: ( LT )*
				try { DebugEnterSubRule(179);
				while (true)
				{
					int alt179=2;
					try { DebugEnterDecision(179, false);
					int LA179_1 = input.LA(1);

					if ((LA179_1==LT))
					{
						alt179 = 1;
					}


					} finally { DebugExitDecision(179); }
					switch ( alt179 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:432:5: LT
						{
						DebugLocation(432, 5);
						LT335=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpressionNoIn3928); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT335);


						}
						break;

					default:
						goto loop179;
					}
				}

				loop179:
					;

				} finally { DebugExitSubRule(179); }

				DebugLocation(432, 9);
				char_literal336=(IToken)Match(input,111,Follow._111_in_bitwiseORExpressionNoIn3931); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_111.Add(char_literal336);

				DebugLocation(432, 13);
				// JavaScript.g:432:13: ( LT )*
				try { DebugEnterSubRule(180);
				while (true)
				{
					int alt180=2;
					try { DebugEnterDecision(180, false);
					int LA180_1 = input.LA(1);

					if ((LA180_1==LT))
					{
						alt180 = 1;
					}


					} finally { DebugExitDecision(180); }
					switch ( alt180 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:432:13: LT
						{
						DebugLocation(432, 13);
						LT337=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpressionNoIn3933); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT337);


						}
						break;

					default:
						goto loop180;
					}
				}

				loop180:
					;

				} finally { DebugExitSubRule(180); }

				DebugLocation(432, 17);
				PushFollow(Follow._bitwiseORExpressionNoIn_in_bitwiseORExpressionNoIn3936);
				bitwiseORExpressionNoIn338=bitwiseORExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseORExpressionNoIn.Add(bitwiseORExpressionNoIn338.Tree);

				}



				{
				// AST REWRITE
				// elements: 111, bitwiseXORExpressionNoIn, bitwiseORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 433:5: -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn )
				{
					DebugLocation(433, 8);
					// JavaScript.g:433:8: ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(433, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrExpression(stream_111.NextToken()), root_1);

					DebugLocation(433, 40);
					adaptor.AddChild(root_1, stream_bitwiseXORExpressionNoIn.NextTree());
					DebugLocation(433, 65);
					adaptor.AddChild(root_1, stream_bitwiseORExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:434:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseXORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 434:6: -> bitwiseXORExpressionNoIn
				{
					DebugLocation(434, 9);
					adaptor.AddChild(root_0, stream_bitwiseXORExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(181); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpressionNoIn", 62);
			LeaveRule("bitwiseORExpressionNoIn", 62);
			LeaveRule_bitwiseORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 62, bitwiseORExpressionNoIn_StartIndex); }

		}
		DebugLocation(436, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpressionNoIn"

	partial void EnterRule_bitwiseXORExpression();
	partial void LeaveRule_bitwiseXORExpression();
	// $ANTLR start "bitwiseXORExpression"
	// JavaScript.g:438:1: bitwiseXORExpression : bitwiseANDExpression ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression ) ;
	[GrammarRule("bitwiseXORExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpression()
	{
		EnterRule_bitwiseXORExpression();
		EnterRule("bitwiseXORExpression", 63);
		TraceIn("bitwiseXORExpression", 63);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseXORExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT340 = default(IToken);
		IToken char_literal341 = default(IToken);
		IToken LT342 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpression339 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpression343 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT340_tree = default(CommonTree);
		CommonTree char_literal341_tree = default(CommonTree);
		CommonTree LT342_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleSubtreeStream stream_bitwiseANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpression");
		RewriteRuleSubtreeStream stream_bitwiseXORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpression");
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
		DebugLocation(438, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 63)) { return retval; }

			// JavaScript.g:439:2: ( bitwiseANDExpression ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:440:3: bitwiseANDExpression ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression )
			{
			DebugLocation(440, 3);
			PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression3984);
			bitwiseANDExpression339=bitwiseANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseANDExpression.Add(bitwiseANDExpression339.Tree);
			DebugLocation(441, 3);
			// JavaScript.g:441:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression )
			int alt184=2;
			try { DebugEnterSubRule(184);
			try { DebugEnterDecision(184, false);
			try
			{
				alt184 = dfa184.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(184); }
			switch (alt184)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:442:4: ( ( LT )* '^' ( LT )* bitwiseXORExpression )
				{
				DebugLocation(442, 4);
				// JavaScript.g:442:4: ( ( LT )* '^' ( LT )* bitwiseXORExpression )
				DebugEnterAlt(1);
				// JavaScript.g:442:5: ( LT )* '^' ( LT )* bitwiseXORExpression
				{
				DebugLocation(442, 5);
				// JavaScript.g:442:5: ( LT )*
				try { DebugEnterSubRule(182);
				while (true)
				{
					int alt182=2;
					try { DebugEnterDecision(182, false);
					int LA182_1 = input.LA(1);

					if ((LA182_1==LT))
					{
						alt182 = 1;
					}


					} finally { DebugExitDecision(182); }
					switch ( alt182 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:442:5: LT
						{
						DebugLocation(442, 5);
						LT340=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpression3995); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT340);


						}
						break;

					default:
						goto loop182;
					}
				}

				loop182:
					;

				} finally { DebugExitSubRule(182); }

				DebugLocation(442, 9);
				char_literal341=(IToken)Match(input,80,Follow._80_in_bitwiseXORExpression3998); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_80.Add(char_literal341);

				DebugLocation(442, 13);
				// JavaScript.g:442:13: ( LT )*
				try { DebugEnterSubRule(183);
				while (true)
				{
					int alt183=2;
					try { DebugEnterDecision(183, false);
					int LA183_1 = input.LA(1);

					if ((LA183_1==LT))
					{
						alt183 = 1;
					}


					} finally { DebugExitDecision(183); }
					switch ( alt183 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:442:13: LT
						{
						DebugLocation(442, 13);
						LT342=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpression4000); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT342);


						}
						break;

					default:
						goto loop183;
					}
				}

				loop183:
					;

				} finally { DebugExitSubRule(183); }

				DebugLocation(442, 17);
				PushFollow(Follow._bitwiseXORExpression_in_bitwiseXORExpression4003);
				bitwiseXORExpression343=bitwiseXORExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseXORExpression.Add(bitwiseXORExpression343.Tree);

				}



				{
				// AST REWRITE
				// elements: 80, bitwiseANDExpression, bitwiseXORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 443:5: -> ^( '^' bitwiseANDExpression bitwiseXORExpression )
				{
					DebugLocation(443, 8);
					// JavaScript.g:443:8: ^( '^' bitwiseANDExpression bitwiseXORExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(443, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorExpression(stream_80.NextToken()), root_1);

					DebugLocation(443, 41);
					adaptor.AddChild(root_1, stream_bitwiseANDExpression.NextTree());
					DebugLocation(443, 62);
					adaptor.AddChild(root_1, stream_bitwiseXORExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:444:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 444:6: -> bitwiseANDExpression
				{
					DebugLocation(444, 9);
					adaptor.AddChild(root_0, stream_bitwiseANDExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(184); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpression", 63);
			LeaveRule("bitwiseXORExpression", 63);
			LeaveRule_bitwiseXORExpression();
			if (state.backtracking > 0) { Memoize(input, 63, bitwiseXORExpression_StartIndex); }

		}
		DebugLocation(446, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpression"

	partial void EnterRule_bitwiseXORExpressionNoIn();
	partial void LeaveRule_bitwiseXORExpressionNoIn();
	// $ANTLR start "bitwiseXORExpressionNoIn"
	// JavaScript.g:448:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn ) ;
	[GrammarRule("bitwiseXORExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpressionNoIn()
	{
		EnterRule_bitwiseXORExpressionNoIn();
		EnterRule("bitwiseXORExpressionNoIn", 64);
		TraceIn("bitwiseXORExpressionNoIn", 64);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseXORExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT345 = default(IToken);
		IToken char_literal346 = default(IToken);
		IToken LT347 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpressionNoIn344 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpressionNoIn348 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT345_tree = default(CommonTree);
		CommonTree char_literal346_tree = default(CommonTree);
		CommonTree LT347_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleSubtreeStream stream_bitwiseANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpressionNoIn");
		RewriteRuleSubtreeStream stream_bitwiseXORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
		DebugLocation(448, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 64)) { return retval; }

			// JavaScript.g:449:2: ( bitwiseANDExpressionNoIn ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:450:3: bitwiseANDExpressionNoIn ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn )
			{
			DebugLocation(450, 3);
			PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4051);
			bitwiseANDExpressionNoIn344=bitwiseANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseANDExpressionNoIn.Add(bitwiseANDExpressionNoIn344.Tree);
			DebugLocation(451, 3);
			// JavaScript.g:451:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn )
			int alt187=2;
			try { DebugEnterSubRule(187);
			try { DebugEnterDecision(187, false);
			try
			{
				alt187 = dfa187.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(187); }
			switch (alt187)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:452:4: ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn )
				{
				DebugLocation(452, 4);
				// JavaScript.g:452:4: ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:452:5: ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn
				{
				DebugLocation(452, 5);
				// JavaScript.g:452:5: ( LT )*
				try { DebugEnterSubRule(185);
				while (true)
				{
					int alt185=2;
					try { DebugEnterDecision(185, false);
					int LA185_1 = input.LA(1);

					if ((LA185_1==LT))
					{
						alt185 = 1;
					}


					} finally { DebugExitDecision(185); }
					switch ( alt185 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:452:5: LT
						{
						DebugLocation(452, 5);
						LT345=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpressionNoIn4061); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT345);


						}
						break;

					default:
						goto loop185;
					}
				}

				loop185:
					;

				} finally { DebugExitSubRule(185); }

				DebugLocation(452, 9);
				char_literal346=(IToken)Match(input,80,Follow._80_in_bitwiseXORExpressionNoIn4064); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_80.Add(char_literal346);

				DebugLocation(452, 13);
				// JavaScript.g:452:13: ( LT )*
				try { DebugEnterSubRule(186);
				while (true)
				{
					int alt186=2;
					try { DebugEnterDecision(186, false);
					int LA186_1 = input.LA(1);

					if ((LA186_1==LT))
					{
						alt186 = 1;
					}


					} finally { DebugExitDecision(186); }
					switch ( alt186 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:452:13: LT
						{
						DebugLocation(452, 13);
						LT347=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpressionNoIn4066); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT347);


						}
						break;

					default:
						goto loop186;
					}
				}

				loop186:
					;

				} finally { DebugExitSubRule(186); }

				DebugLocation(452, 17);
				PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseXORExpressionNoIn4069);
				bitwiseXORExpressionNoIn348=bitwiseXORExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseXORExpressionNoIn.Add(bitwiseXORExpressionNoIn348.Tree);

				}



				{
				// AST REWRITE
				// elements: 80, bitwiseANDExpressionNoIn, bitwiseXORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 453:5: -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn )
				{
					DebugLocation(453, 8);
					// JavaScript.g:453:8: ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(453, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorExpression(stream_80.NextToken()), root_1);

					DebugLocation(453, 41);
					adaptor.AddChild(root_1, stream_bitwiseANDExpressionNoIn.NextTree());
					DebugLocation(453, 66);
					adaptor.AddChild(root_1, stream_bitwiseXORExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:454:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 454:6: -> bitwiseANDExpressionNoIn
				{
					DebugLocation(454, 9);
					adaptor.AddChild(root_0, stream_bitwiseANDExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(187); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpressionNoIn", 64);
			LeaveRule("bitwiseXORExpressionNoIn", 64);
			LeaveRule_bitwiseXORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 64, bitwiseXORExpressionNoIn_StartIndex); }

		}
		DebugLocation(456, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpressionNoIn"

	partial void EnterRule_bitwiseANDExpression();
	partial void LeaveRule_bitwiseANDExpression();
	// $ANTLR start "bitwiseANDExpression"
	// JavaScript.g:458:1: bitwiseANDExpression : equalityExpression ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression ) ;
	[GrammarRule("bitwiseANDExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpression()
	{
		EnterRule_bitwiseANDExpression();
		EnterRule("bitwiseANDExpression", 65);
		TraceIn("bitwiseANDExpression", 65);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseANDExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT350 = default(IToken);
		IToken char_literal351 = default(IToken);
		IToken LT352 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpression349 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpression353 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT350_tree = default(CommonTree);
		CommonTree char_literal351_tree = default(CommonTree);
		CommonTree LT352_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpression");
		RewriteRuleSubtreeStream stream_bitwiseANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpression");
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
		DebugLocation(458, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 65)) { return retval; }

			// JavaScript.g:459:2: ( equalityExpression ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:460:3: equalityExpression ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression )
			{
			DebugLocation(460, 3);
			PushFollow(Follow._equalityExpression_in_bitwiseANDExpression4117);
			equalityExpression349=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_equalityExpression.Add(equalityExpression349.Tree);
			DebugLocation(461, 3);
			// JavaScript.g:461:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression )
			int alt190=2;
			try { DebugEnterSubRule(190);
			try { DebugEnterDecision(190, false);
			try
			{
				alt190 = dfa190.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(190); }
			switch (alt190)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:462:4: ( ( LT )* '&' ( LT )* bitwiseANDExpression )
				{
				DebugLocation(462, 4);
				// JavaScript.g:462:4: ( ( LT )* '&' ( LT )* bitwiseANDExpression )
				DebugEnterAlt(1);
				// JavaScript.g:462:5: ( LT )* '&' ( LT )* bitwiseANDExpression
				{
				DebugLocation(462, 5);
				// JavaScript.g:462:5: ( LT )*
				try { DebugEnterSubRule(188);
				while (true)
				{
					int alt188=2;
					try { DebugEnterDecision(188, false);
					int LA188_1 = input.LA(1);

					if ((LA188_1==LT))
					{
						alt188 = 1;
					}


					} finally { DebugExitDecision(188); }
					switch ( alt188 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:462:5: LT
						{
						DebugLocation(462, 5);
						LT350=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpression4128); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT350);


						}
						break;

					default:
						goto loop188;
					}
				}

				loop188:
					;

				} finally { DebugExitSubRule(188); }

				DebugLocation(462, 9);
				char_literal351=(IToken)Match(input,46,Follow._46_in_bitwiseANDExpression4131); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_46.Add(char_literal351);

				DebugLocation(462, 13);
				// JavaScript.g:462:13: ( LT )*
				try { DebugEnterSubRule(189);
				while (true)
				{
					int alt189=2;
					try { DebugEnterDecision(189, false);
					int LA189_1 = input.LA(1);

					if ((LA189_1==LT))
					{
						alt189 = 1;
					}


					} finally { DebugExitDecision(189); }
					switch ( alt189 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:462:13: LT
						{
						DebugLocation(462, 13);
						LT352=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpression4133); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT352);


						}
						break;

					default:
						goto loop189;
					}
				}

				loop189:
					;

				} finally { DebugExitSubRule(189); }

				DebugLocation(462, 17);
				PushFollow(Follow._bitwiseANDExpression_in_bitwiseANDExpression4136);
				bitwiseANDExpression353=bitwiseANDExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseANDExpression.Add(bitwiseANDExpression353.Tree);

				}



				{
				// AST REWRITE
				// elements: 46, equalityExpression, bitwiseANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 463:5: -> ^( '&' equalityExpression bitwiseANDExpression )
				{
					DebugLocation(463, 8);
					// JavaScript.g:463:8: ^( '&' equalityExpression bitwiseANDExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(463, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndExpression(stream_46.NextToken()), root_1);

					DebugLocation(463, 41);
					adaptor.AddChild(root_1, stream_equalityExpression.NextTree());
					DebugLocation(463, 60);
					adaptor.AddChild(root_1, stream_bitwiseANDExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:464:6: 
				{

				{
				// AST REWRITE
				// elements: equalityExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 464:6: -> equalityExpression
				{
					DebugLocation(464, 9);
					adaptor.AddChild(root_0, stream_equalityExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(190); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpression", 65);
			LeaveRule("bitwiseANDExpression", 65);
			LeaveRule_bitwiseANDExpression();
			if (state.backtracking > 0) { Memoize(input, 65, bitwiseANDExpression_StartIndex); }

		}
		DebugLocation(466, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpression"

	partial void EnterRule_bitwiseANDExpressionNoIn();
	partial void LeaveRule_bitwiseANDExpressionNoIn();
	// $ANTLR start "bitwiseANDExpressionNoIn"
	// JavaScript.g:468:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn ) ;
	[GrammarRule("bitwiseANDExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpressionNoIn()
	{
		EnterRule_bitwiseANDExpressionNoIn();
		EnterRule("bitwiseANDExpressionNoIn", 66);
		TraceIn("bitwiseANDExpressionNoIn", 66);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseANDExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT355 = default(IToken);
		IToken char_literal356 = default(IToken);
		IToken LT357 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpressionNoIn354 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpressionNoIn358 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT355_tree = default(CommonTree);
		CommonTree char_literal356_tree = default(CommonTree);
		CommonTree LT357_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_equalityExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpressionNoIn");
		RewriteRuleSubtreeStream stream_bitwiseANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
		DebugLocation(468, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 66)) { return retval; }

			// JavaScript.g:469:2: ( equalityExpressionNoIn ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:470:3: equalityExpressionNoIn ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn )
			{
			DebugLocation(470, 3);
			PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn4184);
			equalityExpressionNoIn354=equalityExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_equalityExpressionNoIn.Add(equalityExpressionNoIn354.Tree);
			DebugLocation(471, 3);
			// JavaScript.g:471:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn )
			int alt193=2;
			try { DebugEnterSubRule(193);
			try { DebugEnterDecision(193, false);
			try
			{
				alt193 = dfa193.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(193); }
			switch (alt193)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:472:4: ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn )
				{
				DebugLocation(472, 4);
				// JavaScript.g:472:4: ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:472:5: ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn
				{
				DebugLocation(472, 5);
				// JavaScript.g:472:5: ( LT )*
				try { DebugEnterSubRule(191);
				while (true)
				{
					int alt191=2;
					try { DebugEnterDecision(191, false);
					int LA191_1 = input.LA(1);

					if ((LA191_1==LT))
					{
						alt191 = 1;
					}


					} finally { DebugExitDecision(191); }
					switch ( alt191 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:472:5: LT
						{
						DebugLocation(472, 5);
						LT355=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpressionNoIn4194); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT355);


						}
						break;

					default:
						goto loop191;
					}
				}

				loop191:
					;

				} finally { DebugExitSubRule(191); }

				DebugLocation(472, 9);
				char_literal356=(IToken)Match(input,46,Follow._46_in_bitwiseANDExpressionNoIn4197); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_46.Add(char_literal356);

				DebugLocation(472, 13);
				// JavaScript.g:472:13: ( LT )*
				try { DebugEnterSubRule(192);
				while (true)
				{
					int alt192=2;
					try { DebugEnterDecision(192, false);
					int LA192_1 = input.LA(1);

					if ((LA192_1==LT))
					{
						alt192 = 1;
					}


					} finally { DebugExitDecision(192); }
					switch ( alt192 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:472:13: LT
						{
						DebugLocation(472, 13);
						LT357=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpressionNoIn4199); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT357);


						}
						break;

					default:
						goto loop192;
					}
				}

				loop192:
					;

				} finally { DebugExitSubRule(192); }

				DebugLocation(472, 17);
				PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseANDExpressionNoIn4202);
				bitwiseANDExpressionNoIn358=bitwiseANDExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseANDExpressionNoIn.Add(bitwiseANDExpressionNoIn358.Tree);

				}



				{
				// AST REWRITE
				// elements: 46, equalityExpressionNoIn, bitwiseANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 473:5: -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn )
				{
					DebugLocation(473, 8);
					// JavaScript.g:473:8: ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(473, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndExpression(stream_46.NextToken()), root_1);

					DebugLocation(473, 41);
					adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());
					DebugLocation(473, 64);
					adaptor.AddChild(root_1, stream_bitwiseANDExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:474:6: 
				{

				{
				// AST REWRITE
				// elements: equalityExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 474:6: -> equalityExpressionNoIn
				{
					DebugLocation(474, 9);
					adaptor.AddChild(root_0, stream_equalityExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(193); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpressionNoIn", 66);
			LeaveRule("bitwiseANDExpressionNoIn", 66);
			LeaveRule_bitwiseANDExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 66, bitwiseANDExpressionNoIn_StartIndex); }

		}
		DebugLocation(476, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpressionNoIn"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// JavaScript.g:478:1: equalityExpression : rel= relationalExpression ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression ) ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 67);
		TraceIn("equalityExpression", 67);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int equalityExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT359 = default(IToken);
		IToken LT360 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> rel = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> eq = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT359_tree = default(CommonTree);
		CommonTree LT360_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_relationalExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpression");
		RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpression");
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(478, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 67)) { return retval; }

			// JavaScript.g:479:2: (rel= relationalExpression ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:480:3: rel= relationalExpression ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression )
			{
			DebugLocation(480, 6);
			PushFollow(Follow._relationalExpression_in_equalityExpression4251);
			rel=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalExpression.Add(rel.Tree);
			DebugLocation(481, 3);
			// JavaScript.g:481:3: ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression )
			int alt197=2;
			try { DebugEnterSubRule(197);
			try { DebugEnterDecision(197, false);
			try
			{
				alt197 = dfa197.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(197); }
			switch (alt197)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:482:4: ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression )
				{
				DebugLocation(482, 4);
				// JavaScript.g:482:4: ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression )
				DebugEnterAlt(1);
				// JavaScript.g:482:5: ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression
				{
				DebugLocation(482, 5);
				// JavaScript.g:482:5: ( LT )*
				try { DebugEnterSubRule(194);
				while (true)
				{
					int alt194=2;
					try { DebugEnterDecision(194, false);
					int LA194_1 = input.LA(1);

					if ((LA194_1==LT))
					{
						alt194 = 1;
					}


					} finally { DebugExitDecision(194); }
					switch ( alt194 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:482:5: LT
						{
						DebugLocation(482, 5);
						LT359=(IToken)Match(input,LT,Follow._LT_in_equalityExpression4262); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT359);


						}
						break;

					default:
						goto loop194;
					}
				}

				loop194:
					;

				} finally { DebugExitSubRule(194); }

				DebugLocation(482, 9);
				// JavaScript.g:482:9: (op= '==' |op= '!=' |op= '===' |op= '!==' )
				int alt195=4;
				try { DebugEnterSubRule(195);
				try { DebugEnterDecision(195, false);
				switch (input.LA(1))
				{
				case 69:
					{
					alt195 = 1;
					}
					break;
				case 41:
					{
					alt195 = 2;
					}
					break;
				case 70:
					{
					alt195 = 3;
					}
					break;
				case 42:
					{
					alt195 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 195, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(195); }
				switch (alt195)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:482:10: op= '=='
					{
					DebugLocation(482, 12);
					op=(IToken)Match(input,69,Follow._69_in_equalityExpression4268); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_69.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:482:20: op= '!='
					{
					DebugLocation(482, 22);
					op=(IToken)Match(input,41,Follow._41_in_equalityExpression4274); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_41.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:482:30: op= '==='
					{
					DebugLocation(482, 32);
					op=(IToken)Match(input,70,Follow._70_in_equalityExpression4280); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_70.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:482:41: op= '!=='
					{
					DebugLocation(482, 43);
					op=(IToken)Match(input,42,Follow._42_in_equalityExpression4286); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(195); }

				DebugLocation(482, 51);
				// JavaScript.g:482:51: ( LT )*
				try { DebugEnterSubRule(196);
				while (true)
				{
					int alt196=2;
					try { DebugEnterDecision(196, false);
					int LA196_1 = input.LA(1);

					if ((LA196_1==LT))
					{
						alt196 = 1;
					}


					} finally { DebugExitDecision(196); }
					switch ( alt196 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:482:51: LT
						{
						DebugLocation(482, 51);
						LT360=(IToken)Match(input,LT,Follow._LT_in_equalityExpression4289); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT360);


						}
						break;

					default:
						goto loop196;
					}
				}

				loop196:
					;

				} finally { DebugExitSubRule(196); }

				DebugLocation(482, 57);
				PushFollow(Follow._equalityExpression_in_equalityExpression4294);
				eq=equalityExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_equalityExpression.Add(eq.Tree);

				}



				{
				// AST REWRITE
				// elements: 69, rel, eq, 41, rel, eq, 70, rel, eq, 42, rel, eq
				// token labels: 
				// rule labels: rel, eq, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_rel=new RewriteRuleSubtreeStream(adaptor,"rule rel",rel!=null?rel.Tree:null);
				RewriteRuleSubtreeStream stream_eq=new RewriteRuleSubtreeStream(adaptor,"rule eq",eq!=null?eq.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 483:17: -> { op.Text == \"==\" }? ^( '==' $rel $eq)
				if ( op.Text == "=="  )
				{
					DebugLocation(483, 42);
					// JavaScript.g:483:42: ^( '==' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(483, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new EqualToExpression(stream_69.NextToken()), root_1);

					DebugLocation(483, 74);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(483, 79);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 484:17: -> { op.Text == \"!=\" }? ^( '!=' $rel $eq)
				if ( op.Text == "!="  )
				{
					DebugLocation(484, 42);
					// JavaScript.g:484:42: ^( '!=' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(484, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NotEqualToExpression(stream_41.NextToken()), root_1);

					DebugLocation(484, 77);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(484, 82);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 485:17: -> { op.Text == \"===\" }? ^( '===' $rel $eq)
				if ( op.Text == "===" )
				{
					DebugLocation(485, 42);
					// JavaScript.g:485:42: ^( '===' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(485, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new StrictlyEqualToExpression(stream_70.NextToken()), root_1);

					DebugLocation(485, 83);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(485, 88);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 486:17: -> { op.Text == \"!==\" }? ^( '!==' $rel $eq)
				if ( op.Text == "!==" )
				{
					DebugLocation(486, 42);
					// JavaScript.g:486:42: ^( '!==' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(486, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NotStrictlyEqualToExpression(stream_42.NextToken()), root_1);

					DebugLocation(486, 86);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(486, 91);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 487:8: ->
				{
					DebugLocation(488, 13);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:488:17: 
				{

				{
				// AST REWRITE
				// elements: relationalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 488:17: -> relationalExpression
				{
					DebugLocation(488, 20);
					adaptor.AddChild(root_0, stream_relationalExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(197); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 67);
			LeaveRule("equalityExpression", 67);
			LeaveRule_equalityExpression();
			if (state.backtracking > 0) { Memoize(input, 67, equalityExpression_StartIndex); }

		}
		DebugLocation(490, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityExpressionNoIn();
	partial void LeaveRule_equalityExpressionNoIn();
	// $ANTLR start "equalityExpressionNoIn"
	// JavaScript.g:492:1: equalityExpressionNoIn : relationalExpressionNoIn ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn ) ;
	[GrammarRule("equalityExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityExpressionNoIn()
	{
		EnterRule_equalityExpressionNoIn();
		EnterRule("equalityExpressionNoIn", 68);
		TraceIn("equalityExpressionNoIn", 68);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int equalityExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT362 = default(IToken);
		IToken string_literal363 = default(IToken);
		IToken string_literal364 = default(IToken);
		IToken string_literal365 = default(IToken);
		IToken string_literal366 = default(IToken);
		IToken LT367 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpressionNoIn361 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpressionNoIn368 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT362_tree = default(CommonTree);
		CommonTree string_literal363_tree = default(CommonTree);
		CommonTree string_literal364_tree = default(CommonTree);
		CommonTree string_literal365_tree = default(CommonTree);
		CommonTree string_literal366_tree = default(CommonTree);
		CommonTree LT367_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_relationalExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpressionNoIn");
		RewriteRuleSubtreeStream stream_equalityExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
		DebugLocation(492, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 68)) { return retval; }

			// JavaScript.g:493:2: ( relationalExpressionNoIn ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:494:3: relationalExpressionNoIn ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn )
			{
			DebugLocation(494, 3);
			PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn4481);
			relationalExpressionNoIn361=relationalExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalExpressionNoIn.Add(relationalExpressionNoIn361.Tree);
			DebugLocation(495, 3);
			// JavaScript.g:495:3: ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn )
			int alt201=2;
			try { DebugEnterSubRule(201);
			try { DebugEnterDecision(201, false);
			try
			{
				alt201 = dfa201.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(201); }
			switch (alt201)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:496:4: ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn )
				{
				DebugLocation(496, 4);
				// JavaScript.g:496:4: ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:497:5: ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn
				{
				DebugLocation(497, 5);
				// JavaScript.g:497:5: ( LT )*
				try { DebugEnterSubRule(198);
				while (true)
				{
					int alt198=2;
					try { DebugEnterDecision(198, false);
					int LA198_1 = input.LA(1);

					if ((LA198_1==LT))
					{
						alt198 = 1;
					}


					} finally { DebugExitDecision(198); }
					switch ( alt198 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:497:5: LT
						{
						DebugLocation(497, 5);
						LT362=(IToken)Match(input,LT,Follow._LT_in_equalityExpressionNoIn4496); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT362);


						}
						break;

					default:
						goto loop198;
					}
				}

				loop198:
					;

				} finally { DebugExitSubRule(198); }

				DebugLocation(498, 5);
				// JavaScript.g:498:5: ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) )
				int alt199=4;
				try { DebugEnterSubRule(199);
				try { DebugEnterDecision(199, false);
				switch (input.LA(1))
				{
				case 69:
					{
					alt199 = 1;
					}
					break;
				case 41:
					{
					alt199 = 2;
					}
					break;
				case 70:
					{
					alt199 = 3;
					}
					break;
				case 42:
					{
					alt199 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 199, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(199); }
				switch (alt199)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:499:6: '=='
					{
					DebugLocation(499, 6);
					string_literal363=(IToken)Match(input,69,Follow._69_in_equalityExpressionNoIn4511); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_69.Add(string_literal363);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 499:11: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(499, 14);
						// JavaScript.g:499:14: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(499, 16);
						root_1 = (CommonTree)adaptor.BecomeRoot(new EqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(499, 45);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(499, 70);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:500:8: '!='
					{
					DebugLocation(500, 8);
					string_literal364=(IToken)Match(input,41,Follow._41_in_equalityExpressionNoIn4535); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_41.Add(string_literal364);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 500:13: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(500, 16);
						// JavaScript.g:500:16: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(500, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot(new NotEqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(500, 50);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(500, 75);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:501:8: '==='
					{
					DebugLocation(501, 8);
					string_literal365=(IToken)Match(input,70,Follow._70_in_equalityExpressionNoIn4559); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_70.Add(string_literal365);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 501:14: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(501, 17);
						// JavaScript.g:501:17: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(501, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot(new StrictlyEqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(501, 56);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(501, 81);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:502:8: '!=='
					{
					DebugLocation(502, 8);
					string_literal366=(IToken)Match(input,42,Follow._42_in_equalityExpressionNoIn4583); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(string_literal366);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 502:14: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(502, 17);
						// JavaScript.g:502:17: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(502, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot(new NotStrictlyEqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(502, 59);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(502, 84);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(199); }

				DebugLocation(503, 7);
				// JavaScript.g:503:7: ( LT )*
				try { DebugEnterSubRule(200);
				while (true)
				{
					int alt200=2;
					try { DebugEnterDecision(200, false);
					int LA200_1 = input.LA(1);

					if ((LA200_1==LT))
					{
						alt200 = 1;
					}


					} finally { DebugExitDecision(200); }
					switch ( alt200 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:503:7: LT
						{
						DebugLocation(503, 7);
						LT367=(IToken)Match(input,LT,Follow._LT_in_equalityExpressionNoIn4606); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT367);


						}
						break;

					default:
						goto loop200;
					}
				}

				loop200:
					;

				} finally { DebugExitSubRule(200); }

				DebugLocation(503, 11);
				PushFollow(Follow._equalityExpressionNoIn_in_equalityExpressionNoIn4609);
				equalityExpressionNoIn368=equalityExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_equalityExpressionNoIn.Add(equalityExpressionNoIn368.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:505:6: 
				{

				{
				// AST REWRITE
				// elements: relationalExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 505:6: -> relationalExpressionNoIn
				{
					DebugLocation(505, 9);
					adaptor.AddChild(root_0, stream_relationalExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(201); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpressionNoIn", 68);
			LeaveRule("equalityExpressionNoIn", 68);
			LeaveRule_equalityExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 68, equalityExpressionNoIn_StartIndex); }

		}
		DebugLocation(507, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "equalityExpressionNoIn"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// JavaScript.g:509:1: relationalExpression : se= shiftExpression ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se) ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 69);
		TraceIn("relationalExpression", 69);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relationalExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT369 = default(IToken);
		IToken LT370 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> se = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> rel = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT369_tree = default(CommonTree);
		CommonTree LT370_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_96=new RewriteRuleITokenStream(adaptor,"token 96");
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,"rule shiftExpression");
		RewriteRuleSubtreeStream stream_relationalExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpression");
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(509, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 69)) { return retval; }

			// JavaScript.g:510:2: (se= shiftExpression ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se) )
			DebugEnterAlt(1);
			// JavaScript.g:511:3: se= shiftExpression ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se)
			{
			DebugLocation(511, 5);
			PushFollow(Follow._shiftExpression_in_relationalExpression4644);
			se=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_shiftExpression.Add(se.Tree);
			DebugLocation(512, 3);
			// JavaScript.g:512:3: ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se)
			int alt205=2;
			try { DebugEnterSubRule(205);
			try { DebugEnterDecision(205, false);
			try
			{
				alt205 = dfa205.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(205); }
			switch (alt205)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:513:4: ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression )
				{
				DebugLocation(513, 4);
				// JavaScript.g:513:4: ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression )
				DebugEnterAlt(1);
				// JavaScript.g:513:5: ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression
				{
				DebugLocation(513, 5);
				// JavaScript.g:513:5: ( LT )*
				try { DebugEnterSubRule(202);
				while (true)
				{
					int alt202=2;
					try { DebugEnterDecision(202, false);
					int LA202_1 = input.LA(1);

					if ((LA202_1==LT))
					{
						alt202 = 1;
					}


					} finally { DebugExitDecision(202); }
					switch ( alt202 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:513:5: LT
						{
						DebugLocation(513, 5);
						LT369=(IToken)Match(input,LT,Follow._LT_in_relationalExpression4655); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT369);


						}
						break;

					default:
						goto loop202;
					}
				}

				loop202:
					;

				} finally { DebugExitSubRule(202); }

				DebugLocation(513, 9);
				// JavaScript.g:513:9: (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' )
				int alt203=6;
				try { DebugEnterSubRule(203);
				try { DebugEnterDecision(203, false);
				switch (input.LA(1))
				{
				case 64:
					{
					alt203 = 1;
					}
					break;
				case 71:
					{
					alt203 = 2;
					}
					break;
				case 67:
					{
					alt203 = 3;
					}
					break;
				case 72:
					{
					alt203 = 4;
					}
					break;
				case 96:
					{
					alt203 = 5;
					}
					break;
				case 95:
					{
					alt203 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 203, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(203); }
				switch (alt203)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:513:10: op= '<'
					{
					DebugLocation(513, 12);
					op=(IToken)Match(input,64,Follow._64_in_relationalExpression4661); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_64.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:513:19: op= '>'
					{
					DebugLocation(513, 21);
					op=(IToken)Match(input,71,Follow._71_in_relationalExpression4667); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:513:28: op= '<='
					{
					DebugLocation(513, 30);
					op=(IToken)Match(input,67,Follow._67_in_relationalExpression4673); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:513:38: op= '>='
					{
					DebugLocation(513, 40);
					op=(IToken)Match(input,72,Follow._72_in_relationalExpression4679); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(op);


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// JavaScript.g:513:48: op= 'instanceof'
					{
					DebugLocation(513, 50);
					op=(IToken)Match(input,96,Follow._96_in_relationalExpression4685); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_96.Add(op);


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// JavaScript.g:513:66: op= 'in'
					{
					DebugLocation(513, 68);
					op=(IToken)Match(input,95,Follow._95_in_relationalExpression4691); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_95.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(203); }

				DebugLocation(513, 75);
				// JavaScript.g:513:75: ( LT )*
				try { DebugEnterSubRule(204);
				while (true)
				{
					int alt204=2;
					try { DebugEnterDecision(204, false);
					int LA204_1 = input.LA(1);

					if ((LA204_1==LT))
					{
						alt204 = 1;
					}


					} finally { DebugExitDecision(204); }
					switch ( alt204 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:513:75: LT
						{
						DebugLocation(513, 75);
						LT370=(IToken)Match(input,LT,Follow._LT_in_relationalExpression4694); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT370);


						}
						break;

					default:
						goto loop204;
					}
				}

				loop204:
					;

				} finally { DebugExitSubRule(204); }

				DebugLocation(513, 82);
				PushFollow(Follow._relationalExpression_in_relationalExpression4699);
				rel=relationalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_relationalExpression.Add(rel.Tree);

				}



				{
				// AST REWRITE
				// elements: 64, se, rel, 71, se, rel, 67, se, rel, 72, se, rel, 96, se, rel, 95, se, rel
				// token labels: 
				// rule labels: se, rel, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_se=new RewriteRuleSubtreeStream(adaptor,"rule se",se!=null?se.Tree:null);
				RewriteRuleSubtreeStream stream_rel=new RewriteRuleSubtreeStream(adaptor,"rule rel",rel!=null?rel.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 514:17: -> { op.Text == \"<\" }? ^( '<' $se $rel)
				if ( op.Text == "<"          )
				{
					DebugLocation(514, 49);
					// JavaScript.g:514:49: ^( '<' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(514, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanExpression(stream_64.NextToken()), root_1);

					DebugLocation(514, 81);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(514, 85);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 515:17: -> { op.Text == \">\" }? ^( '>' $se $rel)
				if ( op.Text == ">"          )
				{
					DebugLocation(515, 49);
					// JavaScript.g:515:49: ^( '>' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(515, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanExpression(stream_71.NextToken()), root_1);

					DebugLocation(515, 84);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(515, 88);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 516:17: -> { op.Text == \"<=\" }? ^( '<=' $se $rel)
				if ( op.Text == "<="         )
				{
					DebugLocation(516, 49);
					// JavaScript.g:516:49: ^( '<=' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(516, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanOrEqualToExpression(stream_67.NextToken()), root_1);

					DebugLocation(516, 91);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(516, 95);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 517:17: -> { op.Text == \">=\" }? ^( '>=' $se $rel)
				if ( op.Text == ">="         )
				{
					DebugLocation(517, 49);
					// JavaScript.g:517:49: ^( '>=' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(517, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanOrEqualToExpression(stream_72.NextToken()), root_1);

					DebugLocation(517, 94);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(517, 98);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 518:17: -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel)
				if ( op.Text == "instanceof" )
				{
					DebugLocation(518, 49);
					// JavaScript.g:518:49: ^( 'instanceof' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(518, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new InstanceOfExpression(stream_96.NextToken()), root_1);

					DebugLocation(518, 92);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(518, 96);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 519:17: -> { op.Text == \"in\" }? ^( 'in' $se $rel)
				if ( op.Text == "in"         )
				{
					DebugLocation(519, 49);
					// JavaScript.g:519:49: ^( 'in' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(519, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new InExpression(stream_95.NextToken()), root_1);

					DebugLocation(519, 76);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(519, 80);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 520:17: ->
				{
					DebugLocation(521, 4);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:521:8: 
				{

				{
				// AST REWRITE
				// elements: se
				// token labels: 
				// rule labels: se, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_se=new RewriteRuleSubtreeStream(adaptor,"rule se",se!=null?se.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 521:8: -> $se
				{
					DebugLocation(521, 12);
					adaptor.AddChild(root_0, stream_se.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(205); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 69);
			LeaveRule("relationalExpression", 69);
			LeaveRule_relationalExpression();
			if (state.backtracking > 0) { Memoize(input, 69, relationalExpression_StartIndex); }

		}
		DebugLocation(523, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalExpressionNoIn();
	partial void LeaveRule_relationalExpressionNoIn();
	// $ANTLR start "relationalExpressionNoIn"
	// JavaScript.g:525:1: relationalExpressionNoIn : shiftExpression ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression ) ;
	[GrammarRule("relationalExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalExpressionNoIn()
	{
		EnterRule_relationalExpressionNoIn();
		EnterRule("relationalExpressionNoIn", 70);
		TraceIn("relationalExpressionNoIn", 70);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relationalExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT372 = default(IToken);
		IToken char_literal373 = default(IToken);
		IToken char_literal374 = default(IToken);
		IToken string_literal375 = default(IToken);
		IToken string_literal376 = default(IToken);
		IToken string_literal377 = default(IToken);
		IToken LT378 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> shiftExpression371 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpressionNoIn379 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT372_tree = default(CommonTree);
		CommonTree char_literal373_tree = default(CommonTree);
		CommonTree char_literal374_tree = default(CommonTree);
		CommonTree string_literal375_tree = default(CommonTree);
		CommonTree string_literal376_tree = default(CommonTree);
		CommonTree string_literal377_tree = default(CommonTree);
		CommonTree LT378_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_96=new RewriteRuleITokenStream(adaptor,"token 96");
		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,"rule shiftExpression");
		RewriteRuleSubtreeStream stream_relationalExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
		DebugLocation(525, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 70)) { return retval; }

			// JavaScript.g:526:2: ( shiftExpression ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:527:3: shiftExpression ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression )
			{
			DebugLocation(527, 3);
			PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn4958);
			shiftExpression371=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_shiftExpression.Add(shiftExpression371.Tree);
			DebugLocation(528, 3);
			// JavaScript.g:528:3: ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression )
			int alt209=2;
			try { DebugEnterSubRule(209);
			try { DebugEnterDecision(209, false);
			try
			{
				alt209 = dfa209.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(209); }
			switch (alt209)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:529:4: ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn )
				{
				DebugLocation(529, 4);
				// JavaScript.g:529:4: ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:530:5: ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn
				{
				DebugLocation(530, 5);
				// JavaScript.g:530:5: ( LT )*
				try { DebugEnterSubRule(206);
				while (true)
				{
					int alt206=2;
					try { DebugEnterDecision(206, false);
					int LA206_1 = input.LA(1);

					if ((LA206_1==LT))
					{
						alt206 = 1;
					}


					} finally { DebugExitDecision(206); }
					switch ( alt206 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:530:5: LT
						{
						DebugLocation(530, 5);
						LT372=(IToken)Match(input,LT,Follow._LT_in_relationalExpressionNoIn4974); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT372);


						}
						break;

					default:
						goto loop206;
					}
				}

				loop206:
					;

				} finally { DebugExitSubRule(206); }

				DebugLocation(531, 5);
				// JavaScript.g:531:5: ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) )
				int alt207=5;
				try { DebugEnterSubRule(207);
				try { DebugEnterDecision(207, false);
				switch (input.LA(1))
				{
				case 64:
					{
					alt207 = 1;
					}
					break;
				case 71:
					{
					alt207 = 2;
					}
					break;
				case 67:
					{
					alt207 = 3;
					}
					break;
				case 72:
					{
					alt207 = 4;
					}
					break;
				case 96:
					{
					alt207 = 5;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 207, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(207); }
				switch (alt207)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:532:6: '<'
					{
					DebugLocation(532, 6);
					char_literal373=(IToken)Match(input,64,Follow._64_in_relationalExpressionNoIn4989); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_64.Add(char_literal373);



					{
					// AST REWRITE
					// elements: 64, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 532:14: -> ^( '<' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(532, 17);
						// JavaScript.g:532:17: ^( '<' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(532, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanExpression(stream_64.NextToken()), root_1);

						DebugLocation(532, 48);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(532, 64);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:533:8: '>'
					{
					DebugLocation(533, 8);
					char_literal374=(IToken)Match(input,71,Follow._71_in_relationalExpressionNoIn5017); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(char_literal374);



					{
					// AST REWRITE
					// elements: 71, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 533:15: -> ^( '>' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(533, 18);
						// JavaScript.g:533:18: ^( '>' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(533, 20);
						root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanExpression(stream_71.NextToken()), root_1);

						DebugLocation(533, 52);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(533, 68);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:534:8: '<='
					{
					DebugLocation(534, 8);
					string_literal375=(IToken)Match(input,67,Follow._67_in_relationalExpressionNoIn5044); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(string_literal375);



					{
					// AST REWRITE
					// elements: 67, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 534:16: -> ^( '<=' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(534, 19);
						// JavaScript.g:534:19: ^( '<=' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(534, 21);
						root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanOrEqualToExpression(stream_67.NextToken()), root_1);

						DebugLocation(534, 60);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(534, 76);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:535:8: '>='
					{
					DebugLocation(535, 8);
					string_literal376=(IToken)Match(input,72,Follow._72_in_relationalExpressionNoIn5071); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(string_literal376);



					{
					// AST REWRITE
					// elements: 72, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 535:16: -> ^( '>=' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(535, 19);
						// JavaScript.g:535:19: ^( '>=' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(535, 21);
						root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanOrEqualToExpression(stream_72.NextToken()), root_1);

						DebugLocation(535, 63);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(535, 79);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// JavaScript.g:536:8: 'instanceof'
					{
					DebugLocation(536, 8);
					string_literal377=(IToken)Match(input,96,Follow._96_in_relationalExpressionNoIn5098); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_96.Add(string_literal377);



					{
					// AST REWRITE
					// elements: 96, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 536:22: -> ^( 'instanceof' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(536, 25);
						// JavaScript.g:536:25: ^( 'instanceof' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(536, 27);
						root_1 = (CommonTree)adaptor.BecomeRoot(new InstanceOfExpression(stream_96.NextToken()), root_1);

						DebugLocation(536, 67);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(536, 83);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(207); }

				DebugLocation(537, 7);
				// JavaScript.g:537:7: ( LT )*
				try { DebugEnterSubRule(208);
				while (true)
				{
					int alt208=2;
					try { DebugEnterDecision(208, false);
					int LA208_1 = input.LA(1);

					if ((LA208_1==LT))
					{
						alt208 = 1;
					}


					} finally { DebugExitDecision(208); }
					switch ( alt208 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:537:7: LT
						{
						DebugLocation(537, 7);
						LT378=(IToken)Match(input,LT,Follow._LT_in_relationalExpressionNoIn5122); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT378);


						}
						break;

					default:
						goto loop208;
					}
				}

				loop208:
					;

				} finally { DebugExitSubRule(208); }

				DebugLocation(537, 11);
				PushFollow(Follow._relationalExpressionNoIn_in_relationalExpressionNoIn5125);
				relationalExpressionNoIn379=relationalExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_relationalExpressionNoIn.Add(relationalExpressionNoIn379.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:539:6: 
				{

				{
				// AST REWRITE
				// elements: shiftExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 539:6: -> shiftExpression
				{
					DebugLocation(539, 9);
					adaptor.AddChild(root_0, stream_shiftExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(209); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpressionNoIn", 70);
			LeaveRule("relationalExpressionNoIn", 70);
			LeaveRule_relationalExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 70, relationalExpressionNoIn_StartIndex); }

		}
		DebugLocation(541, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "relationalExpressionNoIn"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// JavaScript.g:543:1: shiftExpression : add= additiveExpression ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add) ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 71);
		TraceIn("shiftExpression", 71);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int shiftExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT380 = default(IToken);
		IToken LT381 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT380_tree = default(CommonTree);
		CommonTree LT381_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleITokenStream stream_75=new RewriteRuleITokenStream(adaptor,"token 75");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,"rule shiftExpression");
		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(543, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 71)) { return retval; }

			// JavaScript.g:544:2: (add= additiveExpression ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add) )
			DebugEnterAlt(1);
			// JavaScript.g:545:9: add= additiveExpression ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add)
			{
			DebugLocation(545, 12);
			PushFollow(Follow._additiveExpression_in_shiftExpression5165);
			add=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_additiveExpression.Add(add.Tree);
			DebugLocation(546, 9);
			// JavaScript.g:546:9: ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add)
			int alt213=2;
			try { DebugEnterSubRule(213);
			try { DebugEnterDecision(213, false);
			try
			{
				alt213 = dfa213.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(213); }
			switch (alt213)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:547:13: ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression )
				{
				DebugLocation(547, 13);
				// JavaScript.g:547:13: ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression )
				DebugEnterAlt(1);
				// JavaScript.g:547:14: ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression
				{
				DebugLocation(547, 14);
				// JavaScript.g:547:14: ( LT )*
				try { DebugEnterSubRule(210);
				while (true)
				{
					int alt210=2;
					try { DebugEnterDecision(210, false);
					int LA210_1 = input.LA(1);

					if ((LA210_1==LT))
					{
						alt210 = 1;
					}


					} finally { DebugExitDecision(210); }
					switch ( alt210 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:547:14: LT
						{
						DebugLocation(547, 14);
						LT380=(IToken)Match(input,LT,Follow._LT_in_shiftExpression5191); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT380);


						}
						break;

					default:
						goto loop210;
					}
				}

				loop210:
					;

				} finally { DebugExitSubRule(210); }

				DebugLocation(547, 18);
				// JavaScript.g:547:18: (op= '<<' |op= '>>' |op= '>>>' )
				int alt211=3;
				try { DebugEnterSubRule(211);
				try { DebugEnterDecision(211, false);
				switch (input.LA(1))
				{
				case 65:
					{
					alt211 = 1;
					}
					break;
				case 73:
					{
					alt211 = 2;
					}
					break;
				case 75:
					{
					alt211 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 211, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(211); }
				switch (alt211)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:547:19: op= '<<'
					{
					DebugLocation(547, 21);
					op=(IToken)Match(input,65,Follow._65_in_shiftExpression5197); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_65.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:547:29: op= '>>'
					{
					DebugLocation(547, 31);
					op=(IToken)Match(input,73,Follow._73_in_shiftExpression5203); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_73.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:547:39: op= '>>>'
					{
					DebugLocation(547, 41);
					op=(IToken)Match(input,75,Follow._75_in_shiftExpression5209); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_75.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(211); }

				DebugLocation(547, 49);
				// JavaScript.g:547:49: ( LT )*
				try { DebugEnterSubRule(212);
				while (true)
				{
					int alt212=2;
					try { DebugEnterDecision(212, false);
					int LA212_1 = input.LA(1);

					if ((LA212_1==LT))
					{
						alt212 = 1;
					}


					} finally { DebugExitDecision(212); }
					switch ( alt212 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:547:49: LT
						{
						DebugLocation(547, 49);
						LT381=(IToken)Match(input,LT,Follow._LT_in_shiftExpression5212); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT381);


						}
						break;

					default:
						goto loop212;
					}
				}

				loop212:
					;

				} finally { DebugExitSubRule(212); }

				DebugLocation(547, 58);
				PushFollow(Follow._shiftExpression_in_shiftExpression5217);
				shift=shiftExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_shiftExpression.Add(shift.Tree);

				}



				{
				// AST REWRITE
				// elements: 65, add, shift, 73, add, shift, 75, add, shift
				// token labels: 
				// rule labels: add, shift, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_add=new RewriteRuleSubtreeStream(adaptor,"rule add",add!=null?add.Tree:null);
				RewriteRuleSubtreeStream stream_shift=new RewriteRuleSubtreeStream(adaptor,"rule shift",shift!=null?shift.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 548:17: -> { op.Text == \"<<\" }? ^( '<<' $add $shift)
				if ( op.Text == "<<"  )
				{
					DebugLocation(548, 42);
					// JavaScript.g:548:42: ^( '<<' $add $shift)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(548, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftLeftExpression(stream_65.NextToken()), root_1);

					DebugLocation(548, 76);
					adaptor.AddChild(root_1, stream_add.NextTree());
					DebugLocation(548, 81);
					adaptor.AddChild(root_1, stream_shift.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 549:17: -> { op.Text == \">>\" }? ^( '>>' $add $shift)
				if ( op.Text == ">>"  )
				{
					DebugLocation(549, 42);
					// JavaScript.g:549:42: ^( '>>' $add $shift)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(549, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftRightExpression(stream_73.NextToken()), root_1);

					DebugLocation(549, 77);
					adaptor.AddChild(root_1, stream_add.NextTree());
					DebugLocation(549, 82);
					adaptor.AddChild(root_1, stream_shift.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 550:14: -> { op.Text == \">>>\" }? ^( '>>>' $add $shift)
				if ( op.Text == ">>>" )
				{
					DebugLocation(550, 39);
					// JavaScript.g:550:39: ^( '>>>' $add $shift)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(550, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new RotateRightExpression(stream_75.NextToken()), root_1);

					DebugLocation(550, 76);
					adaptor.AddChild(root_1, stream_add.NextTree());
					DebugLocation(550, 81);
					adaptor.AddChild(root_1, stream_shift.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 551:17: ->
				{
					DebugLocation(552, 13);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:552:17: 
				{

				{
				// AST REWRITE
				// elements: add
				// token labels: 
				// rule labels: add, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_add=new RewriteRuleSubtreeStream(adaptor,"rule add",add!=null?add.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 552:17: -> $add
				{
					DebugLocation(552, 21);
					adaptor.AddChild(root_0, stream_add.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(213); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 71);
			LeaveRule("shiftExpression", 71);
			LeaveRule_shiftExpression();
			if (state.backtracking > 0) { Memoize(input, 71, shiftExpression_StartIndex); }

		}
		DebugLocation(554, 4);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// JavaScript.g:556:1: additiveExpression : mult= multiplicativeExpression ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )? -> { op == null }? $mult -> { op.Text == \"+\" }? ^( '+' $mult $add) -> { op.Text == \"-\" }? ^( '-' $mult $add) ->;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 72);
		TraceIn("additiveExpression", 72);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int additiveExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT382 = default(IToken);
		IToken LT383 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> mult = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT382_tree = default(CommonTree);
		CommonTree LT383_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(556, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 72)) { return retval; }

			// JavaScript.g:557:2: (mult= multiplicativeExpression ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )? -> { op == null }? $mult -> { op.Text == \"+\" }? ^( '+' $mult $add) -> { op.Text == \"-\" }? ^( '-' $mult $add) ->)
			DebugEnterAlt(1);
			// JavaScript.g:558:3: mult= multiplicativeExpression ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )?
			{
			DebugLocation(558, 7);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression5388);
			mult=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_multiplicativeExpression.Add(mult.Tree);
			DebugLocation(559, 6);
			// JavaScript.g:559:6: ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )?
			int alt217=2;
			try { DebugEnterSubRule(217);
			try { DebugEnterDecision(217, false);
			int LA217_1 = input.LA(1);

			if ((LA217_1==LT))
			{
				int LA217_2 = input.LA(2);

				if ((EvaluatePredicate(synpred256_JavaScript_fragment)))
				{
					alt217 = 1;
				}
			}
			else if ((LA217_1==52||LA217_1==56))
			{
				alt217 = 1;
			}
			} finally { DebugExitDecision(217); }
			switch (alt217)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:559:7: ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression
				{
				DebugLocation(559, 7);
				// JavaScript.g:559:7: ( LT )*
				try { DebugEnterSubRule(214);
				while (true)
				{
					int alt214=2;
					try { DebugEnterDecision(214, false);
					int LA214_1 = input.LA(1);

					if ((LA214_1==LT))
					{
						alt214 = 1;
					}


					} finally { DebugExitDecision(214); }
					switch ( alt214 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:559:7: LT
						{
						DebugLocation(559, 7);
						LT382=(IToken)Match(input,LT,Follow._LT_in_additiveExpression5397); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT382);


						}
						break;

					default:
						goto loop214;
					}
				}

				loop214:
					;

				} finally { DebugExitSubRule(214); }

				DebugLocation(559, 11);
				// JavaScript.g:559:11: (op= '+' |op= '-' )
				int alt215=2;
				try { DebugEnterSubRule(215);
				try { DebugEnterDecision(215, false);
				int LA215_1 = input.LA(1);

				if ((LA215_1==52))
				{
					alt215 = 1;
				}
				else if ((LA215_1==56))
				{
					alt215 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 215, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(215); }
				switch (alt215)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:559:12: op= '+'
					{
					DebugLocation(559, 14);
					op=(IToken)Match(input,52,Follow._52_in_additiveExpression5403); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_52.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:559:21: op= '-'
					{
					DebugLocation(559, 23);
					op=(IToken)Match(input,56,Follow._56_in_additiveExpression5409); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_56.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(215); }

				DebugLocation(559, 29);
				// JavaScript.g:559:29: ( LT )*
				try { DebugEnterSubRule(216);
				while (true)
				{
					int alt216=2;
					try { DebugEnterDecision(216, false);
					int LA216_1 = input.LA(1);

					if ((LA216_1==LT))
					{
						alt216 = 1;
					}


					} finally { DebugExitDecision(216); }
					switch ( alt216 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:559:29: LT
						{
						DebugLocation(559, 29);
						LT383=(IToken)Match(input,LT,Follow._LT_in_additiveExpression5412); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT383);


						}
						break;

					default:
						goto loop216;
					}
				}

				loop216:
					;

				} finally { DebugExitSubRule(216); }

				DebugLocation(559, 36);
				PushFollow(Follow._additiveExpression_in_additiveExpression5417);
				add=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(add.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(217); }



			{
			// AST REWRITE
			// elements: mult, 52, mult, add, 56, mult, add
			// token labels: 
			// rule labels: mult, add, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_mult=new RewriteRuleSubtreeStream(adaptor,"rule mult",mult!=null?mult.Tree:null);
			RewriteRuleSubtreeStream stream_add=new RewriteRuleSubtreeStream(adaptor,"rule add",add!=null?add.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 560:13: -> { op == null }? $mult
			if ( op      == null )
			{
				DebugLocation(560, 38);
				adaptor.AddChild(root_0, stream_mult.NextTree());

			}
			else // 561:13: -> { op.Text == \"+\" }? ^( '+' $mult $add)
			if ( op.Text == "+"  )
			{
				DebugLocation(561, 37);
				// JavaScript.g:561:37: ^( '+' $mult $add)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(561, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(new AdditionExpression(stream_52.NextToken()), root_1);

				DebugLocation(561, 69);
				adaptor.AddChild(root_1, stream_mult.NextTree());
				DebugLocation(561, 75);
				adaptor.AddChild(root_1, stream_add.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 562:13: -> { op.Text == \"-\" }? ^( '-' $mult $add)
			if ( op.Text == "-"  )
			{
				DebugLocation(562, 37);
				// JavaScript.g:562:37: ^( '-' $mult $add)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(562, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(new SubtractionExpression(stream_56.NextToken()), root_1);

				DebugLocation(562, 72);
				adaptor.AddChild(root_1, stream_mult.NextTree());
				DebugLocation(562, 78);
				adaptor.AddChild(root_1, stream_add.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 563:13: ->
			{
				DebugLocation(564, 2);
				root_0 = null;
			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 72);
			LeaveRule("additiveExpression", 72);
			LeaveRule_additiveExpression();
			if (state.backtracking > 0) { Memoize(input, 72, additiveExpression_StartIndex); }

		}
		DebugLocation(564, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// JavaScript.g:566:1: multiplicativeExpression : ue= unaryExpression ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue) ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 73);
		TraceIn("multiplicativeExpression", 73);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int multiplicativeExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT384 = default(IToken);
		IToken LT385 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ue = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> me = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT384_tree = default(CommonTree);
		CommonTree LT385_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(566, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 73)) { return retval; }

			// JavaScript.g:567:2: (ue= unaryExpression ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue) )
			DebugEnterAlt(1);
			// JavaScript.g:568:3: ue= unaryExpression ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue)
			{
			DebugLocation(568, 5);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression5530);
			ue=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_unaryExpression.Add(ue.Tree);
			DebugLocation(569, 3);
			// JavaScript.g:569:3: ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue)
			int alt221=2;
			try { DebugEnterSubRule(221);
			try { DebugEnterDecision(221, false);
			try
			{
				alt221 = dfa221.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(221); }
			switch (alt221)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:570:4: ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression )
				{
				DebugLocation(570, 4);
				// JavaScript.g:570:4: ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression )
				DebugEnterAlt(1);
				// JavaScript.g:570:5: ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression
				{
				DebugLocation(570, 5);
				// JavaScript.g:570:5: ( LT )*
				try { DebugEnterSubRule(218);
				while (true)
				{
					int alt218=2;
					try { DebugEnterDecision(218, false);
					int LA218_1 = input.LA(1);

					if ((LA218_1==LT))
					{
						alt218 = 1;
					}


					} finally { DebugExitDecision(218); }
					switch ( alt218 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:570:5: LT
						{
						DebugLocation(570, 5);
						LT384=(IToken)Match(input,LT,Follow._LT_in_multiplicativeExpression5541); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT384);


						}
						break;

					default:
						goto loop218;
					}
				}

				loop218:
					;

				} finally { DebugExitSubRule(218); }

				DebugLocation(570, 9);
				// JavaScript.g:570:9: (op= '*' |op= '/' |op= '%' )
				int alt219=3;
				try { DebugEnterSubRule(219);
				try { DebugEnterDecision(219, false);
				switch (input.LA(1))
				{
				case 50:
					{
					alt219 = 1;
					}
					break;
				case 60:
					{
					alt219 = 2;
					}
					break;
				case 43:
					{
					alt219 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 219, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(219); }
				switch (alt219)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:570:10: op= '*'
					{
					DebugLocation(570, 12);
					op=(IToken)Match(input,50,Follow._50_in_multiplicativeExpression5547); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_50.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:570:19: op= '/'
					{
					DebugLocation(570, 21);
					op=(IToken)Match(input,60,Follow._60_in_multiplicativeExpression5553); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_60.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:570:28: op= '%'
					{
					DebugLocation(570, 30);
					op=(IToken)Match(input,43,Follow._43_in_multiplicativeExpression5559); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_43.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(219); }

				DebugLocation(570, 36);
				// JavaScript.g:570:36: ( LT )*
				try { DebugEnterSubRule(220);
				while (true)
				{
					int alt220=2;
					try { DebugEnterDecision(220, false);
					int LA220_1 = input.LA(1);

					if ((LA220_1==LT))
					{
						alt220 = 1;
					}


					} finally { DebugExitDecision(220); }
					switch ( alt220 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:570:36: LT
						{
						DebugLocation(570, 36);
						LT385=(IToken)Match(input,LT,Follow._LT_in_multiplicativeExpression5562); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT385);


						}
						break;

					default:
						goto loop220;
					}
				}

				loop220:
					;

				} finally { DebugExitSubRule(220); }

				DebugLocation(570, 42);
				PushFollow(Follow._multiplicativeExpression_in_multiplicativeExpression5567);
				me=multiplicativeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_multiplicativeExpression.Add(me.Tree);

				}



				{
				// AST REWRITE
				// elements: 50, ue, me, 60, ue, me, 43, ue, me
				// token labels: 
				// rule labels: ue, me, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ue=new RewriteRuleSubtreeStream(adaptor,"rule ue",ue!=null?ue.Tree:null);
				RewriteRuleSubtreeStream stream_me=new RewriteRuleSubtreeStream(adaptor,"rule me",me!=null?me.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 571:17: -> { op.Text == \"*\" }? ^( '*' $ue $me)
				if ( op.Text == "*"  )
				{
					DebugLocation(571, 41);
					// JavaScript.g:571:41: ^( '*' $ue $me)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(571, 43);
					root_1 = (CommonTree)adaptor.BecomeRoot(new MultiplicationExpression(stream_50.NextToken()), root_1);

					DebugLocation(571, 79);
					adaptor.AddChild(root_1, stream_ue.NextTree());
					DebugLocation(571, 83);
					adaptor.AddChild(root_1, stream_me.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 572:17: -> { op.Text == \"/\" }? ^( '/' $ue $me)
				if ( op.Text == "/"  )
				{
					DebugLocation(572, 41);
					// JavaScript.g:572:41: ^( '/' $ue $me)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(572, 43);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DivisionExpression(stream_60.NextToken()), root_1);

					DebugLocation(572, 73);
					adaptor.AddChild(root_1, stream_ue.NextTree());
					DebugLocation(572, 77);
					adaptor.AddChild(root_1, stream_me.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 573:17: -> { op.Text == \"\\%\" }? ^( '%' $ue $me)
				if ( op.Text == "%" )
				{
					DebugLocation(573, 41);
					// JavaScript.g:573:41: ^( '%' $ue $me)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(573, 43);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ModulusExpression(stream_43.NextToken()), root_1);

					DebugLocation(573, 72);
					adaptor.AddChild(root_1, stream_ue.NextTree());
					DebugLocation(573, 76);
					adaptor.AddChild(root_1, stream_me.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 574:8: ->
				{
					DebugLocation(575, 13);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:575:17: 
				{

				{
				// AST REWRITE
				// elements: ue
				// token labels: 
				// rule labels: ue, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ue=new RewriteRuleSubtreeStream(adaptor,"rule ue",ue!=null?ue.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 575:17: -> $ue
				{
					DebugLocation(575, 21);
					adaptor.AddChild(root_0, stream_ue.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(221); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 73);
			LeaveRule("multiplicativeExpression", 73);
			LeaveRule_multiplicativeExpression();
			if (state.backtracking > 0) { Memoize(input, 73, multiplicativeExpression_StartIndex); }

		}
		DebugLocation(577, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// JavaScript.g:579:1: unaryExpression : (pfe= postfixExpression -> $pfe| ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression ) -> { op.Text == \"delete\" }? ^( 'delete' $ue) -> { op.Text == \"void\" }? ^( 'void' $ue) -> { op.Text == \"typeof\" }? ^( 'typeof' $ue) -> { op.Text == \"++\" }? ^( '++' $ue) -> { op.Text == \"--\" }? ^( '--' $ue) -> { op.Text == \"+\" }? ^( '+' $ue) -> { op.Text == \"-\" }? ^( '-' $ue) -> { op.Text == \"~\" }? ^( '~' $ue) -> { op.Text == \"!\" }? ^( '!' $ue) ->);
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 74);
		TraceIn("unaryExpression", 74);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int unaryExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> pfe = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ue = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		RewriteRuleITokenStream stream_87=new RewriteRuleITokenStream(adaptor,"token 87");
		RewriteRuleITokenStream stream_107=new RewriteRuleITokenStream(adaptor,"token 107");
		RewriteRuleITokenStream stream_105=new RewriteRuleITokenStream(adaptor,"token 105");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_115=new RewriteRuleITokenStream(adaptor,"token 115");
		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
		RewriteRuleSubtreeStream stream_postfixExpression=new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(579, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 74)) { return retval; }

			// JavaScript.g:580:2: (pfe= postfixExpression -> $pfe| ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression ) -> { op.Text == \"delete\" }? ^( 'delete' $ue) -> { op.Text == \"void\" }? ^( 'void' $ue) -> { op.Text == \"typeof\" }? ^( 'typeof' $ue) -> { op.Text == \"++\" }? ^( '++' $ue) -> { op.Text == \"--\" }? ^( '--' $ue) -> { op.Text == \"+\" }? ^( '+' $ue) -> { op.Text == \"-\" }? ^( '-' $ue) -> { op.Text == \"~\" }? ^( '~' $ue) -> { op.Text == \"!\" }? ^( '!' $ue) ->)
			int alt223=2;
			try { DebugEnterDecision(223, false);
			int LA223_1 = input.LA(1);

			if ((LA223_1==Identifier||LA223_1==NumericLiteral||LA223_1==StringLiteral||LA223_1==48||LA223_1==78||LA223_1==90||LA223_1==93||(LA223_1>=97 && LA223_1<=98)||LA223_1==101||LA223_1==103||LA223_1==110))
			{
				alt223 = 1;
			}
			else if ((LA223_1==40||(LA223_1>=52 && LA223_1<=53)||(LA223_1>=56 && LA223_1<=57)||LA223_1==87||LA223_1==105||LA223_1==107||LA223_1==115))
			{
				alt223 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 223, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(223); }
			switch (alt223)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:580:4: pfe= postfixExpression
				{
				DebugLocation(580, 7);
				PushFollow(Follow._postfixExpression_in_unaryExpression5720);
				pfe=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_postfixExpression.Add(pfe.Tree);


				{
				// AST REWRITE
				// elements: pfe
				// token labels: 
				// rule labels: pfe, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_pfe=new RewriteRuleSubtreeStream(adaptor,"rule pfe",pfe!=null?pfe.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 580:26: -> $pfe
				{
					DebugLocation(580, 30);
					adaptor.AddChild(root_0, stream_pfe.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:582:9: ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression )
				{
				DebugLocation(582, 9);
				// JavaScript.g:582:9: ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression )
				DebugEnterAlt(1);
				// JavaScript.g:583:13: (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression
				{
				DebugLocation(583, 13);
				// JavaScript.g:583:13: (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' )
				int alt222=9;
				try { DebugEnterSubRule(222);
				try { DebugEnterDecision(222, false);
				switch (input.LA(1))
				{
				case 87:
					{
					alt222 = 1;
					}
					break;
				case 107:
					{
					alt222 = 2;
					}
					break;
				case 105:
					{
					alt222 = 3;
					}
					break;
				case 53:
					{
					alt222 = 4;
					}
					break;
				case 57:
					{
					alt222 = 5;
					}
					break;
				case 52:
					{
					alt222 = 6;
					}
					break;
				case 56:
					{
					alt222 = 7;
					}
					break;
				case 115:
					{
					alt222 = 8;
					}
					break;
				case 40:
					{
					alt222 = 9;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 222, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(222); }
				switch (alt222)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:583:14: op= 'delete'
					{
					DebugLocation(583, 16);
					op=(IToken)Match(input,87,Follow._87_in_unaryExpression5756); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_87.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:583:28: op= 'void'
					{
					DebugLocation(583, 30);
					op=(IToken)Match(input,107,Follow._107_in_unaryExpression5762); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_107.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:583:40: op= 'typeof'
					{
					DebugLocation(583, 42);
					op=(IToken)Match(input,105,Follow._105_in_unaryExpression5768); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_105.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:583:54: op= '++'
					{
					DebugLocation(583, 56);
					op=(IToken)Match(input,53,Follow._53_in_unaryExpression5774); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_53.Add(op);


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// JavaScript.g:583:64: op= '--'
					{
					DebugLocation(583, 66);
					op=(IToken)Match(input,57,Follow._57_in_unaryExpression5780); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_57.Add(op);


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// JavaScript.g:583:74: op= '+'
					{
					DebugLocation(583, 76);
					op=(IToken)Match(input,52,Follow._52_in_unaryExpression5786); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_52.Add(op);


					}
					break;
				case 7:
					DebugEnterAlt(7);
					// JavaScript.g:583:83: op= '-'
					{
					DebugLocation(583, 85);
					op=(IToken)Match(input,56,Follow._56_in_unaryExpression5792); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_56.Add(op);


					}
					break;
				case 8:
					DebugEnterAlt(8);
					// JavaScript.g:583:92: op= '~'
					{
					DebugLocation(583, 94);
					op=(IToken)Match(input,115,Follow._115_in_unaryExpression5798); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_115.Add(op);


					}
					break;
				case 9:
					DebugEnterAlt(9);
					// JavaScript.g:583:101: op= '!'
					{
					DebugLocation(583, 103);
					op=(IToken)Match(input,40,Follow._40_in_unaryExpression5804); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_40.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(222); }

				DebugLocation(584, 15);
				PushFollow(Follow._unaryExpression_in_unaryExpression5822);
				ue=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(ue.Tree);

				}



				{
				// AST REWRITE
				// elements: 87, ue, 107, ue, 105, ue, 53, ue, 57, ue, 52, ue, 56, ue, 115, ue, 40, ue
				// token labels: 
				// rule labels: ue, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ue=new RewriteRuleSubtreeStream(adaptor,"rule ue",ue!=null?ue.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 586:9: -> { op.Text == \"delete\" }? ^( 'delete' $ue)
				if ( op.Text == "delete" )
				{
					DebugLocation(586, 37);
					// JavaScript.g:586:37: ^( 'delete' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(586, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DeleteExpression(stream_87.NextToken()), root_1);

					DebugLocation(586, 72);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 587:9: -> { op.Text == \"void\" }? ^( 'void' $ue)
				if ( op.Text == "void"   )
				{
					DebugLocation(587, 37);
					// JavaScript.g:587:37: ^( 'void' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(587, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new VoidExpression(stream_107.NextToken()), root_1);

					DebugLocation(587, 68);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 588:9: -> { op.Text == \"typeof\" }? ^( 'typeof' $ue)
				if ( op.Text == "typeof" )
				{
					DebugLocation(588, 37);
					// JavaScript.g:588:37: ^( 'typeof' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(588, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new TypeofExpression(stream_105.NextToken()), root_1);

					DebugLocation(588, 72);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 589:9: -> { op.Text == \"++\" }? ^( '++' $ue)
				if ( op.Text == "++"     )
				{
					DebugLocation(589, 37);
					// JavaScript.g:589:37: ^( '++' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(589, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PrefixIncrementExpression(stream_53.NextToken()), root_1);

					DebugLocation(589, 77);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 590:9: -> { op.Text == \"--\" }? ^( '--' $ue)
				if ( op.Text == "--"     )
				{
					DebugLocation(590, 37);
					// JavaScript.g:590:37: ^( '--' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(590, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PrefixDecrementExpression(stream_57.NextToken()), root_1);

					DebugLocation(590, 77);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 591:9: -> { op.Text == \"+\" }? ^( '+' $ue)
				if ( op.Text == "+"      )
				{
					DebugLocation(591, 37);
					// JavaScript.g:591:37: ^( '+' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(591, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new UnaryPlusExpression(stream_52.NextToken()), root_1);

					DebugLocation(591, 70);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 592:9: -> { op.Text == \"-\" }? ^( '-' $ue)
				if ( op.Text == "-"      )
				{
					DebugLocation(592, 37);
					// JavaScript.g:592:37: ^( '-' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(592, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NegationExpression(stream_56.NextToken()), root_1);

					DebugLocation(592, 69);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 593:9: -> { op.Text == \"~\" }? ^( '~' $ue)
				if ( op.Text == "~"      )
				{
					DebugLocation(593, 37);
					// JavaScript.g:593:37: ^( '~' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(593, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseNotExpression(stream_115.NextToken()), root_1);

					DebugLocation(593, 71);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 594:9: -> { op.Text == \"!\" }? ^( '!' $ue)
				if ( op.Text == "!"      )
				{
					DebugLocation(594, 37);
					// JavaScript.g:594:37: ^( '!' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(594, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BooleanNotExpression(stream_40.NextToken()), root_1);

					DebugLocation(594, 71);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 595:9: ->
				{
					DebugLocation(596, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 74);
			LeaveRule("unaryExpression", 74);
			LeaveRule_unaryExpression();
			if (state.backtracking > 0) { Memoize(input, 74, unaryExpression_StartIndex); }

		}
		DebugLocation(596, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// JavaScript.g:598:1: postfixExpression : leftHandSideExpression ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression ) ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 75);
		TraceIn("postfixExpression", 75);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int postfixExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal387 = default(IToken);
		IToken string_literal388 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> leftHandSideExpression386 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal387_tree = default(CommonTree);
		CommonTree string_literal388_tree = default(CommonTree);
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleSubtreeStream stream_leftHandSideExpression=new RewriteRuleSubtreeStream(adaptor,"rule leftHandSideExpression");
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(598, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 75)) { return retval; }

			// JavaScript.g:599:2: ( leftHandSideExpression ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:600:3: leftHandSideExpression ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression )
			{
			DebugLocation(600, 3);
			PushFollow(Follow._leftHandSideExpression_in_postfixExpression6074);
			leftHandSideExpression386=leftHandSideExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_leftHandSideExpression.Add(leftHandSideExpression386.Tree);
			DebugLocation(601, 3);
			// JavaScript.g:601:3: ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression )
			int alt224=3;
			try { DebugEnterSubRule(224);
			try { DebugEnterDecision(224, false);
			switch (input.LA(1))
			{
			case 53:
				{
				alt224 = 1;
				}
				break;
			case 57:
				{
				alt224 = 2;
				}
				break;
			case EOF:
			case LT:
			case 41:
			case 42:
			case 43:
			case 45:
			case 46:
			case 49:
			case 50:
			case 52:
			case 55:
			case 56:
			case 60:
			case 62:
			case 63:
			case 64:
			case 65:
			case 67:
			case 69:
			case 70:
			case 71:
			case 72:
			case 73:
			case 75:
			case 77:
			case 79:
			case 80:
			case 95:
			case 96:
			case 111:
			case 113:
			case 114:
				{
				alt224 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 224, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(224); }
			switch (alt224)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:602:4: '++'
				{
				DebugLocation(602, 4);
				string_literal387=(IToken)Match(input,53,Follow._53_in_postfixExpression6084); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(string_literal387);



				{
				// AST REWRITE
				// elements: 53, leftHandSideExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 602:9: -> ^( '++' leftHandSideExpression )
				{
					DebugLocation(602, 12);
					// JavaScript.g:602:12: ^( '++' leftHandSideExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(602, 14);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PostfixIncrementExpression(stream_53.NextToken()), root_1);

					DebugLocation(602, 52);
					adaptor.AddChild(root_1, stream_leftHandSideExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:603:6: '--'
				{
				DebugLocation(603, 6);
				string_literal388=(IToken)Match(input,57,Follow._57_in_postfixExpression6104); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(string_literal388);



				{
				// AST REWRITE
				// elements: 57, leftHandSideExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 603:11: -> ^( '--' leftHandSideExpression )
				{
					DebugLocation(603, 14);
					// JavaScript.g:603:14: ^( '--' leftHandSideExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(603, 16);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PostfixDecrementExpression(stream_57.NextToken()), root_1);

					DebugLocation(603, 54);
					adaptor.AddChild(root_1, stream_leftHandSideExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:604:7: 
				{

				{
				// AST REWRITE
				// elements: leftHandSideExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 604:7: -> leftHandSideExpression
				{
					DebugLocation(604, 10);
					adaptor.AddChild(root_0, stream_leftHandSideExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(224); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 75);
			LeaveRule("postfixExpression", 75);
			LeaveRule_postfixExpression();
			if (state.backtracking > 0) { Memoize(input, 75, postfixExpression_StartIndex); }

		}
		DebugLocation(606, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// JavaScript.g:608:1: primaryExpression : ( 'this' -> ^( 'this' ) | Identifier -> ^( Identifier ) | literal -> literal | arrayLiteral -> arrayLiteral | objectLiteral -> objectLiteral | '(' ( LT )* expression ( LT )* ')' -> expression );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 76);
		TraceIn("primaryExpression", 76);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primaryExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal389 = default(IToken);
		IToken Identifier390 = default(IToken);
		IToken char_literal394 = default(IToken);
		IToken LT395 = default(IToken);
		IToken LT397 = default(IToken);
		IToken char_literal398 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> literal391 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arrayLiteral392 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> objectLiteral393 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression396 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal389_tree = default(CommonTree);
		CommonTree Identifier390_tree = default(CommonTree);
		CommonTree char_literal394_tree = default(CommonTree);
		CommonTree LT395_tree = default(CommonTree);
		CommonTree LT397_tree = default(CommonTree);
		CommonTree char_literal398_tree = default(CommonTree);
		RewriteRuleITokenStream stream_101=new RewriteRuleITokenStream(adaptor,"token 101");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_literal=new RewriteRuleSubtreeStream(adaptor,"rule literal");
		RewriteRuleSubtreeStream stream_arrayLiteral=new RewriteRuleSubtreeStream(adaptor,"rule arrayLiteral");
		RewriteRuleSubtreeStream stream_objectLiteral=new RewriteRuleSubtreeStream(adaptor,"rule objectLiteral");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(608, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 76)) { return retval; }

			// JavaScript.g:609:2: ( 'this' -> ^( 'this' ) | Identifier -> ^( Identifier ) | literal -> literal | arrayLiteral -> arrayLiteral | objectLiteral -> objectLiteral | '(' ( LT )* expression ( LT )* ')' -> expression )
			int alt227=6;
			try { DebugEnterDecision(227, false);
			switch (input.LA(1))
			{
			case 101:
				{
				alt227 = 1;
				}
				break;
			case Identifier:
				{
				alt227 = 2;
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 90:
			case 98:
			case 103:
				{
				alt227 = 3;
				}
				break;
			case 78:
				{
				alt227 = 4;
				}
				break;
			case 110:
				{
				alt227 = 5;
				}
				break;
			case 48:
				{
				alt227 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 227, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(227); }
			switch (alt227)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:609:4: 'this'
				{
				DebugLocation(609, 4);
				string_literal389=(IToken)Match(input,101,Follow._101_in_primaryExpression6142); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_101.Add(string_literal389);



				{
				// AST REWRITE
				// elements: 101
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 609:16: -> ^( 'this' )
				{
					DebugLocation(609, 19);
					// JavaScript.g:609:19: ^( 'this' )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(609, 21);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ThisExpression(stream_101.NextToken()), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:610:4: Identifier
				{
				DebugLocation(610, 4);
				Identifier390=(IToken)Match(input,Identifier,Follow._Identifier_in_primaryExpression6163); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier390);



				{
				// AST REWRITE
				// elements: Identifier
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 610:19: -> ^( Identifier )
				{
					DebugLocation(610, 22);
					// JavaScript.g:610:22: ^( Identifier )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(610, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot(new Identifier(stream_Identifier.NextToken()), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:611:4: literal
				{
				DebugLocation(611, 4);
				PushFollow(Follow._literal_in_primaryExpression6183);
				literal391=literal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_literal.Add(literal391.Tree);


				{
				// AST REWRITE
				// elements: literal
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 611:17: -> literal
				{
					DebugLocation(611, 20);
					adaptor.AddChild(root_0, stream_literal.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:612:4: arrayLiteral
				{
				DebugLocation(612, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression6197);
				arrayLiteral392=arrayLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arrayLiteral.Add(arrayLiteral392.Tree);


				{
				// AST REWRITE
				// elements: arrayLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 612:21: -> arrayLiteral
				{
					DebugLocation(612, 24);
					adaptor.AddChild(root_0, stream_arrayLiteral.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:613:4: objectLiteral
				{
				DebugLocation(613, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression6210);
				objectLiteral393=objectLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_objectLiteral.Add(objectLiteral393.Tree);


				{
				// AST REWRITE
				// elements: objectLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 613:22: -> objectLiteral
				{
					DebugLocation(613, 25);
					adaptor.AddChild(root_0, stream_objectLiteral.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:614:4: '(' ( LT )* expression ( LT )* ')'
				{
				DebugLocation(614, 4);
				char_literal394=(IToken)Match(input,48,Follow._48_in_primaryExpression6223); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(char_literal394);

				DebugLocation(614, 8);
				// JavaScript.g:614:8: ( LT )*
				try { DebugEnterSubRule(225);
				while (true)
				{
					int alt225=2;
					try { DebugEnterDecision(225, false);
					int LA225_1 = input.LA(1);

					if ((LA225_1==LT))
					{
						alt225 = 1;
					}


					} finally { DebugExitDecision(225); }
					switch ( alt225 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:614:8: LT
						{
						DebugLocation(614, 8);
						LT395=(IToken)Match(input,LT,Follow._LT_in_primaryExpression6225); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT395);


						}
						break;

					default:
						goto loop225;
					}
				}

				loop225:
					;

				} finally { DebugExitSubRule(225); }

				DebugLocation(614, 12);
				PushFollow(Follow._expression_in_primaryExpression6228);
				expression396=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression396.Tree);
				DebugLocation(614, 23);
				// JavaScript.g:614:23: ( LT )*
				try { DebugEnterSubRule(226);
				while (true)
				{
					int alt226=2;
					try { DebugEnterDecision(226, false);
					int LA226_1 = input.LA(1);

					if ((LA226_1==LT))
					{
						alt226 = 1;
					}


					} finally { DebugExitDecision(226); }
					switch ( alt226 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:614:23: LT
						{
						DebugLocation(614, 23);
						LT397=(IToken)Match(input,LT,Follow._LT_in_primaryExpression6230); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT397);


						}
						break;

					default:
						goto loop226;
					}
				}

				loop226:
					;

				} finally { DebugExitSubRule(226); }

				DebugLocation(614, 27);
				char_literal398=(IToken)Match(input,49,Follow._49_in_primaryExpression6233); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal398);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 614:31: -> expression
				{
					DebugLocation(614, 34);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 76);
			LeaveRule("primaryExpression", 76);
			LeaveRule_primaryExpression();
			if (state.backtracking > 0) { Memoize(input, 76, primaryExpression_StartIndex); }

		}
		DebugLocation(615, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// JavaScript.g:618:1: arrayLiteral : '[' ( LT )* ( assignmentExpression )? ( ( LT )* ',' ( ( LT )* assignmentExpression )? )* ( LT )* ']' -> ^( '[' ( assignmentExpression )* ) ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 77);
		TraceIn("arrayLiteral", 77);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arrayLiteral_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal399 = default(IToken);
		IToken LT400 = default(IToken);
		IToken LT402 = default(IToken);
		IToken char_literal403 = default(IToken);
		IToken LT404 = default(IToken);
		IToken LT406 = default(IToken);
		IToken char_literal407 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression401 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression405 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal399_tree = default(CommonTree);
		CommonTree LT400_tree = default(CommonTree);
		CommonTree LT402_tree = default(CommonTree);
		CommonTree char_literal403_tree = default(CommonTree);
		CommonTree LT404_tree = default(CommonTree);
		CommonTree LT406_tree = default(CommonTree);
		CommonTree char_literal407_tree = default(CommonTree);
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(618, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 77)) { return retval; }

			// JavaScript.g:619:2: ( '[' ( LT )* ( assignmentExpression )? ( ( LT )* ',' ( ( LT )* assignmentExpression )? )* ( LT )* ']' -> ^( '[' ( assignmentExpression )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:619:4: '[' ( LT )* ( assignmentExpression )? ( ( LT )* ',' ( ( LT )* assignmentExpression )? )* ( LT )* ']'
			{
			DebugLocation(619, 4);
			char_literal399=(IToken)Match(input,78,Follow._78_in_arrayLiteral6250); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_78.Add(char_literal399);

			DebugLocation(619, 8);
			// JavaScript.g:619:8: ( LT )*
			try { DebugEnterSubRule(228);
			while (true)
			{
				int alt228=2;
				try { DebugEnterDecision(228, false);
				int LA228_1 = input.LA(1);

				if ((LA228_1==LT))
				{
					int LA228_2 = input.LA(2);

					if ((EvaluatePredicate(synpred280_JavaScript_fragment)))
					{
						alt228 = 1;
					}


				}


				} finally { DebugExitDecision(228); }
				switch ( alt228 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:619:8: LT
					{
					DebugLocation(619, 8);
					LT400=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6252); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT400);


					}
					break;

				default:
					goto loop228;
				}
			}

			loop228:
				;

			} finally { DebugExitSubRule(228); }

			DebugLocation(619, 12);
			// JavaScript.g:619:12: ( assignmentExpression )?
			int alt229=2;
			try { DebugEnterSubRule(229);
			try { DebugEnterDecision(229, false);
			int LA229_1 = input.LA(1);

			if ((LA229_1==Identifier||LA229_1==NumericLiteral||LA229_1==StringLiteral||LA229_1==40||LA229_1==48||(LA229_1>=52 && LA229_1<=53)||(LA229_1>=56 && LA229_1<=57)||LA229_1==78||LA229_1==87||LA229_1==90||LA229_1==93||(LA229_1>=97 && LA229_1<=98)||LA229_1==101||LA229_1==103||LA229_1==105||LA229_1==107||LA229_1==110||LA229_1==115))
			{
				alt229 = 1;
			}
			} finally { DebugExitDecision(229); }
			switch (alt229)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:619:12: assignmentExpression
				{
				DebugLocation(619, 12);
				PushFollow(Follow._assignmentExpression_in_arrayLiteral6255);
				assignmentExpression401=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression401.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(229); }

			DebugLocation(619, 34);
			// JavaScript.g:619:34: ( ( LT )* ',' ( ( LT )* assignmentExpression )? )*
			try { DebugEnterSubRule(233);
			while (true)
			{
				int alt233=2;
				try { DebugEnterDecision(233, false);
				try
				{
					alt233 = dfa233.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(233); }
				switch ( alt233 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:619:35: ( LT )* ',' ( ( LT )* assignmentExpression )?
					{
					DebugLocation(619, 35);
					// JavaScript.g:619:35: ( LT )*
					try { DebugEnterSubRule(230);
					while (true)
					{
						int alt230=2;
						try { DebugEnterDecision(230, false);
						int LA230_1 = input.LA(1);

						if ((LA230_1==LT))
						{
							alt230 = 1;
						}


						} finally { DebugExitDecision(230); }
						switch ( alt230 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:619:35: LT
							{
							DebugLocation(619, 35);
							LT402=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6259); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT402);


							}
							break;

						default:
							goto loop230;
						}
					}

					loop230:
						;

					} finally { DebugExitSubRule(230); }

					DebugLocation(619, 39);
					char_literal403=(IToken)Match(input,55,Follow._55_in_arrayLiteral6262); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal403);

					DebugLocation(619, 43);
					// JavaScript.g:619:43: ( ( LT )* assignmentExpression )?
					int alt232=2;
					try { DebugEnterSubRule(232);
					try { DebugEnterDecision(232, false);
					try
					{
						alt232 = dfa232.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(232); }
					switch (alt232)
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:619:44: ( LT )* assignmentExpression
						{
						DebugLocation(619, 44);
						// JavaScript.g:619:44: ( LT )*
						try { DebugEnterSubRule(231);
						while (true)
						{
							int alt231=2;
							try { DebugEnterDecision(231, false);
							int LA231_1 = input.LA(1);

							if ((LA231_1==LT))
							{
								alt231 = 1;
							}


							} finally { DebugExitDecision(231); }
							switch ( alt231 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:619:44: LT
								{
								DebugLocation(619, 44);
								LT404=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6265); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT404);


								}
								break;

							default:
								goto loop231;
							}
						}

						loop231:
							;

						} finally { DebugExitSubRule(231); }

						DebugLocation(619, 48);
						PushFollow(Follow._assignmentExpression_in_arrayLiteral6268);
						assignmentExpression405=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression405.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(232); }


					}
					break;

				default:
					goto loop233;
				}
			}

			loop233:
				;

			} finally { DebugExitSubRule(233); }

			DebugLocation(619, 73);
			// JavaScript.g:619:73: ( LT )*
			try { DebugEnterSubRule(234);
			while (true)
			{
				int alt234=2;
				try { DebugEnterDecision(234, false);
				int LA234_1 = input.LA(1);

				if ((LA234_1==LT))
				{
					alt234 = 1;
				}


				} finally { DebugExitDecision(234); }
				switch ( alt234 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:619:73: LT
					{
					DebugLocation(619, 73);
					LT406=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6274); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT406);


					}
					break;

				default:
					goto loop234;
				}
			}

			loop234:
				;

			} finally { DebugExitSubRule(234); }

			DebugLocation(619, 77);
			char_literal407=(IToken)Match(input,79,Follow._79_in_arrayLiteral6277); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_79.Add(char_literal407);



			{
			// AST REWRITE
			// elements: 78, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 620:3: -> ^( '[' ( assignmentExpression )* )
			{
				DebugLocation(620, 6);
				// JavaScript.g:620:6: ^( '[' ( assignmentExpression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(620, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ArrayLiteral(stream_78.NextToken()), root_1);

				DebugLocation(620, 31);
				// JavaScript.g:620:31: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(620, 31);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayLiteral", 77);
			LeaveRule("arrayLiteral", 77);
			LeaveRule_arrayLiteral();
			if (state.backtracking > 0) { Memoize(input, 77, arrayLiteral_StartIndex); }

		}
		DebugLocation(621, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// JavaScript.g:624:1: objectLiteral : '{' ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )? ( LT )* '}' -> ^( '{' ( propertyNameAndValue )* ) ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 78);
		TraceIn("objectLiteral", 78);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int objectLiteral_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal408 = default(IToken);
		IToken LT409 = default(IToken);
		IToken LT411 = default(IToken);
		IToken char_literal412 = default(IToken);
		IToken LT413 = default(IToken);
		IToken LT415 = default(IToken);
		IToken char_literal416 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> propertyNameAndValue410 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propertyNameAndValue414 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal408_tree = default(CommonTree);
		CommonTree LT409_tree = default(CommonTree);
		CommonTree LT411_tree = default(CommonTree);
		CommonTree char_literal412_tree = default(CommonTree);
		CommonTree LT413_tree = default(CommonTree);
		CommonTree LT415_tree = default(CommonTree);
		CommonTree char_literal416_tree = default(CommonTree);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_propertyNameAndValue=new RewriteRuleSubtreeStream(adaptor,"rule propertyNameAndValue");
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(624, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 78)) { return retval; }

			// JavaScript.g:625:2: ( '{' ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )? ( LT )* '}' -> ^( '{' ( propertyNameAndValue )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:625:4: '{' ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )? ( LT )* '}'
			{
			DebugLocation(625, 4);
			char_literal408=(IToken)Match(input,110,Follow._110_in_objectLiteral6312); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_110.Add(char_literal408);

			DebugLocation(625, 8);
			// JavaScript.g:625:8: ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )?
			int alt239=2;
			try { DebugEnterSubRule(239);
			try { DebugEnterDecision(239, false);
			try
			{
				alt239 = dfa239.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(239); }
			switch (alt239)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:625:9: ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )*
				{
				DebugLocation(625, 9);
				// JavaScript.g:625:9: ( LT )*
				try { DebugEnterSubRule(235);
				while (true)
				{
					int alt235=2;
					try { DebugEnterDecision(235, false);
					int LA235_1 = input.LA(1);

					if ((LA235_1==LT))
					{
						alt235 = 1;
					}


					} finally { DebugExitDecision(235); }
					switch ( alt235 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:625:9: LT
						{
						DebugLocation(625, 9);
						LT409=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6315); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT409);


						}
						break;

					default:
						goto loop235;
					}
				}

				loop235:
					;

				} finally { DebugExitSubRule(235); }

				DebugLocation(625, 13);
				PushFollow(Follow._propertyNameAndValue_in_objectLiteral6318);
				propertyNameAndValue410=propertyNameAndValue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_propertyNameAndValue.Add(propertyNameAndValue410.Tree);
				DebugLocation(625, 34);
				// JavaScript.g:625:34: ( ( LT )* ',' ( LT )* propertyNameAndValue )*
				try { DebugEnterSubRule(238);
				while (true)
				{
					int alt238=2;
					try { DebugEnterDecision(238, false);
					try
					{
						alt238 = dfa238.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(238); }
					switch ( alt238 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:625:35: ( LT )* ',' ( LT )* propertyNameAndValue
						{
						DebugLocation(625, 35);
						// JavaScript.g:625:35: ( LT )*
						try { DebugEnterSubRule(236);
						while (true)
						{
							int alt236=2;
							try { DebugEnterDecision(236, false);
							int LA236_1 = input.LA(1);

							if ((LA236_1==LT))
							{
								alt236 = 1;
							}


							} finally { DebugExitDecision(236); }
							switch ( alt236 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:625:35: LT
								{
								DebugLocation(625, 35);
								LT411=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6321); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT411);


								}
								break;

							default:
								goto loop236;
							}
						}

						loop236:
							;

						} finally { DebugExitSubRule(236); }

						DebugLocation(625, 39);
						char_literal412=(IToken)Match(input,55,Follow._55_in_objectLiteral6324); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal412);

						DebugLocation(625, 43);
						// JavaScript.g:625:43: ( LT )*
						try { DebugEnterSubRule(237);
						while (true)
						{
							int alt237=2;
							try { DebugEnterDecision(237, false);
							int LA237_1 = input.LA(1);

							if ((LA237_1==LT))
							{
								alt237 = 1;
							}


							} finally { DebugExitDecision(237); }
							switch ( alt237 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:625:43: LT
								{
								DebugLocation(625, 43);
								LT413=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6326); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT413);


								}
								break;

							default:
								goto loop237;
							}
						}

						loop237:
							;

						} finally { DebugExitSubRule(237); }

						DebugLocation(625, 47);
						PushFollow(Follow._propertyNameAndValue_in_objectLiteral6329);
						propertyNameAndValue414=propertyNameAndValue();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_propertyNameAndValue.Add(propertyNameAndValue414.Tree);

						}
						break;

					default:
						goto loop238;
					}
				}

				loop238:
					;

				} finally { DebugExitSubRule(238); }


				}
				break;

			}
			} finally { DebugExitSubRule(239); }

			DebugLocation(625, 72);
			// JavaScript.g:625:72: ( LT )*
			try { DebugEnterSubRule(240);
			while (true)
			{
				int alt240=2;
				try { DebugEnterDecision(240, false);
				int LA240_1 = input.LA(1);

				if ((LA240_1==LT))
				{
					alt240 = 1;
				}


				} finally { DebugExitDecision(240); }
				switch ( alt240 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:625:72: LT
					{
					DebugLocation(625, 72);
					LT415=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6335); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT415);


					}
					break;

				default:
					goto loop240;
				}
			}

			loop240:
				;

			} finally { DebugExitSubRule(240); }

			DebugLocation(625, 76);
			char_literal416=(IToken)Match(input,114,Follow._114_in_objectLiteral6338); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_114.Add(char_literal416);



			{
			// AST REWRITE
			// elements: 110, propertyNameAndValue
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 626:3: -> ^( '{' ( propertyNameAndValue )* )
			{
				DebugLocation(626, 6);
				// JavaScript.g:626:6: ^( '{' ( propertyNameAndValue )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(626, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ObjectLiteral(stream_110.NextToken()), root_1);

				DebugLocation(626, 32);
				// JavaScript.g:626:32: ( propertyNameAndValue )*
				while ( stream_propertyNameAndValue.HasNext )
				{
					DebugLocation(626, 32);
					adaptor.AddChild(root_1, stream_propertyNameAndValue.NextTree());

				}
				stream_propertyNameAndValue.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectLiteral", 78);
			LeaveRule("objectLiteral", 78);
			LeaveRule_objectLiteral();
			if (state.backtracking > 0) { Memoize(input, 78, objectLiteral_StartIndex); }

		}
		DebugLocation(627, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_propertyNameAndValue();
	partial void LeaveRule_propertyNameAndValue();
	// $ANTLR start "propertyNameAndValue"
	// JavaScript.g:629:1: propertyNameAndValue : propertyName ( LT )* ':' ( LT )* assignmentExpression -> ^( ':' propertyName assignmentExpression ) ;
	[GrammarRule("propertyNameAndValue")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyNameAndValue()
	{
		EnterRule_propertyNameAndValue();
		EnterRule("propertyNameAndValue", 79);
		TraceIn("propertyNameAndValue", 79);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyNameAndValue_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT418 = default(IToken);
		IToken char_literal419 = default(IToken);
		IToken LT420 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> propertyName417 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression421 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT418_tree = default(CommonTree);
		CommonTree char_literal419_tree = default(CommonTree);
		CommonTree LT420_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_propertyName=new RewriteRuleSubtreeStream(adaptor,"rule propertyName");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "propertyNameAndValue");
		DebugLocation(629, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 79)) { return retval; }

			// JavaScript.g:630:2: ( propertyName ( LT )* ':' ( LT )* assignmentExpression -> ^( ':' propertyName assignmentExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:630:4: propertyName ( LT )* ':' ( LT )* assignmentExpression
			{
			DebugLocation(630, 4);
			PushFollow(Follow._propertyName_in_propertyNameAndValue6366);
			propertyName417=propertyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_propertyName.Add(propertyName417.Tree);
			DebugLocation(630, 17);
			// JavaScript.g:630:17: ( LT )*
			try { DebugEnterSubRule(241);
			while (true)
			{
				int alt241=2;
				try { DebugEnterDecision(241, false);
				int LA241_1 = input.LA(1);

				if ((LA241_1==LT))
				{
					alt241 = 1;
				}


				} finally { DebugExitDecision(241); }
				switch ( alt241 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:630:17: LT
					{
					DebugLocation(630, 17);
					LT418=(IToken)Match(input,LT,Follow._LT_in_propertyNameAndValue6368); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT418);


					}
					break;

				default:
					goto loop241;
				}
			}

			loop241:
				;

			} finally { DebugExitSubRule(241); }

			DebugLocation(630, 21);
			char_literal419=(IToken)Match(input,62,Follow._62_in_propertyNameAndValue6371); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal419);

			DebugLocation(630, 25);
			// JavaScript.g:630:25: ( LT )*
			try { DebugEnterSubRule(242);
			while (true)
			{
				int alt242=2;
				try { DebugEnterDecision(242, false);
				int LA242_1 = input.LA(1);

				if ((LA242_1==LT))
				{
					alt242 = 1;
				}


				} finally { DebugExitDecision(242); }
				switch ( alt242 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:630:25: LT
					{
					DebugLocation(630, 25);
					LT420=(IToken)Match(input,LT,Follow._LT_in_propertyNameAndValue6373); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT420);


					}
					break;

				default:
					goto loop242;
				}
			}

			loop242:
				;

			} finally { DebugExitSubRule(242); }

			DebugLocation(630, 29);
			PushFollow(Follow._assignmentExpression_in_propertyNameAndValue6376);
			assignmentExpression421=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression421.Tree);


			{
			// AST REWRITE
			// elements: 62, propertyName, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 631:3: -> ^( ':' propertyName assignmentExpression )
			{
				DebugLocation(631, 6);
				// JavaScript.g:631:6: ^( ':' propertyName assignmentExpression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(631, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new PropertyAssignment(stream_62.NextToken()), root_1);

				DebugLocation(631, 37);
				adaptor.AddChild(root_1, stream_propertyName.NextTree());
				DebugLocation(631, 50);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyNameAndValue", 79);
			LeaveRule("propertyNameAndValue", 79);
			LeaveRule_propertyNameAndValue();
			if (state.backtracking > 0) { Memoize(input, 79, propertyNameAndValue_StartIndex); }

		}
		DebugLocation(632, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyNameAndValue"); }
		return retval;

	}
	// $ANTLR end "propertyNameAndValue"

	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();
	// $ANTLR start "propertyName"
	// JavaScript.g:634:1: propertyName : ( Identifier -> Identifier | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral );
	[GrammarRule("propertyName")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 80);
		TraceIn("propertyName", 80);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyName_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier422 = default(IToken);
		IToken StringLiteral423 = default(IToken);
		IToken NumericLiteral424 = default(IToken);

		CommonTree Identifier422_tree = default(CommonTree);
		CommonTree StringLiteral423_tree = default(CommonTree);
		CommonTree NumericLiteral424_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_StringLiteral=new RewriteRuleITokenStream(adaptor,"token StringLiteral");
		RewriteRuleITokenStream stream_NumericLiteral=new RewriteRuleITokenStream(adaptor,"token NumericLiteral");
		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(634, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 80)) { return retval; }

			// JavaScript.g:635:2: ( Identifier -> Identifier | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral )
			int alt243=3;
			try { DebugEnterDecision(243, false);
			switch (input.LA(1))
			{
			case Identifier:
				{
				alt243 = 1;
				}
				break;
			case StringLiteral:
				{
				alt243 = 2;
				}
				break;
			case NumericLiteral:
				{
				alt243 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 243, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(243); }
			switch (alt243)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:635:4: Identifier
				{
				DebugLocation(635, 4);
				Identifier422=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyName6405); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier422);



				{
				// AST REWRITE
				// elements: Identifier
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 635:16: -> Identifier
				{
					DebugLocation(635, 19);
					adaptor.AddChild(root_0, new Identifier(stream_Identifier.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:636:4: StringLiteral
				{
				DebugLocation(636, 4);
				StringLiteral423=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_propertyName6420); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_StringLiteral.Add(StringLiteral423);



				{
				// AST REWRITE
				// elements: StringLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 636:19: -> StringLiteral
				{
					DebugLocation(636, 22);
					adaptor.AddChild(root_0, new StringLiteral(stream_StringLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:637:4: NumericLiteral
				{
				DebugLocation(637, 4);
				NumericLiteral424=(IToken)Match(input,NumericLiteral,Follow._NumericLiteral_in_propertyName6435); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NumericLiteral.Add(NumericLiteral424);



				{
				// AST REWRITE
				// elements: NumericLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 637:19: -> NumericLiteral
				{
					DebugLocation(637, 22);
					adaptor.AddChild(root_0, new NumericLiteral(stream_NumericLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyName", 80);
			LeaveRule("propertyName", 80);
			LeaveRule_propertyName();
			if (state.backtracking > 0) { Memoize(input, 80, propertyName_StartIndex); }

		}
		DebugLocation(638, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return retval;

	}
	// $ANTLR end "propertyName"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// JavaScript.g:641:1: literal : ( 'null' -> 'null' | 'true' -> 'true' | 'false' -> 'false' | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 81);
		TraceIn("literal", 81);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int literal_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal425 = default(IToken);
		IToken string_literal426 = default(IToken);
		IToken string_literal427 = default(IToken);
		IToken StringLiteral428 = default(IToken);
		IToken NumericLiteral429 = default(IToken);

		CommonTree string_literal425_tree = default(CommonTree);
		CommonTree string_literal426_tree = default(CommonTree);
		CommonTree string_literal427_tree = default(CommonTree);
		CommonTree StringLiteral428_tree = default(CommonTree);
		CommonTree NumericLiteral429_tree = default(CommonTree);
		RewriteRuleITokenStream stream_98=new RewriteRuleITokenStream(adaptor,"token 98");
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleITokenStream stream_90=new RewriteRuleITokenStream(adaptor,"token 90");
		RewriteRuleITokenStream stream_StringLiteral=new RewriteRuleITokenStream(adaptor,"token StringLiteral");
		RewriteRuleITokenStream stream_NumericLiteral=new RewriteRuleITokenStream(adaptor,"token NumericLiteral");
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(641, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 81)) { return retval; }

			// JavaScript.g:642:2: ( 'null' -> 'null' | 'true' -> 'true' | 'false' -> 'false' | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral )
			int alt244=5;
			try { DebugEnterDecision(244, false);
			switch (input.LA(1))
			{
			case 98:
				{
				alt244 = 1;
				}
				break;
			case 103:
				{
				alt244 = 2;
				}
				break;
			case 90:
				{
				alt244 = 3;
				}
				break;
			case StringLiteral:
				{
				alt244 = 4;
				}
				break;
			case NumericLiteral:
				{
				alt244 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 244, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(244); }
			switch (alt244)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:642:4: 'null'
				{
				DebugLocation(642, 4);
				string_literal425=(IToken)Match(input,98,Follow._98_in_literal6456); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_98.Add(string_literal425);



				{
				// AST REWRITE
				// elements: 98
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 642:13: -> 'null'
				{
					DebugLocation(642, 16);
					adaptor.AddChild(root_0, new NullLiteral(stream_98.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:643:4: 'true'
				{
				DebugLocation(643, 4);
				string_literal426=(IToken)Match(input,103,Follow._103_in_literal6472); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_103.Add(string_literal426);



				{
				// AST REWRITE
				// elements: 103
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 643:13: -> 'true'
				{
					DebugLocation(643, 16);
					adaptor.AddChild(root_0, new TrueLiteral(stream_103.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:644:4: 'false'
				{
				DebugLocation(644, 4);
				string_literal427=(IToken)Match(input,90,Follow._90_in_literal6488); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_90.Add(string_literal427);



				{
				// AST REWRITE
				// elements: 90
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 644:14: -> 'false'
				{
					DebugLocation(644, 17);
					adaptor.AddChild(root_0, new FalseLiteral(stream_90.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:645:4: StringLiteral
				{
				DebugLocation(645, 4);
				StringLiteral428=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_literal6504); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_StringLiteral.Add(StringLiteral428);



				{
				// AST REWRITE
				// elements: StringLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 645:19: -> StringLiteral
				{
					DebugLocation(645, 22);
					adaptor.AddChild(root_0, new StringLiteral(stream_StringLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:646:4: NumericLiteral
				{
				DebugLocation(646, 4);
				NumericLiteral429=(IToken)Match(input,NumericLiteral,Follow._NumericLiteral_in_literal6519); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NumericLiteral.Add(NumericLiteral429);



				{
				// AST REWRITE
				// elements: NumericLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 646:19: -> NumericLiteral
				{
					DebugLocation(646, 22);
					adaptor.AddChild(root_0, new NumericLiteral(stream_NumericLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 81);
			LeaveRule("literal", 81);
			LeaveRule_literal();
			if (state.backtracking > 0) { Memoize(input, 81, literal_StartIndex); }

		}
		DebugLocation(647, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"

	partial void EnterRule_synpred5_JavaScript_fragment();
	partial void LeaveRule_synpred5_JavaScript_fragment();

	// $ANTLR start synpred5_JavaScript
	public void synpred5_JavaScript_fragment()
	{
		EnterRule_synpred5_JavaScript_fragment();
		EnterRule("synpred5_JavaScript_fragment", 86);
		TraceIn("synpred5_JavaScript_fragment", 86);
		try
		{
			// JavaScript.g:44:4: ( functionDeclaration )
			DebugEnterAlt(1);
			// JavaScript.g:44:4: functionDeclaration
			{
			DebugLocation(44, 4);
			PushFollow(Follow._functionDeclaration_in_synpred5_JavaScript187);
			functionDeclaration();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_JavaScript_fragment", 86);
			LeaveRule("synpred5_JavaScript_fragment", 86);
			LeaveRule_synpred5_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred5_JavaScript

	partial void EnterRule_synpred9_JavaScript_fragment();
	partial void LeaveRule_synpred9_JavaScript_fragment();

	// $ANTLR start synpred9_JavaScript
	public void synpred9_JavaScript_fragment()
	{
		EnterRule_synpred9_JavaScript_fragment();
		EnterRule("synpred9_JavaScript_fragment", 90);
		TraceIn("synpred9_JavaScript_fragment", 90);
		try
		{
			// JavaScript.g:58:15: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:58:15: LT
			{
			DebugLocation(58, 15);
			Match(input,LT,Follow._LT_in_synpred9_JavaScript274); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_JavaScript_fragment", 90);
			LeaveRule("synpred9_JavaScript_fragment", 90);
			LeaveRule_synpred9_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred9_JavaScript

	partial void EnterRule_synpred21_JavaScript_fragment();
	partial void LeaveRule_synpred21_JavaScript_fragment();

	// $ANTLR start synpred21_JavaScript
	public void synpred21_JavaScript_fragment()
	{
		EnterRule_synpred21_JavaScript_fragment();
		EnterRule("synpred21_JavaScript_fragment", 102);
		TraceIn("synpred21_JavaScript_fragment", 102);
		try
		{
			// JavaScript.g:76:4: ( statementBlock )
			DebugEnterAlt(1);
			// JavaScript.g:76:4: statementBlock
			{
			DebugLocation(76, 4);
			PushFollow(Follow._statementBlock_in_synpred21_JavaScript430);
			statementBlock();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred21_JavaScript_fragment", 102);
			LeaveRule("synpred21_JavaScript_fragment", 102);
			LeaveRule_synpred21_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred21_JavaScript

	partial void EnterRule_synpred24_JavaScript_fragment();
	partial void LeaveRule_synpred24_JavaScript_fragment();

	// $ANTLR start synpred24_JavaScript
	public void synpred24_JavaScript_fragment()
	{
		EnterRule_synpred24_JavaScript_fragment();
		EnterRule("synpred24_JavaScript_fragment", 105);
		TraceIn("synpred24_JavaScript_fragment", 105);
		try
		{
			// JavaScript.g:79:4: ( expressionStatement )
			DebugEnterAlt(1);
			// JavaScript.g:79:4: expressionStatement
			{
			DebugLocation(79, 4);
			PushFollow(Follow._expressionStatement_in_synpred24_JavaScript445);
			expressionStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred24_JavaScript_fragment", 105);
			LeaveRule("synpred24_JavaScript_fragment", 105);
			LeaveRule_synpred24_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred24_JavaScript

	partial void EnterRule_synpred31_JavaScript_fragment();
	partial void LeaveRule_synpred31_JavaScript_fragment();

	// $ANTLR start synpred31_JavaScript
	public void synpred31_JavaScript_fragment()
	{
		EnterRule_synpred31_JavaScript_fragment();
		EnterRule("synpred31_JavaScript_fragment", 112);
		TraceIn("synpred31_JavaScript_fragment", 112);
		try
		{
			// JavaScript.g:86:4: ( labelledStatement )
			DebugEnterAlt(1);
			// JavaScript.g:86:4: labelledStatement
			{
			DebugLocation(86, 4);
			PushFollow(Follow._labelledStatement_in_synpred31_JavaScript480);
			labelledStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred31_JavaScript_fragment", 112);
			LeaveRule("synpred31_JavaScript_fragment", 112);
			LeaveRule_synpred31_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred31_JavaScript

	partial void EnterRule_synpred34_JavaScript_fragment();
	partial void LeaveRule_synpred34_JavaScript_fragment();

	// $ANTLR start synpred34_JavaScript
	public void synpred34_JavaScript_fragment()
	{
		EnterRule_synpred34_JavaScript_fragment();
		EnterRule("synpred34_JavaScript_fragment", 115);
		TraceIn("synpred34_JavaScript_fragment", 115);
		try
		{
			// JavaScript.g:93:8: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:93:8: LT
			{
			DebugLocation(93, 8);
			Match(input,LT,Follow._LT_in_synpred34_JavaScript509); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred34_JavaScript_fragment", 115);
			LeaveRule("synpred34_JavaScript_fragment", 115);
			LeaveRule_synpred34_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred34_JavaScript

	partial void EnterRule_synpred47_JavaScript_fragment();
	partial void LeaveRule_synpred47_JavaScript_fragment();

	// $ANTLR start synpred47_JavaScript
	public void synpred47_JavaScript_fragment()
	{
		EnterRule_synpred47_JavaScript_fragment();
		EnterRule("synpred47_JavaScript_fragment", 128);
		TraceIn("synpred47_JavaScript_fragment", 128);
		try
		{
			// JavaScript.g:114:15: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:114:15: LT
			{
			DebugLocation(114, 15);
			Match(input,LT,Follow._LT_in_synpred47_JavaScript668); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred47_JavaScript_fragment", 128);
			LeaveRule("synpred47_JavaScript_fragment", 128);
			LeaveRule_synpred47_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred47_JavaScript

	partial void EnterRule_synpred49_JavaScript_fragment();
	partial void LeaveRule_synpred49_JavaScript_fragment();

	// $ANTLR start synpred49_JavaScript
	public void synpred49_JavaScript_fragment()
	{
		EnterRule_synpred49_JavaScript_fragment();
		EnterRule("synpred49_JavaScript_fragment", 130);
		TraceIn("synpred49_JavaScript_fragment", 130);
		try
		{
			// JavaScript.g:121:15: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:121:15: LT
			{
			DebugLocation(121, 15);
			Match(input,LT,Follow._LT_in_synpred49_JavaScript720); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred49_JavaScript_fragment", 130);
			LeaveRule("synpred49_JavaScript_fragment", 130);
			LeaveRule_synpred49_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred49_JavaScript

	partial void EnterRule_synpred60_JavaScript_fragment();
	partial void LeaveRule_synpred60_JavaScript_fragment();

	// $ANTLR start synpred60_JavaScript
	public void synpred60_JavaScript_fragment()
	{
		AstParserRuleReturnScope<CommonTree, IToken> elsestmt = default(AstParserRuleReturnScope<CommonTree, IToken>);

		EnterRule_synpred60_JavaScript_fragment();
		EnterRule("synpred60_JavaScript_fragment", 141);
		TraceIn("synpred60_JavaScript_fragment", 141);
		try
		{
			// JavaScript.g:144:62: ( ( LT )* 'else' ( LT )* elsestmt= statement )
			DebugEnterAlt(1);
			// JavaScript.g:144:62: ( LT )* 'else' ( LT )* elsestmt= statement
			{
			DebugLocation(144, 62);
			// JavaScript.g:144:62: ( LT )*
			try { DebugEnterSubRule(257);
			while (true)
			{
				int alt257=2;
				try { DebugEnterDecision(257, false);
				int LA257_1 = input.LA(1);

				if ((LA257_1==LT))
				{
					alt257 = 1;
				}


				} finally { DebugExitDecision(257); }
				switch ( alt257 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:62: LT
					{
					DebugLocation(144, 62);
					Match(input,LT,Follow._LT_in_synpred60_JavaScript883); if (state.failed) return;

					}
					break;

				default:
					goto loop257;
				}
			}

			loop257:
				;

			} finally { DebugExitSubRule(257); }

			DebugLocation(144, 66);
			Match(input,89,Follow._89_in_synpred60_JavaScript886); if (state.failed) return;
			DebugLocation(144, 73);
			// JavaScript.g:144:73: ( LT )*
			try { DebugEnterSubRule(258);
			while (true)
			{
				int alt258=2;
				try { DebugEnterDecision(258, false);
				int LA258_1 = input.LA(1);

				if ((LA258_1==LT))
				{
					alt258 = 1;
				}


				} finally { DebugExitDecision(258); }
				switch ( alt258 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:73: LT
					{
					DebugLocation(144, 73);
					Match(input,LT,Follow._LT_in_synpred60_JavaScript888); if (state.failed) return;

					}
					break;

				default:
					goto loop258;
				}
			}

			loop258:
				;

			} finally { DebugExitSubRule(258); }

			DebugLocation(144, 85);
			PushFollow(Follow._statement_in_synpred60_JavaScript893);
			elsestmt=statement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred60_JavaScript_fragment", 141);
			LeaveRule("synpred60_JavaScript_fragment", 141);
			LeaveRule_synpred60_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred60_JavaScript

	partial void EnterRule_synpred63_JavaScript_fragment();
	partial void LeaveRule_synpred63_JavaScript_fragment();

	// $ANTLR start synpred63_JavaScript
	public void synpred63_JavaScript_fragment()
	{
		EnterRule_synpred63_JavaScript_fragment();
		EnterRule("synpred63_JavaScript_fragment", 144);
		TraceIn("synpred63_JavaScript_fragment", 144);
		try
		{
			// JavaScript.g:151:4: ( forStatement )
			DebugEnterAlt(1);
			// JavaScript.g:151:4: forStatement
			{
			DebugLocation(151, 4);
			PushFollow(Follow._forStatement_in_synpred63_JavaScript939);
			forStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred63_JavaScript_fragment", 144);
			LeaveRule("synpred63_JavaScript_fragment", 144);
			LeaveRule_synpred63_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred63_JavaScript

	partial void EnterRule_synpred118_JavaScript_fragment();
	partial void LeaveRule_synpred118_JavaScript_fragment();

	// $ANTLR start synpred118_JavaScript
	public void synpred118_JavaScript_fragment()
	{
		EnterRule_synpred118_JavaScript_fragment();
		EnterRule("synpred118_JavaScript_fragment", 199);
		TraceIn("synpred118_JavaScript_fragment", 199);
		try
		{
			// JavaScript.g:226:34: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:226:34: LT
			{
			DebugLocation(226, 34);
			Match(input,LT,Follow._LT_in_synpred118_JavaScript1675); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred118_JavaScript_fragment", 199);
			LeaveRule("synpred118_JavaScript_fragment", 199);
			LeaveRule_synpred118_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred118_JavaScript

	partial void EnterRule_synpred121_JavaScript_fragment();
	partial void LeaveRule_synpred121_JavaScript_fragment();

	// $ANTLR start synpred121_JavaScript
	public void synpred121_JavaScript_fragment()
	{
		EnterRule_synpred121_JavaScript_fragment();
		EnterRule("synpred121_JavaScript_fragment", 202);
		TraceIn("synpred121_JavaScript_fragment", 202);
		try
		{
			// JavaScript.g:230:22: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:230:22: LT
			{
			DebugLocation(230, 22);
			Match(input,LT,Follow._LT_in_synpred121_JavaScript1714); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred121_JavaScript_fragment", 202);
			LeaveRule("synpred121_JavaScript_fragment", 202);
			LeaveRule_synpred121_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred121_JavaScript

	partial void EnterRule_synpred140_JavaScript_fragment();
	partial void LeaveRule_synpred140_JavaScript_fragment();

	// $ANTLR start synpred140_JavaScript
	public void synpred140_JavaScript_fragment()
	{
		EnterRule_synpred140_JavaScript_fragment();
		EnterRule("synpred140_JavaScript_fragment", 221);
		TraceIn("synpred140_JavaScript_fragment", 221);
		try
		{
			// JavaScript.g:261:4: ( conditionalExpression )
			DebugEnterAlt(1);
			// JavaScript.g:261:4: conditionalExpression
			{
			DebugLocation(261, 4);
			PushFollow(Follow._conditionalExpression_in_synpred140_JavaScript1985);
			conditionalExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred140_JavaScript_fragment", 221);
			LeaveRule("synpred140_JavaScript_fragment", 221);
			LeaveRule_synpred140_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred140_JavaScript

	partial void EnterRule_synpred143_JavaScript_fragment();
	partial void LeaveRule_synpred143_JavaScript_fragment();

	// $ANTLR start synpred143_JavaScript
	public void synpred143_JavaScript_fragment()
	{
		EnterRule_synpred143_JavaScript_fragment();
		EnterRule("synpred143_JavaScript_fragment", 224);
		TraceIn("synpred143_JavaScript_fragment", 224);
		try
		{
			// JavaScript.g:279:4: ( conditionalExpressionNoIn )
			DebugEnterAlt(1);
			// JavaScript.g:279:4: conditionalExpressionNoIn
			{
			DebugLocation(279, 4);
			PushFollow(Follow._conditionalExpressionNoIn_in_synpred143_JavaScript2297);
			conditionalExpressionNoIn();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred143_JavaScript_fragment", 224);
			LeaveRule("synpred143_JavaScript_fragment", 224);
			LeaveRule_synpred143_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred143_JavaScript

	partial void EnterRule_synpred157_JavaScript_fragment();
	partial void LeaveRule_synpred157_JavaScript_fragment();

	// $ANTLR start synpred157_JavaScript
	public void synpred157_JavaScript_fragment()
	{
		EnterRule_synpred157_JavaScript_fragment();
		EnterRule("synpred157_JavaScript_fragment", 238);
		TraceIn("synpred157_JavaScript_fragment", 238);
		try
		{
			// JavaScript.g:301:4: ( callExpression )
			DebugEnterAlt(1);
			// JavaScript.g:301:4: callExpression
			{
			DebugLocation(301, 4);
			PushFollow(Follow._callExpression_in_synpred157_JavaScript2663);
			callExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred157_JavaScript_fragment", 238);
			LeaveRule("synpred157_JavaScript_fragment", 238);
			LeaveRule_synpred157_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred157_JavaScript

	partial void EnterRule_synpred158_JavaScript_fragment();
	partial void LeaveRule_synpred158_JavaScript_fragment();

	// $ANTLR start synpred158_JavaScript
	public void synpred158_JavaScript_fragment()
	{
		EnterRule_synpred158_JavaScript_fragment();
		EnterRule("synpred158_JavaScript_fragment", 239);
		TraceIn("synpred158_JavaScript_fragment", 239);
		try
		{
			// JavaScript.g:306:4: ( memberExpression )
			DebugEnterAlt(1);
			// JavaScript.g:306:4: memberExpression
			{
			DebugLocation(306, 4);
			PushFollow(Follow._memberExpression_in_synpred158_JavaScript2680);
			memberExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred158_JavaScript_fragment", 239);
			LeaveRule("synpred158_JavaScript_fragment", 239);
			LeaveRule_synpred158_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred158_JavaScript

	partial void EnterRule_synpred162_JavaScript_fragment();
	partial void LeaveRule_synpred162_JavaScript_fragment();

	// $ANTLR start synpred162_JavaScript
	public void synpred162_JavaScript_fragment()
	{
		EnterRule_synpred162_JavaScript_fragment();
		EnterRule("synpred162_JavaScript_fragment", 243);
		TraceIn("synpred162_JavaScript_fragment", 243);
		try
		{
			// JavaScript.g:314:13: ( ( LT )* ( indexSuffix | propertyReferenceSuffix ) )
			DebugEnterAlt(1);
			// JavaScript.g:314:13: ( LT )* ( indexSuffix | propertyReferenceSuffix )
			{
			DebugLocation(314, 13);
			// JavaScript.g:314:13: ( LT )*
			try { DebugEnterSubRule(272);
			while (true)
			{
				int alt272=2;
				try { DebugEnterDecision(272, false);
				int LA272_1 = input.LA(1);

				if ((LA272_1==LT))
				{
					alt272 = 1;
				}


				} finally { DebugExitDecision(272); }
				switch ( alt272 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:314:13: LT
					{
					DebugLocation(314, 13);
					Match(input,LT,Follow._LT_in_synpred162_JavaScript2756); if (state.failed) return;

					}
					break;

				default:
					goto loop272;
				}
			}

			loop272:
				;

			} finally { DebugExitSubRule(272); }

			DebugLocation(315, 13);
			// JavaScript.g:315:13: ( indexSuffix | propertyReferenceSuffix )
			int alt273=2;
			try { DebugEnterSubRule(273);
			try { DebugEnterDecision(273, false);
			int LA273_1 = input.LA(1);

			if ((LA273_1==78))
			{
				alt273 = 1;
			}
			else if ((LA273_1==59))
			{
				alt273 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 273, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(273); }
			switch (alt273)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:316:17: indexSuffix
				{
				DebugLocation(316, 17);
				PushFollow(Follow._indexSuffix_in_synpred162_JavaScript2790);
				indexSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:317:19: propertyReferenceSuffix
				{
				DebugLocation(317, 19);
				PushFollow(Follow._propertyReferenceSuffix_in_synpred162_JavaScript2854);
				propertyReferenceSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(273); }


			}

		}
		finally
		{
			TraceOut("synpred162_JavaScript_fragment", 243);
			LeaveRule("synpred162_JavaScript_fragment", 243);
			LeaveRule_synpred162_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred162_JavaScript

	partial void EnterRule_synpred170_JavaScript_fragment();
	partial void LeaveRule_synpred170_JavaScript_fragment();

	// $ANTLR start synpred170_JavaScript
	public void synpred170_JavaScript_fragment()
	{
		AstParserRuleReturnScope<CommonTree, IToken> args = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> idx = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> prop = default(AstParserRuleReturnScope<CommonTree, IToken>);

		EnterRule_synpred170_JavaScript_fragment();
		EnterRule("synpred170_JavaScript_fragment", 251);
		TraceIn("synpred170_JavaScript_fragment", 251);
		try
		{
			// JavaScript.g:332:13: ( ( LT )* (args= arguments |idx= indexSuffix |prop= propertyReferenceSuffix ) )
			DebugEnterAlt(1);
			// JavaScript.g:332:13: ( LT )* (args= arguments |idx= indexSuffix |prop= propertyReferenceSuffix )
			{
			DebugLocation(332, 13);
			// JavaScript.g:332:13: ( LT )*
			try { DebugEnterSubRule(274);
			while (true)
			{
				int alt274=2;
				try { DebugEnterDecision(274, false);
				int LA274_1 = input.LA(1);

				if ((LA274_1==LT))
				{
					alt274 = 1;
				}


				} finally { DebugExitDecision(274); }
				switch ( alt274 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:332:13: LT
					{
					DebugLocation(332, 13);
					Match(input,LT,Follow._LT_in_synpred170_JavaScript3073); if (state.failed) return;

					}
					break;

				default:
					goto loop274;
				}
			}

			loop274:
				;

			} finally { DebugExitSubRule(274); }

			DebugLocation(333, 13);
			// JavaScript.g:333:13: (args= arguments |idx= indexSuffix |prop= propertyReferenceSuffix )
			int alt275=3;
			try { DebugEnterSubRule(275);
			try { DebugEnterDecision(275, false);
			switch (input.LA(1))
			{
			case 48:
				{
				alt275 = 1;
				}
				break;
			case 78:
				{
				alt275 = 2;
				}
				break;
			case 59:
				{
				alt275 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 275, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(275); }
			switch (alt275)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:334:17: args= arguments
				{
				DebugLocation(334, 21);
				PushFollow(Follow._arguments_in_synpred170_JavaScript3109);
				args=arguments();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:335:16: idx= indexSuffix
				{
				DebugLocation(335, 19);
				PushFollow(Follow._indexSuffix_in_synpred170_JavaScript3162);
				idx=indexSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:336:16: prop= propertyReferenceSuffix
				{
				DebugLocation(336, 20);
				PushFollow(Follow._propertyReferenceSuffix_in_synpred170_JavaScript3212);
				prop=propertyReferenceSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(275); }


			}

		}
		finally
		{
			TraceOut("synpred170_JavaScript_fragment", 251);
			LeaveRule("synpred170_JavaScript_fragment", 251);
			LeaveRule_synpred170_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred170_JavaScript

	partial void EnterRule_synpred256_JavaScript_fragment();
	partial void LeaveRule_synpred256_JavaScript_fragment();

	// $ANTLR start synpred256_JavaScript
	public void synpred256_JavaScript_fragment()
	{
		IToken op = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add = default(AstParserRuleReturnScope<CommonTree, IToken>);

		EnterRule_synpred256_JavaScript_fragment();
		EnterRule("synpred256_JavaScript_fragment", 337);
		TraceIn("synpred256_JavaScript_fragment", 337);
		try
		{
			// JavaScript.g:559:7: ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )
			DebugEnterAlt(1);
			// JavaScript.g:559:7: ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression
			{
			DebugLocation(559, 7);
			// JavaScript.g:559:7: ( LT )*
			try { DebugEnterSubRule(323);
			while (true)
			{
				int alt323=2;
				try { DebugEnterDecision(323, false);
				int LA323_1 = input.LA(1);

				if ((LA323_1==LT))
				{
					alt323 = 1;
				}


				} finally { DebugExitDecision(323); }
				switch ( alt323 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:559:7: LT
					{
					DebugLocation(559, 7);
					Match(input,LT,Follow._LT_in_synpred256_JavaScript5397); if (state.failed) return;

					}
					break;

				default:
					goto loop323;
				}
			}

			loop323:
				;

			} finally { DebugExitSubRule(323); }

			DebugLocation(559, 11);
			// JavaScript.g:559:11: (op= '+' |op= '-' )
			int alt324=2;
			try { DebugEnterSubRule(324);
			try { DebugEnterDecision(324, false);
			int LA324_1 = input.LA(1);

			if ((LA324_1==52))
			{
				alt324 = 1;
			}
			else if ((LA324_1==56))
			{
				alt324 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 324, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(324); }
			switch (alt324)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:559:12: op= '+'
				{
				DebugLocation(559, 14);
				op=(IToken)Match(input,52,Follow._52_in_synpred256_JavaScript5403); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:559:21: op= '-'
				{
				DebugLocation(559, 23);
				op=(IToken)Match(input,56,Follow._56_in_synpred256_JavaScript5409); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(324); }

			DebugLocation(559, 29);
			// JavaScript.g:559:29: ( LT )*
			try { DebugEnterSubRule(325);
			while (true)
			{
				int alt325=2;
				try { DebugEnterDecision(325, false);
				int LA325_1 = input.LA(1);

				if ((LA325_1==LT))
				{
					alt325 = 1;
				}


				} finally { DebugExitDecision(325); }
				switch ( alt325 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:559:29: LT
					{
					DebugLocation(559, 29);
					Match(input,LT,Follow._LT_in_synpred256_JavaScript5412); if (state.failed) return;

					}
					break;

				default:
					goto loop325;
				}
			}

			loop325:
				;

			} finally { DebugExitSubRule(325); }

			DebugLocation(559, 36);
			PushFollow(Follow._additiveExpression_in_synpred256_JavaScript5417);
			add=additiveExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred256_JavaScript_fragment", 337);
			LeaveRule("synpred256_JavaScript_fragment", 337);
			LeaveRule_synpred256_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred256_JavaScript

	partial void EnterRule_synpred280_JavaScript_fragment();
	partial void LeaveRule_synpred280_JavaScript_fragment();

	// $ANTLR start synpred280_JavaScript
	public void synpred280_JavaScript_fragment()
	{
		EnterRule_synpred280_JavaScript_fragment();
		EnterRule("synpred280_JavaScript_fragment", 361);
		TraceIn("synpred280_JavaScript_fragment", 361);
		try
		{
			// JavaScript.g:619:8: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:619:8: LT
			{
			DebugLocation(619, 8);
			Match(input,LT,Follow._LT_in_synpred280_JavaScript6252); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred280_JavaScript_fragment", 361);
			LeaveRule("synpred280_JavaScript_fragment", 361);
			LeaveRule_synpred280_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred280_JavaScript
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA4 dfa4;
	private DFA17 dfa17;
	private DFA16 dfa16;
	private DFA26 dfa26;
	private DFA31 dfa31;
	private DFA34 dfa34;
	private DFA60 dfa60;
	private DFA63 dfa63;
	private DFA66 dfa66;
	private DFA96 dfa96;
	private DFA100 dfa100;
	private DFA99 dfa99;
	private DFA113 dfa113;
	private DFA122 dfa122;
	private DFA125 dfa125;
	private DFA149 dfa149;
	private DFA148 dfa148;
	private DFA158 dfa158;
	private DFA163 dfa163;
	private DFA166 dfa166;
	private DFA169 dfa169;
	private DFA172 dfa172;
	private DFA175 dfa175;
	private DFA178 dfa178;
	private DFA181 dfa181;
	private DFA184 dfa184;
	private DFA187 dfa187;
	private DFA190 dfa190;
	private DFA193 dfa193;
	private DFA197 dfa197;
	private DFA201 dfa201;
	private DFA205 dfa205;
	private DFA209 dfa209;
	private DFA213 dfa213;
	private DFA221 dfa221;
	private DFA233 dfa233;
	private DFA232 dfa232;
	private DFA239 dfa239;
	private DFA238 dfa238;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa4 = new DFA4( this );
		dfa17 = new DFA17( this );
		dfa16 = new DFA16( this );
		dfa26 = new DFA26( this );
		dfa31 = new DFA31( this );
		dfa34 = new DFA34( this );
		dfa60 = new DFA60( this );
		dfa63 = new DFA63( this );
		dfa66 = new DFA66( this );
		dfa96 = new DFA96( this );
		dfa100 = new DFA100( this );
		dfa99 = new DFA99( this );
		dfa113 = new DFA113( this );
		dfa122 = new DFA122( this );
		dfa125 = new DFA125( this );
		dfa149 = new DFA149( this );
		dfa148 = new DFA148( this );
		dfa158 = new DFA158( this );
		dfa163 = new DFA163( this );
		dfa166 = new DFA166( this );
		dfa169 = new DFA169( this );
		dfa172 = new DFA172( this );
		dfa175 = new DFA175( this );
		dfa178 = new DFA178( this );
		dfa181 = new DFA181( this );
		dfa184 = new DFA184( this );
		dfa187 = new DFA187( this );
		dfa190 = new DFA190( this );
		dfa193 = new DFA193( this );
		dfa197 = new DFA197( this );
		dfa201 = new DFA201( this );
		dfa205 = new DFA205( this );
		dfa209 = new DFA209( this );
		dfa213 = new DFA213( this );
		dfa221 = new DFA221( this );
		dfa233 = new DFA233( this );
		dfa232 = new DFA232( this );
		dfa239 = new DFA239( this );
		dfa238 = new DFA238( this );
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\x4\xFFFF";
		private const string DFA4_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA4_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA4_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA4_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA4_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1\xFFFF\x1\x3\x1\xFFFF"+
				"\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1\xFFFF\x1\x3\x1\xFFFF"+
				"\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "()* loopback of 40:18: ( ( LT )* sourceElement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA17 : DFA
	{
		private const string DFA17_eotS =
			"\x4\xFFFF";
		private const string DFA17_eofS =
			"\x4\xFFFF";
		private const string DFA17_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA17_maxS =
			"\x2\x31\x2\xFFFF";
		private const string DFA17_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA17_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA17_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x18\xFFFF\x1\x3",
				"\x1\x2\x2\xFFFF\x1\x1\x18\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA17_eot = DFA.UnpackEncodedString(DFA17_eotS);
		private static readonly short[] DFA17_eof = DFA.UnpackEncodedString(DFA17_eofS);
		private static readonly char[] DFA17_min = DFA.UnpackEncodedStringToUnsignedChars(DFA17_minS);
		private static readonly char[] DFA17_max = DFA.UnpackEncodedStringToUnsignedChars(DFA17_maxS);
		private static readonly short[] DFA17_accept = DFA.UnpackEncodedString(DFA17_acceptS);
		private static readonly short[] DFA17_special = DFA.UnpackEncodedString(DFA17_specialS);
		private static readonly short[][] DFA17_transition;

		static DFA17()
		{
			int numStates = DFA17_transitionS.Length;
			DFA17_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA17_transition[i] = DFA.UnpackEncodedString(DFA17_transitionS[i]);
			}
		}

		public DFA17( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 17;
			this.eot = DFA17_eot;
			this.eof = DFA17_eof;
			this.min = DFA17_min;
			this.max = DFA17_max;
			this.accept = DFA17_accept;
			this.special = DFA17_special;
			this.transition = DFA17_transition;
		}

		public override string Description { get { return "66:8: ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA16 : DFA
	{
		private const string DFA16_eotS =
			"\x4\xFFFF";
		private const string DFA16_eofS =
			"\x4\xFFFF";
		private const string DFA16_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA16_maxS =
			"\x2\x37\x2\xFFFF";
		private const string DFA16_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA16_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA16_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA16_eot = DFA.UnpackEncodedString(DFA16_eotS);
		private static readonly short[] DFA16_eof = DFA.UnpackEncodedString(DFA16_eofS);
		private static readonly char[] DFA16_min = DFA.UnpackEncodedStringToUnsignedChars(DFA16_minS);
		private static readonly char[] DFA16_max = DFA.UnpackEncodedStringToUnsignedChars(DFA16_maxS);
		private static readonly short[] DFA16_accept = DFA.UnpackEncodedString(DFA16_acceptS);
		private static readonly short[] DFA16_special = DFA.UnpackEncodedString(DFA16_specialS);
		private static readonly short[][] DFA16_transition;

		static DFA16()
		{
			int numStates = DFA16_transitionS.Length;
			DFA16_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA16_transition[i] = DFA.UnpackEncodedString(DFA16_transitionS[i]);
			}
		}

		public DFA16( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 16;
			this.eot = DFA16_eot;
			this.eof = DFA16_eof;
			this.min = DFA16_min;
			this.max = DFA16_max;
			this.accept = DFA16_accept;
			this.special = DFA16_special;
			this.transition = DFA16_transition;
		}

		public override string Description { get { return "()* loopback of 66:24: ( ( LT )* ',' ( LT )* Identifier )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA26 : DFA
	{
		private const string DFA26_eotS =
			"\x4\xFFFF";
		private const string DFA26_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA26_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA26_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA26_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA26_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA26_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x1\x2\x1\xFFFF\x1\x3\x1\x2\x2\x3\x1\xFFFF\x1\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x1\x2\x1\xFFFF\x1\x3\x1\x2\x2\x3\x1\xFFFF\x1\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA26_eot = DFA.UnpackEncodedString(DFA26_eotS);
		private static readonly short[] DFA26_eof = DFA.UnpackEncodedString(DFA26_eofS);
		private static readonly char[] DFA26_min = DFA.UnpackEncodedStringToUnsignedChars(DFA26_minS);
		private static readonly char[] DFA26_max = DFA.UnpackEncodedStringToUnsignedChars(DFA26_maxS);
		private static readonly short[] DFA26_accept = DFA.UnpackEncodedString(DFA26_acceptS);
		private static readonly short[] DFA26_special = DFA.UnpackEncodedString(DFA26_specialS);
		private static readonly short[][] DFA26_transition;

		static DFA26()
		{
			int numStates = DFA26_transitionS.Length;
			DFA26_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA26_transition[i] = DFA.UnpackEncodedString(DFA26_transitionS[i]);
			}
		}

		public DFA26( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 26;
			this.eot = DFA26_eot;
			this.eof = DFA26_eof;
			this.min = DFA26_min;
			this.max = DFA26_max;
			this.accept = DFA26_accept;
			this.special = DFA26_special;
			this.transition = DFA26_transition;
		}

		public override string Description { get { return "()* loopback of 97:14: ( ( LT !)* statement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA31 : DFA
	{
		private const string DFA31_eotS =
			"\x5\xFFFF";
		private const string DFA31_eofS =
			"\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2";
		private const string DFA31_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA31_maxS =
			"\x1\x3F\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA31_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA31_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA31_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x5\xFFFF\x1\x2\xE\xFFFF"+
				"\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2",
				"",
				"",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x5\xFFFF\x1\x2\xE\xFFFF"+
				"\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2"
			};

		private static readonly short[] DFA31_eot = DFA.UnpackEncodedString(DFA31_eotS);
		private static readonly short[] DFA31_eof = DFA.UnpackEncodedString(DFA31_eofS);
		private static readonly char[] DFA31_min = DFA.UnpackEncodedStringToUnsignedChars(DFA31_minS);
		private static readonly char[] DFA31_max = DFA.UnpackEncodedStringToUnsignedChars(DFA31_maxS);
		private static readonly short[] DFA31_accept = DFA.UnpackEncodedString(DFA31_acceptS);
		private static readonly short[] DFA31_special = DFA.UnpackEncodedString(DFA31_specialS);
		private static readonly short[][] DFA31_transition;

		static DFA31()
		{
			int numStates = DFA31_transitionS.Length;
			DFA31_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA31_transition[i] = DFA.UnpackEncodedString(DFA31_transitionS[i]);
			}
		}

		public DFA31( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 31;
			this.eot = DFA31_eot;
			this.eof = DFA31_eof;
			this.min = DFA31_min;
			this.max = DFA31_max;
			this.accept = DFA31_accept;
			this.special = DFA31_special;
			this.transition = DFA31_transition;
		}

		public override string Description { get { return "()* loopback of 106:24: ( ( LT )* ',' ( LT )* variableDeclaration )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA34 : DFA
	{
		private const string DFA34_eotS =
			"\x4\xFFFF";
		private const string DFA34_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA34_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA34_maxS =
			"\x2\x3F\x2\xFFFF";
		private const string DFA34_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA34_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA34_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA34_eot = DFA.UnpackEncodedString(DFA34_eotS);
		private static readonly short[] DFA34_eof = DFA.UnpackEncodedString(DFA34_eofS);
		private static readonly char[] DFA34_min = DFA.UnpackEncodedStringToUnsignedChars(DFA34_minS);
		private static readonly char[] DFA34_max = DFA.UnpackEncodedStringToUnsignedChars(DFA34_maxS);
		private static readonly short[] DFA34_accept = DFA.UnpackEncodedString(DFA34_acceptS);
		private static readonly short[] DFA34_special = DFA.UnpackEncodedString(DFA34_specialS);
		private static readonly short[][] DFA34_transition;

		static DFA34()
		{
			int numStates = DFA34_transitionS.Length;
			DFA34_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA34_transition[i] = DFA.UnpackEncodedString(DFA34_transitionS[i]);
			}
		}

		public DFA34( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 34;
			this.eot = DFA34_eot;
			this.eof = DFA34_eof;
			this.min = DFA34_min;
			this.max = DFA34_max;
			this.accept = DFA34_accept;
			this.special = DFA34_special;
			this.transition = DFA34_transition;
		}

		public override string Description { get { return "()* loopback of 110:28: ( ( LT )* ',' ( LT )* variableDeclarationNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA60 : DFA
	{
		private const string DFA60_eotS =
			"\x4\xFFFF";
		private const string DFA60_eofS =
			"\x4\xFFFF";
		private const string DFA60_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA60_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA60_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA60_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA60_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA60_eot = DFA.UnpackEncodedString(DFA60_eotS);
		private static readonly short[] DFA60_eof = DFA.UnpackEncodedString(DFA60_eofS);
		private static readonly char[] DFA60_min = DFA.UnpackEncodedStringToUnsignedChars(DFA60_minS);
		private static readonly char[] DFA60_max = DFA.UnpackEncodedStringToUnsignedChars(DFA60_maxS);
		private static readonly short[] DFA60_accept = DFA.UnpackEncodedString(DFA60_acceptS);
		private static readonly short[] DFA60_special = DFA.UnpackEncodedString(DFA60_specialS);
		private static readonly short[][] DFA60_transition;

		static DFA60()
		{
			int numStates = DFA60_transitionS.Length;
			DFA60_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA60_transition[i] = DFA.UnpackEncodedString(DFA60_transitionS[i]);
			}
		}

		public DFA60( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 60;
			this.eot = DFA60_eot;
			this.eof = DFA60_eof;
			this.min = DFA60_min;
			this.max = DFA60_max;
			this.accept = DFA60_accept;
			this.special = DFA60_special;
			this.transition = DFA60_transition;
		}

		public override string Description { get { return "166:18: ( ( LT )* forStatementInitialiserPart )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA63 : DFA
	{
		private const string DFA63_eotS =
			"\x4\xFFFF";
		private const string DFA63_eofS =
			"\x4\xFFFF";
		private const string DFA63_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA63_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA63_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA63_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA63_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA63_eot = DFA.UnpackEncodedString(DFA63_eotS);
		private static readonly short[] DFA63_eof = DFA.UnpackEncodedString(DFA63_eofS);
		private static readonly char[] DFA63_min = DFA.UnpackEncodedStringToUnsignedChars(DFA63_minS);
		private static readonly char[] DFA63_max = DFA.UnpackEncodedStringToUnsignedChars(DFA63_maxS);
		private static readonly short[] DFA63_accept = DFA.UnpackEncodedString(DFA63_acceptS);
		private static readonly short[] DFA63_special = DFA.UnpackEncodedString(DFA63_specialS);
		private static readonly short[][] DFA63_transition;

		static DFA63()
		{
			int numStates = DFA63_transitionS.Length;
			DFA63_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA63_transition[i] = DFA.UnpackEncodedString(DFA63_transitionS[i]);
			}
		}

		public DFA63( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 63;
			this.eot = DFA63_eot;
			this.eof = DFA63_eof;
			this.min = DFA63_min;
			this.max = DFA63_max;
			this.accept = DFA63_accept;
			this.special = DFA63_special;
			this.transition = DFA63_transition;
		}

		public override string Description { get { return "166:61: ( ( LT )* condition= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA66 : DFA
	{
		private const string DFA66_eotS =
			"\x4\xFFFF";
		private const string DFA66_eofS =
			"\x4\xFFFF";
		private const string DFA66_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA66_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA66_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA66_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA66_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA66_eot = DFA.UnpackEncodedString(DFA66_eotS);
		private static readonly short[] DFA66_eof = DFA.UnpackEncodedString(DFA66_eofS);
		private static readonly char[] DFA66_min = DFA.UnpackEncodedStringToUnsignedChars(DFA66_minS);
		private static readonly char[] DFA66_max = DFA.UnpackEncodedStringToUnsignedChars(DFA66_maxS);
		private static readonly short[] DFA66_accept = DFA.UnpackEncodedString(DFA66_acceptS);
		private static readonly short[] DFA66_special = DFA.UnpackEncodedString(DFA66_specialS);
		private static readonly short[][] DFA66_transition;

		static DFA66()
		{
			int numStates = DFA66_transitionS.Length;
			DFA66_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA66_transition[i] = DFA.UnpackEncodedString(DFA66_transitionS[i]);
			}
		}

		public DFA66( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 66;
			this.eot = DFA66_eot;
			this.eof = DFA66_eof;
			this.min = DFA66_min;
			this.max = DFA66_max;
			this.accept = DFA66_accept;
			this.special = DFA66_special;
			this.transition = DFA66_transition;
		}

		public override string Description { get { return "166:97: ( ( LT )* incr= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA96 : DFA
	{
		private const string DFA96_eotS =
			"\x4\xFFFF";
		private const string DFA96_eofS =
			"\x4\xFFFF";
		private const string DFA96_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA96_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA96_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA96_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA96_transitionS =
			{
				"\x1\x1\x3A\xFFFF\x1\x3\x2\xFFFF\x1\x2\x1B\xFFFF\x1\x2",
				"\x1\x1\x3A\xFFFF\x1\x3\x2\xFFFF\x1\x2\x1B\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA96_eot = DFA.UnpackEncodedString(DFA96_eotS);
		private static readonly short[] DFA96_eof = DFA.UnpackEncodedString(DFA96_eofS);
		private static readonly char[] DFA96_min = DFA.UnpackEncodedStringToUnsignedChars(DFA96_minS);
		private static readonly char[] DFA96_max = DFA.UnpackEncodedStringToUnsignedChars(DFA96_maxS);
		private static readonly short[] DFA96_accept = DFA.UnpackEncodedString(DFA96_acceptS);
		private static readonly short[] DFA96_special = DFA.UnpackEncodedString(DFA96_specialS);
		private static readonly short[][] DFA96_transition;

		static DFA96()
		{
			int numStates = DFA96_transitionS.Length;
			DFA96_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA96_transition[i] = DFA.UnpackEncodedString(DFA96_transitionS[i]);
			}
		}

		public DFA96( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 96;
			this.eot = DFA96_eot;
			this.eof = DFA96_eof;
			this.min = DFA96_min;
			this.max = DFA96_max;
			this.accept = DFA96_accept;
			this.special = DFA96_special;
			this.transition = DFA96_transition;
		}

		public override string Description { get { return "()* loopback of 222:9: ( ( LT !)* caseClause )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA100 : DFA
	{
		private const string DFA100_eotS =
			"\x4\xFFFF";
		private const string DFA100_eofS =
			"\x4\xFFFF";
		private const string DFA100_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA100_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA100_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA100_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA100_transitionS =
			{
				"\x1\x1\x3D\xFFFF\x1\x2\x1B\xFFFF\x1\x3",
				"\x1\x1\x3D\xFFFF\x1\x2\x1B\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA100_eot = DFA.UnpackEncodedString(DFA100_eotS);
		private static readonly short[] DFA100_eof = DFA.UnpackEncodedString(DFA100_eofS);
		private static readonly char[] DFA100_min = DFA.UnpackEncodedStringToUnsignedChars(DFA100_minS);
		private static readonly char[] DFA100_max = DFA.UnpackEncodedStringToUnsignedChars(DFA100_maxS);
		private static readonly short[] DFA100_accept = DFA.UnpackEncodedString(DFA100_acceptS);
		private static readonly short[] DFA100_special = DFA.UnpackEncodedString(DFA100_specialS);
		private static readonly short[][] DFA100_transition;

		static DFA100()
		{
			int numStates = DFA100_transitionS.Length;
			DFA100_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA100_transition[i] = DFA.UnpackEncodedString(DFA100_transitionS[i]);
			}
		}

		public DFA100( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 100;
			this.eot = DFA100_eot;
			this.eof = DFA100_eof;
			this.min = DFA100_min;
			this.max = DFA100_max;
			this.accept = DFA100_accept;
			this.special = DFA100_special;
			this.transition = DFA100_transition;
		}

		public override string Description { get { return "222:28: ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA99 : DFA
	{
		private const string DFA99_eotS =
			"\x4\xFFFF";
		private const string DFA99_eofS =
			"\x4\xFFFF";
		private const string DFA99_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA99_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA99_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA99_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA99_transitionS =
			{
				"\x1\x1\x3A\xFFFF\x1\x3\x1E\xFFFF\x1\x2",
				"\x1\x1\x3A\xFFFF\x1\x3\x1E\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA99_eot = DFA.UnpackEncodedString(DFA99_eotS);
		private static readonly short[] DFA99_eof = DFA.UnpackEncodedString(DFA99_eofS);
		private static readonly char[] DFA99_min = DFA.UnpackEncodedStringToUnsignedChars(DFA99_minS);
		private static readonly char[] DFA99_max = DFA.UnpackEncodedStringToUnsignedChars(DFA99_maxS);
		private static readonly short[] DFA99_accept = DFA.UnpackEncodedString(DFA99_acceptS);
		private static readonly short[] DFA99_special = DFA.UnpackEncodedString(DFA99_specialS);
		private static readonly short[][] DFA99_transition;

		static DFA99()
		{
			int numStates = DFA99_transitionS.Length;
			DFA99_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA99_transition[i] = DFA.UnpackEncodedString(DFA99_transitionS[i]);
			}
		}

		public DFA99( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 99;
			this.eot = DFA99_eot;
			this.eof = DFA99_eof;
			this.min = DFA99_min;
			this.max = DFA99_max;
			this.accept = DFA99_accept;
			this.special = DFA99_special;
			this.transition = DFA99_transition;
		}

		public override string Description { get { return "()* loopback of 222:48: ( ( LT !)* caseClause )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA113 : DFA
	{
		private const string DFA113_eotS =
			"\x4\xFFFF";
		private const string DFA113_eofS =
			"\x2\x3\x2\xFFFF";
		private const string DFA113_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA113_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA113_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA113_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA113_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\x2\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF"+
				"\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\x2\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF"+
				"\x2\x3",
				"",
				""
			};

		private static readonly short[] DFA113_eot = DFA.UnpackEncodedString(DFA113_eotS);
		private static readonly short[] DFA113_eof = DFA.UnpackEncodedString(DFA113_eofS);
		private static readonly char[] DFA113_min = DFA.UnpackEncodedStringToUnsignedChars(DFA113_minS);
		private static readonly char[] DFA113_max = DFA.UnpackEncodedStringToUnsignedChars(DFA113_maxS);
		private static readonly short[] DFA113_accept = DFA.UnpackEncodedString(DFA113_acceptS);
		private static readonly short[] DFA113_special = DFA.UnpackEncodedString(DFA113_specialS);
		private static readonly short[][] DFA113_transition;

		static DFA113()
		{
			int numStates = DFA113_transitionS.Length;
			DFA113_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA113_transition[i] = DFA.UnpackEncodedString(DFA113_transitionS[i]);
			}
		}

		public DFA113( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 113;
			this.eot = DFA113_eot;
			this.eof = DFA113_eof;
			this.min = DFA113_min;
			this.max = DFA113_max;
			this.accept = DFA113_accept;
			this.special = DFA113_special;
			this.transition = DFA113_transition;
		}

		public override string Description { get { return "238:62: ( ( LT )* finallyClause )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA122 : DFA
	{
		private const string DFA122_eotS =
			"\x5\xFFFF";
		private const string DFA122_eofS =
			"\x2\x2\x2\xFFFF\x1\x2";
		private const string DFA122_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA122_maxS =
			"\x1\x4F\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA122_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA122_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA122_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3\x6\xFFFF\x2\x2\xF\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x4\xFFFF\x2\x2\xE\xFFFF"+
				"\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2",
				"",
				"",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x4\xFFFF\x2\x2\xE\xFFFF"+
				"\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2"
			};

		private static readonly short[] DFA122_eot = DFA.UnpackEncodedString(DFA122_eotS);
		private static readonly short[] DFA122_eof = DFA.UnpackEncodedString(DFA122_eofS);
		private static readonly char[] DFA122_min = DFA.UnpackEncodedStringToUnsignedChars(DFA122_minS);
		private static readonly char[] DFA122_max = DFA.UnpackEncodedStringToUnsignedChars(DFA122_maxS);
		private static readonly short[] DFA122_accept = DFA.UnpackEncodedString(DFA122_acceptS);
		private static readonly short[] DFA122_special = DFA.UnpackEncodedString(DFA122_specialS);
		private static readonly short[][] DFA122_transition;

		static DFA122()
		{
			int numStates = DFA122_transitionS.Length;
			DFA122_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA122_transition[i] = DFA.UnpackEncodedString(DFA122_transitionS[i]);
			}
		}

		public DFA122( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 122;
			this.eot = DFA122_eot;
			this.eof = DFA122_eof;
			this.min = DFA122_min;
			this.max = DFA122_max;
			this.accept = DFA122_accept;
			this.special = DFA122_special;
			this.transition = DFA122_transition;
		}

		public override string Description { get { return "()* loopback of 253:25: ( ( LT )* ',' ( LT )* assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA125 : DFA
	{
		private const string DFA125_eotS =
			"\x4\xFFFF";
		private const string DFA125_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA125_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA125_maxS =
			"\x2\x3F\x2\xFFFF";
		private const string DFA125_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA125_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA125_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA125_eot = DFA.UnpackEncodedString(DFA125_eotS);
		private static readonly short[] DFA125_eof = DFA.UnpackEncodedString(DFA125_eofS);
		private static readonly char[] DFA125_min = DFA.UnpackEncodedStringToUnsignedChars(DFA125_minS);
		private static readonly char[] DFA125_max = DFA.UnpackEncodedStringToUnsignedChars(DFA125_maxS);
		private static readonly short[] DFA125_accept = DFA.UnpackEncodedString(DFA125_acceptS);
		private static readonly short[] DFA125_special = DFA.UnpackEncodedString(DFA125_specialS);
		private static readonly short[][] DFA125_transition;

		static DFA125()
		{
			int numStates = DFA125_transitionS.Length;
			DFA125_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA125_transition[i] = DFA.UnpackEncodedString(DFA125_transitionS[i]);
			}
		}

		public DFA125( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 125;
			this.eot = DFA125_eot;
			this.eof = DFA125_eof;
			this.min = DFA125_min;
			this.max = DFA125_max;
			this.accept = DFA125_accept;
			this.special = DFA125_special;
			this.transition = DFA125_transition;
		}

		public override string Description { get { return "()* loopback of 257:29: ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA149 : DFA
	{
		private const string DFA149_eotS =
			"\x4\xFFFF";
		private const string DFA149_eofS =
			"\x4\xFFFF";
		private const string DFA149_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA149_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA149_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA149_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA149_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA149_eot = DFA.UnpackEncodedString(DFA149_eotS);
		private static readonly short[] DFA149_eof = DFA.UnpackEncodedString(DFA149_eofS);
		private static readonly char[] DFA149_min = DFA.UnpackEncodedStringToUnsignedChars(DFA149_minS);
		private static readonly char[] DFA149_max = DFA.UnpackEncodedStringToUnsignedChars(DFA149_maxS);
		private static readonly short[] DFA149_accept = DFA.UnpackEncodedString(DFA149_acceptS);
		private static readonly short[] DFA149_special = DFA.UnpackEncodedString(DFA149_specialS);
		private static readonly short[][] DFA149_transition;

		static DFA149()
		{
			int numStates = DFA149_transitionS.Length;
			DFA149_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA149_transition[i] = DFA.UnpackEncodedString(DFA149_transitionS[i]);
			}
		}

		public DFA149( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 149;
			this.eot = DFA149_eot;
			this.eof = DFA149_eof;
			this.min = DFA149_min;
			this.max = DFA149_max;
			this.accept = DFA149_accept;
			this.special = DFA149_special;
			this.transition = DFA149_transition;
		}

		public override string Description { get { return "346:8: ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA148 : DFA
	{
		private const string DFA148_eotS =
			"\x4\xFFFF";
		private const string DFA148_eofS =
			"\x4\xFFFF";
		private const string DFA148_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA148_maxS =
			"\x2\x37\x2\xFFFF";
		private const string DFA148_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA148_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA148_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA148_eot = DFA.UnpackEncodedString(DFA148_eotS);
		private static readonly short[] DFA148_eof = DFA.UnpackEncodedString(DFA148_eofS);
		private static readonly char[] DFA148_min = DFA.UnpackEncodedStringToUnsignedChars(DFA148_minS);
		private static readonly char[] DFA148_max = DFA.UnpackEncodedStringToUnsignedChars(DFA148_maxS);
		private static readonly short[] DFA148_accept = DFA.UnpackEncodedString(DFA148_acceptS);
		private static readonly short[] DFA148_special = DFA.UnpackEncodedString(DFA148_specialS);
		private static readonly short[][] DFA148_transition;

		static DFA148()
		{
			int numStates = DFA148_transitionS.Length;
			DFA148_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA148_transition[i] = DFA.UnpackEncodedString(DFA148_transitionS[i]);
			}
		}

		public DFA148( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 148;
			this.eot = DFA148_eot;
			this.eof = DFA148_eof;
			this.min = DFA148_min;
			this.max = DFA148_max;
			this.accept = DFA148_accept;
			this.special = DFA148_special;
			this.transition = DFA148_transition;
		}

		public override string Description { get { return "()* loopback of 346:34: ( ( LT )* ',' ( LT )* assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA158 : DFA
	{
		private const string DFA158_eotS =
			"\x5\xFFFF";
		private const string DFA158_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA158_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA158_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA158_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA158_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA158_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x2"+
				"\x1\xFFFF\x1\x3\x22\xFFFF\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x1"+
				"\x2\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3"+
				"\x3\xFFFF\x2\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x1"+
				"\x2\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3"+
				"\x3\xFFFF\x2\x3"
			};

		private static readonly short[] DFA158_eot = DFA.UnpackEncodedString(DFA158_eotS);
		private static readonly short[] DFA158_eof = DFA.UnpackEncodedString(DFA158_eofS);
		private static readonly char[] DFA158_min = DFA.UnpackEncodedStringToUnsignedChars(DFA158_minS);
		private static readonly char[] DFA158_max = DFA.UnpackEncodedStringToUnsignedChars(DFA158_maxS);
		private static readonly short[] DFA158_accept = DFA.UnpackEncodedString(DFA158_acceptS);
		private static readonly short[] DFA158_special = DFA.UnpackEncodedString(DFA158_specialS);
		private static readonly short[][] DFA158_transition;

		static DFA158()
		{
			int numStates = DFA158_transitionS.Length;
			DFA158_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA158_transition[i] = DFA.UnpackEncodedString(DFA158_transitionS[i]);
			}
		}

		public DFA158( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 158;
			this.eot = DFA158_eot;
			this.eof = DFA158_eof;
			this.min = DFA158_min;
			this.max = DFA158_max;
			this.accept = DFA158_accept;
			this.special = DFA158_special;
			this.transition = DFA158_transition;
		}

		public override string Description { get { return "361:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA163 : DFA
	{
		private const string DFA163_eotS =
			"\x4\xFFFF";
		private const string DFA163_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA163_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA163_maxS =
			"\x2\x5F\x2\xFFFF";
		private const string DFA163_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA163_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA163_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x2\x11\xFFFF\x1\x3",
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x2\x11\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA163_eot = DFA.UnpackEncodedString(DFA163_eotS);
		private static readonly short[] DFA163_eof = DFA.UnpackEncodedString(DFA163_eofS);
		private static readonly char[] DFA163_min = DFA.UnpackEncodedStringToUnsignedChars(DFA163_minS);
		private static readonly char[] DFA163_max = DFA.UnpackEncodedStringToUnsignedChars(DFA163_maxS);
		private static readonly short[] DFA163_accept = DFA.UnpackEncodedString(DFA163_acceptS);
		private static readonly short[] DFA163_special = DFA.UnpackEncodedString(DFA163_specialS);
		private static readonly short[][] DFA163_transition;

		static DFA163()
		{
			int numStates = DFA163_transitionS.Length;
			DFA163_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA163_transition[i] = DFA.UnpackEncodedString(DFA163_transitionS[i]);
			}
		}

		public DFA163( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 163;
			this.eot = DFA163_eot;
			this.eof = DFA163_eof;
			this.min = DFA163_min;
			this.max = DFA163_max;
			this.accept = DFA163_accept;
			this.special = DFA163_special;
			this.transition = DFA163_transition;
		}

		public override string Description { get { return "371:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA166 : DFA
	{
		private const string DFA166_eotS =
			"\x5\xFFFF";
		private const string DFA166_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA166_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA166_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA166_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA166_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA166_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x1\xFFFF\x1\x3\x21\xFFFF\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x3"+
				"\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3\x2\xFFFF"+
				"\x1\x2\x2\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x3"+
				"\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3\x2\xFFFF"+
				"\x1\x2\x2\x3"
			};

		private static readonly short[] DFA166_eot = DFA.UnpackEncodedString(DFA166_eotS);
		private static readonly short[] DFA166_eof = DFA.UnpackEncodedString(DFA166_eofS);
		private static readonly char[] DFA166_min = DFA.UnpackEncodedStringToUnsignedChars(DFA166_minS);
		private static readonly char[] DFA166_max = DFA.UnpackEncodedStringToUnsignedChars(DFA166_maxS);
		private static readonly short[] DFA166_accept = DFA.UnpackEncodedString(DFA166_acceptS);
		private static readonly short[] DFA166_special = DFA.UnpackEncodedString(DFA166_specialS);
		private static readonly short[][] DFA166_transition;

		static DFA166()
		{
			int numStates = DFA166_transitionS.Length;
			DFA166_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA166_transition[i] = DFA.UnpackEncodedString(DFA166_transitionS[i]);
			}
		}

		public DFA166( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 166;
			this.eot = DFA166_eot;
			this.eof = DFA166_eof;
			this.min = DFA166_min;
			this.max = DFA166_max;
			this.accept = DFA166_accept;
			this.special = DFA166_special;
			this.transition = DFA166_transition;
		}

		public override string Description { get { return "381:3: ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA169 : DFA
	{
		private const string DFA169_eotS =
			"\x4\xFFFF";
		private const string DFA169_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA169_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA169_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA169_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA169_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA169_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3\x11\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3\x11\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA169_eot = DFA.UnpackEncodedString(DFA169_eotS);
		private static readonly short[] DFA169_eof = DFA.UnpackEncodedString(DFA169_eofS);
		private static readonly char[] DFA169_min = DFA.UnpackEncodedStringToUnsignedChars(DFA169_minS);
		private static readonly char[] DFA169_max = DFA.UnpackEncodedStringToUnsignedChars(DFA169_maxS);
		private static readonly short[] DFA169_accept = DFA.UnpackEncodedString(DFA169_acceptS);
		private static readonly short[] DFA169_special = DFA.UnpackEncodedString(DFA169_specialS);
		private static readonly short[][] DFA169_transition;

		static DFA169()
		{
			int numStates = DFA169_transitionS.Length;
			DFA169_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA169_transition[i] = DFA.UnpackEncodedString(DFA169_transitionS[i]);
			}
		}

		public DFA169( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 169;
			this.eot = DFA169_eot;
			this.eof = DFA169_eof;
			this.min = DFA169_min;
			this.max = DFA169_max;
			this.accept = DFA169_accept;
			this.special = DFA169_special;
			this.transition = DFA169_transition;
		}

		public override string Description { get { return "391:3: ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA172 : DFA
	{
		private const string DFA172_eotS =
			"\x5\xFFFF";
		private const string DFA172_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA172_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA172_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA172_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA172_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA172_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x2\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x3\x21\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x2\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x2\xFFFF\x3\x3"
			};

		private static readonly short[] DFA172_eot = DFA.UnpackEncodedString(DFA172_eotS);
		private static readonly short[] DFA172_eof = DFA.UnpackEncodedString(DFA172_eofS);
		private static readonly char[] DFA172_min = DFA.UnpackEncodedStringToUnsignedChars(DFA172_minS);
		private static readonly char[] DFA172_max = DFA.UnpackEncodedStringToUnsignedChars(DFA172_maxS);
		private static readonly short[] DFA172_accept = DFA.UnpackEncodedString(DFA172_acceptS);
		private static readonly short[] DFA172_special = DFA.UnpackEncodedString(DFA172_specialS);
		private static readonly short[][] DFA172_transition;

		static DFA172()
		{
			int numStates = DFA172_transitionS.Length;
			DFA172_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA172_transition[i] = DFA.UnpackEncodedString(DFA172_transitionS[i]);
			}
		}

		public DFA172( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 172;
			this.eot = DFA172_eot;
			this.eof = DFA172_eof;
			this.min = DFA172_min;
			this.max = DFA172_max;
			this.accept = DFA172_accept;
			this.special = DFA172_special;
			this.transition = DFA172_transition;
		}

		public override string Description { get { return "401:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA175 : DFA
	{
		private const string DFA175_eotS =
			"\x4\xFFFF";
		private const string DFA175_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA175_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA175_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA175_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA175_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA175_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x2\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\x11\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x2\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\x11\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA175_eot = DFA.UnpackEncodedString(DFA175_eotS);
		private static readonly short[] DFA175_eof = DFA.UnpackEncodedString(DFA175_eofS);
		private static readonly char[] DFA175_min = DFA.UnpackEncodedStringToUnsignedChars(DFA175_minS);
		private static readonly char[] DFA175_max = DFA.UnpackEncodedStringToUnsignedChars(DFA175_maxS);
		private static readonly short[] DFA175_accept = DFA.UnpackEncodedString(DFA175_acceptS);
		private static readonly short[] DFA175_special = DFA.UnpackEncodedString(DFA175_specialS);
		private static readonly short[][] DFA175_transition;

		static DFA175()
		{
			int numStates = DFA175_transitionS.Length;
			DFA175_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA175_transition[i] = DFA.UnpackEncodedString(DFA175_transitionS[i]);
			}
		}

		public DFA175( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 175;
			this.eot = DFA175_eot;
			this.eof = DFA175_eof;
			this.min = DFA175_min;
			this.max = DFA175_max;
			this.accept = DFA175_accept;
			this.special = DFA175_special;
			this.transition = DFA175_transition;
		}

		public override string Description { get { return "411:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA178 : DFA
	{
		private const string DFA178_eotS =
			"\x5\xFFFF";
		private const string DFA178_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA178_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA178_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA178_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA178_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA178_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1F\xFFFF\x1\x2\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x1\x2\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x1\x2\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA178_eot = DFA.UnpackEncodedString(DFA178_eotS);
		private static readonly short[] DFA178_eof = DFA.UnpackEncodedString(DFA178_eofS);
		private static readonly char[] DFA178_min = DFA.UnpackEncodedStringToUnsignedChars(DFA178_minS);
		private static readonly char[] DFA178_max = DFA.UnpackEncodedStringToUnsignedChars(DFA178_maxS);
		private static readonly short[] DFA178_accept = DFA.UnpackEncodedString(DFA178_acceptS);
		private static readonly short[] DFA178_special = DFA.UnpackEncodedString(DFA178_specialS);
		private static readonly short[][] DFA178_transition;

		static DFA178()
		{
			int numStates = DFA178_transitionS.Length;
			DFA178_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA178_transition[i] = DFA.UnpackEncodedString(DFA178_transitionS[i]);
			}
		}

		public DFA178( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 178;
			this.eot = DFA178_eot;
			this.eof = DFA178_eof;
			this.min = DFA178_min;
			this.max = DFA178_max;
			this.accept = DFA178_accept;
			this.special = DFA178_special;
			this.transition = DFA178_transition;
		}

		public override string Description { get { return "421:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA181 : DFA
	{
		private const string DFA181_eotS =
			"\x4\xFFFF";
		private const string DFA181_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA181_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA181_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA181_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA181_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA181_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\xF\xFFFF\x1\x2\x1\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\xF\xFFFF\x1\x2\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA181_eot = DFA.UnpackEncodedString(DFA181_eotS);
		private static readonly short[] DFA181_eof = DFA.UnpackEncodedString(DFA181_eofS);
		private static readonly char[] DFA181_min = DFA.UnpackEncodedStringToUnsignedChars(DFA181_minS);
		private static readonly char[] DFA181_max = DFA.UnpackEncodedStringToUnsignedChars(DFA181_maxS);
		private static readonly short[] DFA181_accept = DFA.UnpackEncodedString(DFA181_acceptS);
		private static readonly short[] DFA181_special = DFA.UnpackEncodedString(DFA181_specialS);
		private static readonly short[][] DFA181_transition;

		static DFA181()
		{
			int numStates = DFA181_transitionS.Length;
			DFA181_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA181_transition[i] = DFA.UnpackEncodedString(DFA181_transitionS[i]);
			}
		}

		public DFA181( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 181;
			this.eot = DFA181_eot;
			this.eof = DFA181_eof;
			this.min = DFA181_min;
			this.max = DFA181_max;
			this.accept = DFA181_accept;
			this.special = DFA181_special;
			this.transition = DFA181_transition;
		}

		public override string Description { get { return "431:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA184 : DFA
	{
		private const string DFA184_eotS =
			"\x5\xFFFF";
		private const string DFA184_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA184_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA184_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA184_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA184_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA184_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\x2\x1E\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA184_eot = DFA.UnpackEncodedString(DFA184_eotS);
		private static readonly short[] DFA184_eof = DFA.UnpackEncodedString(DFA184_eofS);
		private static readonly char[] DFA184_min = DFA.UnpackEncodedStringToUnsignedChars(DFA184_minS);
		private static readonly char[] DFA184_max = DFA.UnpackEncodedStringToUnsignedChars(DFA184_maxS);
		private static readonly short[] DFA184_accept = DFA.UnpackEncodedString(DFA184_acceptS);
		private static readonly short[] DFA184_special = DFA.UnpackEncodedString(DFA184_specialS);
		private static readonly short[][] DFA184_transition;

		static DFA184()
		{
			int numStates = DFA184_transitionS.Length;
			DFA184_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA184_transition[i] = DFA.UnpackEncodedString(DFA184_transitionS[i]);
			}
		}

		public DFA184( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 184;
			this.eot = DFA184_eot;
			this.eof = DFA184_eof;
			this.min = DFA184_min;
			this.max = DFA184_max;
			this.accept = DFA184_accept;
			this.special = DFA184_special;
			this.transition = DFA184_transition;
		}

		public override string Description { get { return "441:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA187 : DFA
	{
		private const string DFA187_eotS =
			"\x4\xFFFF";
		private const string DFA187_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA187_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA187_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA187_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA187_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA187_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x2\xFFFF\x1\x2\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x2\xFFFF\x1\x2\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA187_eot = DFA.UnpackEncodedString(DFA187_eotS);
		private static readonly short[] DFA187_eof = DFA.UnpackEncodedString(DFA187_eofS);
		private static readonly char[] DFA187_min = DFA.UnpackEncodedStringToUnsignedChars(DFA187_minS);
		private static readonly char[] DFA187_max = DFA.UnpackEncodedStringToUnsignedChars(DFA187_maxS);
		private static readonly short[] DFA187_accept = DFA.UnpackEncodedString(DFA187_acceptS);
		private static readonly short[] DFA187_special = DFA.UnpackEncodedString(DFA187_specialS);
		private static readonly short[][] DFA187_transition;

		static DFA187()
		{
			int numStates = DFA187_transitionS.Length;
			DFA187_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA187_transition[i] = DFA.UnpackEncodedString(DFA187_transitionS[i]);
			}
		}

		public DFA187( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 187;
			this.eot = DFA187_eot;
			this.eof = DFA187_eof;
			this.min = DFA187_min;
			this.max = DFA187_max;
			this.accept = DFA187_accept;
			this.special = DFA187_special;
			this.transition = DFA187_transition;
		}

		public override string Description { get { return "451:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA190 : DFA
	{
		private const string DFA190_eotS =
			"\x5\xFFFF";
		private const string DFA190_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA190_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA190_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA190_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA190_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA190_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x1\x2\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF"+
				"\x2\x3\xD\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1E\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x1\x2\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\xD\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2"+
				"\xFFFF\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x1\x2\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\xD\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2"+
				"\xFFFF\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA190_eot = DFA.UnpackEncodedString(DFA190_eotS);
		private static readonly short[] DFA190_eof = DFA.UnpackEncodedString(DFA190_eofS);
		private static readonly char[] DFA190_min = DFA.UnpackEncodedStringToUnsignedChars(DFA190_minS);
		private static readonly char[] DFA190_max = DFA.UnpackEncodedStringToUnsignedChars(DFA190_maxS);
		private static readonly short[] DFA190_accept = DFA.UnpackEncodedString(DFA190_acceptS);
		private static readonly short[] DFA190_special = DFA.UnpackEncodedString(DFA190_specialS);
		private static readonly short[][] DFA190_transition;

		static DFA190()
		{
			int numStates = DFA190_transitionS.Length;
			DFA190_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA190_transition[i] = DFA.UnpackEncodedString(DFA190_transitionS[i]);
			}
		}

		public DFA190( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 190;
			this.eot = DFA190_eot;
			this.eof = DFA190_eof;
			this.min = DFA190_min;
			this.max = DFA190_max;
			this.accept = DFA190_accept;
			this.special = DFA190_special;
			this.transition = DFA190_transition;
		}

		public override string Description { get { return "461:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA193 : DFA
	{
		private const string DFA193_eotS =
			"\x4\xFFFF";
		private const string DFA193_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA193_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA193_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA193_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA193_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA193_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x1\x2\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF"+
				"\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x3\x1\x2\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF"+
				"\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA193_eot = DFA.UnpackEncodedString(DFA193_eotS);
		private static readonly short[] DFA193_eof = DFA.UnpackEncodedString(DFA193_eofS);
		private static readonly char[] DFA193_min = DFA.UnpackEncodedStringToUnsignedChars(DFA193_minS);
		private static readonly char[] DFA193_max = DFA.UnpackEncodedStringToUnsignedChars(DFA193_maxS);
		private static readonly short[] DFA193_accept = DFA.UnpackEncodedString(DFA193_acceptS);
		private static readonly short[] DFA193_special = DFA.UnpackEncodedString(DFA193_specialS);
		private static readonly short[][] DFA193_transition;

		static DFA193()
		{
			int numStates = DFA193_transitionS.Length;
			DFA193_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA193_transition[i] = DFA.UnpackEncodedString(DFA193_transitionS[i]);
			}
		}

		public DFA193( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 193;
			this.eot = DFA193_eot;
			this.eof = DFA193_eof;
			this.min = DFA193_min;
			this.max = DFA193_max;
			this.accept = DFA193_accept;
			this.special = DFA193_special;
			this.transition = DFA193_transition;
		}

		public override string Description { get { return "471:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA197 : DFA
	{
		private const string DFA197_eotS =
			"\x5\xFFFF";
		private const string DFA197_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA197_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA197_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA197_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA197_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA197_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x2\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3"+
				"\x6\xFFFF\x2\x3\x5\xFFFF\x2\x2\x6\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1E\xFFFF"+
				"\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x2"+
				"\x2\x2\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\x5\xFFFF\x2\x2\x6\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x2"+
				"\x2\x2\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\x5\xFFFF\x2\x2\x6\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA197_eot = DFA.UnpackEncodedString(DFA197_eotS);
		private static readonly short[] DFA197_eof = DFA.UnpackEncodedString(DFA197_eofS);
		private static readonly char[] DFA197_min = DFA.UnpackEncodedStringToUnsignedChars(DFA197_minS);
		private static readonly char[] DFA197_max = DFA.UnpackEncodedStringToUnsignedChars(DFA197_maxS);
		private static readonly short[] DFA197_accept = DFA.UnpackEncodedString(DFA197_acceptS);
		private static readonly short[] DFA197_special = DFA.UnpackEncodedString(DFA197_specialS);
		private static readonly short[][] DFA197_transition;

		static DFA197()
		{
			int numStates = DFA197_transitionS.Length;
			DFA197_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA197_transition[i] = DFA.UnpackEncodedString(DFA197_transitionS[i]);
			}
		}

		public DFA197( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 197;
			this.eot = DFA197_eot;
			this.eof = DFA197_eof;
			this.min = DFA197_min;
			this.max = DFA197_max;
			this.accept = DFA197_accept;
			this.special = DFA197_special;
			this.transition = DFA197_transition;
		}

		public override string Description { get { return "481:3: ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA201 : DFA
	{
		private const string DFA201_eotS =
			"\x4\xFFFF";
		private const string DFA201_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA201_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA201_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA201_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA201_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA201_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x2\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x5\xFFFF\x2\x2\x6\xFFFF\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF"+
				"\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x10\xFFFF\x2\x2\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x5\xFFFF\x2\x2\x6\xFFFF\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF"+
				"\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA201_eot = DFA.UnpackEncodedString(DFA201_eotS);
		private static readonly short[] DFA201_eof = DFA.UnpackEncodedString(DFA201_eofS);
		private static readonly char[] DFA201_min = DFA.UnpackEncodedStringToUnsignedChars(DFA201_minS);
		private static readonly char[] DFA201_max = DFA.UnpackEncodedStringToUnsignedChars(DFA201_maxS);
		private static readonly short[] DFA201_accept = DFA.UnpackEncodedString(DFA201_acceptS);
		private static readonly short[] DFA201_special = DFA.UnpackEncodedString(DFA201_specialS);
		private static readonly short[][] DFA201_transition;

		static DFA201()
		{
			int numStates = DFA201_transitionS.Length;
			DFA201_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA201_transition[i] = DFA.UnpackEncodedString(DFA201_transitionS[i]);
			}
		}

		public DFA201( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 201;
			this.eot = DFA201_eot;
			this.eof = DFA201_eof;
			this.min = DFA201_min;
			this.max = DFA201_max;
			this.accept = DFA201_accept;
			this.special = DFA201_special;
			this.transition = DFA201_transition;
		}

		public override string Description { get { return "495:3: ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA205 : DFA
	{
		private const string DFA205_eotS =
			"\x5\xFFFF";
		private const string DFA205_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA205_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA205_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA205_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA205_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA205_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3"+
				"\x6\xFFFF\x2\x3\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x1"+
				"\x3\x1\xFFFF\x2\x3\xE\xFFFF\x2\x2\xE\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x4\x3\x1\xFFFF"+
				"\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\x2\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x4\x3\x1\xFFFF"+
				"\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\x2\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA205_eot = DFA.UnpackEncodedString(DFA205_eotS);
		private static readonly short[] DFA205_eof = DFA.UnpackEncodedString(DFA205_eofS);
		private static readonly char[] DFA205_min = DFA.UnpackEncodedStringToUnsignedChars(DFA205_minS);
		private static readonly char[] DFA205_max = DFA.UnpackEncodedStringToUnsignedChars(DFA205_maxS);
		private static readonly short[] DFA205_accept = DFA.UnpackEncodedString(DFA205_acceptS);
		private static readonly short[] DFA205_special = DFA.UnpackEncodedString(DFA205_specialS);
		private static readonly short[][] DFA205_transition;

		static DFA205()
		{
			int numStates = DFA205_transitionS.Length;
			DFA205_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA205_transition[i] = DFA.UnpackEncodedString(DFA205_transitionS[i]);
			}
		}

		public DFA205( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 205;
			this.eot = DFA205_eot;
			this.eof = DFA205_eof;
			this.min = DFA205_min;
			this.max = DFA205_max;
			this.accept = DFA205_accept;
			this.special = DFA205_special;
			this.transition = DFA205_transition;
		}

		public override string Description { get { return "512:3: ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA209 : DFA
	{
		private const string DFA209_eotS =
			"\x4\xFFFF";
		private const string DFA209_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA209_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA209_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA209_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA209_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA209_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\x3\xE\xFFFF\x1\x3\x1\x2\xE\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\x3\xE\xFFFF\x1\x3\x1\x2\xE\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA209_eot = DFA.UnpackEncodedString(DFA209_eotS);
		private static readonly short[] DFA209_eof = DFA.UnpackEncodedString(DFA209_eofS);
		private static readonly char[] DFA209_min = DFA.UnpackEncodedStringToUnsignedChars(DFA209_minS);
		private static readonly char[] DFA209_max = DFA.UnpackEncodedStringToUnsignedChars(DFA209_maxS);
		private static readonly short[] DFA209_accept = DFA.UnpackEncodedString(DFA209_acceptS);
		private static readonly short[] DFA209_special = DFA.UnpackEncodedString(DFA209_specialS);
		private static readonly short[][] DFA209_transition;

		static DFA209()
		{
			int numStates = DFA209_transitionS.Length;
			DFA209_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA209_transition[i] = DFA.UnpackEncodedString(DFA209_transitionS[i]);
			}
		}

		public DFA209( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 209;
			this.eot = DFA209_eot;
			this.eof = DFA209_eof;
			this.min = DFA209_min;
			this.max = DFA209_max;
			this.accept = DFA209_accept;
			this.special = DFA209_special;
			this.transition = DFA209_transition;
		}

		public override string Description { get { return "528:3: ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA213 : DFA
	{
		private const string DFA213_eotS =
			"\x5\xFFFF";
		private const string DFA213_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA213_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA213_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA213_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA213_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA213_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3"+
				"\x6\xFFFF\x3\x3\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x4\x3\x1\x2\x1\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3\xE\xFFFF\x2\x3\xE\xFFFF\x1\x3\x1\xFFFF"+
				"\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x3"+
				"\x3\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x4\x3\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
				"\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x3"+
				"\x3\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x4\x3\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
				"\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA213_eot = DFA.UnpackEncodedString(DFA213_eotS);
		private static readonly short[] DFA213_eof = DFA.UnpackEncodedString(DFA213_eofS);
		private static readonly char[] DFA213_min = DFA.UnpackEncodedStringToUnsignedChars(DFA213_minS);
		private static readonly char[] DFA213_max = DFA.UnpackEncodedStringToUnsignedChars(DFA213_maxS);
		private static readonly short[] DFA213_accept = DFA.UnpackEncodedString(DFA213_acceptS);
		private static readonly short[] DFA213_special = DFA.UnpackEncodedString(DFA213_specialS);
		private static readonly short[][] DFA213_transition;

		static DFA213()
		{
			int numStates = DFA213_transitionS.Length;
			DFA213_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA213_transition[i] = DFA.UnpackEncodedString(DFA213_transitionS[i]);
			}
		}

		public DFA213( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 213;
			this.eot = DFA213_eot;
			this.eof = DFA213_eof;
			this.min = DFA213_min;
			this.max = DFA213_max;
			this.accept = DFA213_accept;
			this.special = DFA213_special;
			this.transition = DFA213_transition;
		}

		public override string Description { get { return "546:9: ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA221 : DFA
	{
		private const string DFA221_eotS =
			"\x5\xFFFF";
		private const string DFA221_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA221_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA221_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA221_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA221_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA221_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x1\x2\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x1\x2\x1"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x3\xFFFF\x1\x2\x1\xFFFF\x4\x3\x1\xFFFF\x1"+
				"\x3\x1\xFFFF\x5\x3\x1\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3\xE\xFFFF"+
				"\x2\x3\xE\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x1"+
				"\x2\x1\xFFFF\x2\x3\x1\xFFFF\x2\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\x1\x2\x1\xFFFF\x4\x3\x1\xFFFF\x1\x3\x1\xFFFF\x5\x3\x1\xFFFF"+
				"\x1\x3\x1\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3"+
				"\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x1"+
				"\x2\x1\xFFFF\x2\x3\x1\xFFFF\x2\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\x1\x2\x1\xFFFF\x4\x3\x1\xFFFF\x1\x3\x1\xFFFF\x5\x3\x1\xFFFF"+
				"\x1\x3\x1\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3"+
				"\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA221_eot = DFA.UnpackEncodedString(DFA221_eotS);
		private static readonly short[] DFA221_eof = DFA.UnpackEncodedString(DFA221_eofS);
		private static readonly char[] DFA221_min = DFA.UnpackEncodedStringToUnsignedChars(DFA221_minS);
		private static readonly char[] DFA221_max = DFA.UnpackEncodedStringToUnsignedChars(DFA221_maxS);
		private static readonly short[] DFA221_accept = DFA.UnpackEncodedString(DFA221_acceptS);
		private static readonly short[] DFA221_special = DFA.UnpackEncodedString(DFA221_specialS);
		private static readonly short[][] DFA221_transition;

		static DFA221()
		{
			int numStates = DFA221_transitionS.Length;
			DFA221_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA221_transition[i] = DFA.UnpackEncodedString(DFA221_transitionS[i]);
			}
		}

		public DFA221( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 221;
			this.eot = DFA221_eot;
			this.eof = DFA221_eof;
			this.min = DFA221_min;
			this.max = DFA221_max;
			this.accept = DFA221_accept;
			this.special = DFA221_special;
			this.transition = DFA221_transition;
		}

		public override string Description { get { return "569:3: ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA233 : DFA
	{
		private const string DFA233_eotS =
			"\x4\xFFFF";
		private const string DFA233_eofS =
			"\x4\xFFFF";
		private const string DFA233_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA233_maxS =
			"\x2\x4F\x2\xFFFF";
		private const string DFA233_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA233_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA233_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x17\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x17\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA233_eot = DFA.UnpackEncodedString(DFA233_eotS);
		private static readonly short[] DFA233_eof = DFA.UnpackEncodedString(DFA233_eofS);
		private static readonly char[] DFA233_min = DFA.UnpackEncodedStringToUnsignedChars(DFA233_minS);
		private static readonly char[] DFA233_max = DFA.UnpackEncodedStringToUnsignedChars(DFA233_maxS);
		private static readonly short[] DFA233_accept = DFA.UnpackEncodedString(DFA233_acceptS);
		private static readonly short[] DFA233_special = DFA.UnpackEncodedString(DFA233_specialS);
		private static readonly short[][] DFA233_transition;

		static DFA233()
		{
			int numStates = DFA233_transitionS.Length;
			DFA233_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA233_transition[i] = DFA.UnpackEncodedString(DFA233_transitionS[i]);
			}
		}

		public DFA233( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 233;
			this.eot = DFA233_eot;
			this.eof = DFA233_eof;
			this.min = DFA233_min;
			this.max = DFA233_max;
			this.accept = DFA233_accept;
			this.special = DFA233_special;
			this.transition = DFA233_transition;
		}

		public override string Description { get { return "()* loopback of 619:34: ( ( LT )* ',' ( ( LT )* assignmentExpression )? )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA232 : DFA
	{
		private const string DFA232_eotS =
			"\x4\xFFFF";
		private const string DFA232_eofS =
			"\x4\xFFFF";
		private const string DFA232_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA232_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA232_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA232_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA232_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x14\xFFFF\x1\x2\x1"+
				"\x3\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x14\xFFFF\x1\x2\x1"+
				"\x3\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA232_eot = DFA.UnpackEncodedString(DFA232_eotS);
		private static readonly short[] DFA232_eof = DFA.UnpackEncodedString(DFA232_eofS);
		private static readonly char[] DFA232_min = DFA.UnpackEncodedStringToUnsignedChars(DFA232_minS);
		private static readonly char[] DFA232_max = DFA.UnpackEncodedStringToUnsignedChars(DFA232_maxS);
		private static readonly short[] DFA232_accept = DFA.UnpackEncodedString(DFA232_acceptS);
		private static readonly short[] DFA232_special = DFA.UnpackEncodedString(DFA232_specialS);
		private static readonly short[][] DFA232_transition;

		static DFA232()
		{
			int numStates = DFA232_transitionS.Length;
			DFA232_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA232_transition[i] = DFA.UnpackEncodedString(DFA232_transitionS[i]);
			}
		}

		public DFA232( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 232;
			this.eot = DFA232_eot;
			this.eof = DFA232_eof;
			this.min = DFA232_min;
			this.max = DFA232_max;
			this.accept = DFA232_accept;
			this.special = DFA232_special;
			this.transition = DFA232_transition;
		}

		public override string Description { get { return "619:43: ( ( LT )* assignmentExpression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA239 : DFA
	{
		private const string DFA239_eotS =
			"\x4\xFFFF";
		private const string DFA239_eofS =
			"\x4\xFFFF";
		private const string DFA239_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA239_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA239_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA239_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA239_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x51\xFFFF\x1\x3",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x51\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA239_eot = DFA.UnpackEncodedString(DFA239_eotS);
		private static readonly short[] DFA239_eof = DFA.UnpackEncodedString(DFA239_eofS);
		private static readonly char[] DFA239_min = DFA.UnpackEncodedStringToUnsignedChars(DFA239_minS);
		private static readonly char[] DFA239_max = DFA.UnpackEncodedStringToUnsignedChars(DFA239_maxS);
		private static readonly short[] DFA239_accept = DFA.UnpackEncodedString(DFA239_acceptS);
		private static readonly short[] DFA239_special = DFA.UnpackEncodedString(DFA239_specialS);
		private static readonly short[][] DFA239_transition;

		static DFA239()
		{
			int numStates = DFA239_transitionS.Length;
			DFA239_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA239_transition[i] = DFA.UnpackEncodedString(DFA239_transitionS[i]);
			}
		}

		public DFA239( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 239;
			this.eot = DFA239_eot;
			this.eof = DFA239_eof;
			this.min = DFA239_min;
			this.max = DFA239_max;
			this.accept = DFA239_accept;
			this.special = DFA239_special;
			this.transition = DFA239_transition;
		}

		public override string Description { get { return "625:8: ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA238 : DFA
	{
		private const string DFA238_eotS =
			"\x4\xFFFF";
		private const string DFA238_eofS =
			"\x4\xFFFF";
		private const string DFA238_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA238_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA238_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA238_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA238_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x3A\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x3A\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA238_eot = DFA.UnpackEncodedString(DFA238_eotS);
		private static readonly short[] DFA238_eof = DFA.UnpackEncodedString(DFA238_eofS);
		private static readonly char[] DFA238_min = DFA.UnpackEncodedStringToUnsignedChars(DFA238_minS);
		private static readonly char[] DFA238_max = DFA.UnpackEncodedStringToUnsignedChars(DFA238_maxS);
		private static readonly short[] DFA238_accept = DFA.UnpackEncodedString(DFA238_acceptS);
		private static readonly short[] DFA238_special = DFA.UnpackEncodedString(DFA238_specialS);
		private static readonly short[][] DFA238_transition;

		static DFA238()
		{
			int numStates = DFA238_transitionS.Length;
			DFA238_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA238_transition[i] = DFA.UnpackEncodedString(DFA238_transitionS[i]);
			}
		}

		public DFA238( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 238;
			this.eot = DFA238_eot;
			this.eof = DFA238_eof;
			this.min = DFA238_min;
			this.max = DFA238_max;
			this.accept = DFA238_accept;
			this.special = DFA238_special;
			this.transition = DFA238_transition;
		}

		public override string Description { get { return "()* loopback of 625:34: ( ( LT )* ',' ( LT )* propertyNameAndValue )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LT_in_program129 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _sourceElements_in_program132 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _LT_in_program134 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sourceElement_in_sourceElements162 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_sourceElements165 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _sourceElement_in_sourceElements168 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _functionDeclaration_in_sourceElement187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_sourceElement192 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _93_in_functionDeclaration205 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_functionDeclaration207 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration210 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_functionDeclaration212 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _formalParameterList_in_functionDeclaration215 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_functionDeclaration217 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _functionBody_in_functionDeclaration220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _93_in_functionExpression272 = new BitSet(new ulong[]{0x1000001200000UL});
		public static readonly BitSet _LT_in_functionExpression274 = new BitSet(new ulong[]{0x1000001200000UL});
		public static readonly BitSet _Identifier_in_functionExpression277 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_functionExpression280 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _formalParameterList_in_functionExpression283 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_functionExpression285 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _functionBody_in_functionExpression288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_formalParameterList337 = new BitSet(new ulong[]{0x2000001200000UL});
		public static readonly BitSet _LT_in_formalParameterList340 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_formalParameterList343 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_formalParameterList346 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_formalParameterList349 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_formalParameterList351 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_formalParameterList354 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_formalParameterList360 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_formalParameterList363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_functionBody395 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_functionBody397 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _sourceElements_in_functionBody400 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_functionBody402 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_functionBody405 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementBlock_in_statement430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_statement435 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyStatement_in_statement440 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statement445 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement450 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iterationStatement_in_statement455 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statement460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statement465 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statement470 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statement475 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_statement480 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statement485 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statement490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statement495 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_statementBlock507 = new BitSet(new ulong[]{0x8331010109200000UL,0xC7FFE75A44000UL});
		public static readonly BitSet _LT_in_statementBlock509 = new BitSet(new ulong[]{0x8331010109200000UL,0xC7FFE75A44000UL});
		public static readonly BitSet _statementList_in_statementBlock512 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_statementBlock515 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_statementBlock518 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statementList544 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_statementList547 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_statementList551 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _106_in_variableStatement565 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_variableStatement567 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationList_in_variableStatement570 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_variableStatement573 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_variableStatement577 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList606 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_variableDeclarationList609 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_variableDeclarationList612 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_variableDeclarationList614 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList617 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _variableDeclarationNoIn_in_variableDeclarationListNoIn636 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_variableDeclarationListNoIn639 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_variableDeclarationListNoIn642 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_variableDeclarationListNoIn644 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_variableDeclarationListNoIn647 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _Identifier_in_variableDeclaration666 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _LT_in_variableDeclaration668 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _initialiser_in_variableDeclaration671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_variableDeclarationNoIn718 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _LT_in_variableDeclarationNoIn720 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _initialiserNoIn_in_variableDeclarationNoIn723 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_initialiser768 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_initialiser770 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_initialiser773 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_initialiserNoIn792 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_initialiserNoIn794 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_initialiserNoIn797 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_emptyStatement813 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionStatement834 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_expressionStatement837 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_expressionStatement841 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _94_in_ifStatement858 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_ifStatement860 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_ifStatement863 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_ifStatement865 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_ifStatement868 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_ifStatement870 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_ifStatement873 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_ifStatement875 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_ifStatement880 = new BitSet(new ulong[]{0x1000002UL,0x2000000UL});
		public static readonly BitSet _LT_in_ifStatement883 = new BitSet(new ulong[]{0x1000000UL,0x2000000UL});
		public static readonly BitSet _89_in_ifStatement886 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_ifStatement888 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_ifStatement893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doWhileStatement_in_iterationStatement929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_iterationStatement934 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_iterationStatement939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forInStatement_in_iterationStatement944 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _88_in_doWhileStatement956 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_doWhileStatement958 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_doWhileStatement961 = new BitSet(new ulong[]{0x1000000UL,0x100000000000UL});
		public static readonly BitSet _LT_in_doWhileStatement963 = new BitSet(new ulong[]{0x1000000UL,0x100000000000UL});
		public static readonly BitSet _108_in_doWhileStatement966 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_doWhileStatement968 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_doWhileStatement971 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_doWhileStatement973 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_doWhileStatement975 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_doWhileStatement978 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_doWhileStatement982 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _108_in_whileStatement1012 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_whileStatement1014 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_whileStatement1017 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_whileStatement1019 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_whileStatement1022 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_whileStatement1024 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_whileStatement1027 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_whileStatement1029 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_whileStatement1032 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_forStatement1062 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_forStatement1064 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_forStatement1067 = new BitSet(new ulong[]{0x8331010109200000UL,0x84EA624804000UL});
		public static readonly BitSet _LT_in_forStatement1070 = new BitSet(new ulong[]{0x331010109200000UL,0x84EA624804000UL});
		public static readonly BitSet _forStatementInitialiserPart_in_forStatement1073 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_forStatement1077 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _63_in_forStatement1080 = new BitSet(new ulong[]{0x8331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_forStatement1083 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_forStatement1088 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_forStatement1092 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _63_in_forStatement1095 = new BitSet(new ulong[]{0x333010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_forStatement1098 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_forStatement1103 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_forStatement1107 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_forStatement1110 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_forStatement1112 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_forStatement1115 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionNoIn_in_forStatementInitialiserPart1211 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _106_in_forStatementInitialiserPart1216 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_forStatementInitialiserPart1218 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationListNoIn_in_forStatementInitialiserPart1221 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_forInStatement1249 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_forInStatement1251 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_forInStatement1254 = new BitSet(new ulong[]{0x1000109200000UL,0x44A624004000UL});
		public static readonly BitSet _LT_in_forInStatement1256 = new BitSet(new ulong[]{0x1000109200000UL,0x44A624004000UL});
		public static readonly BitSet _forInStatementInitialiserPart_in_forInStatement1259 = new BitSet(new ulong[]{0x1000000UL,0x80000000UL});
		public static readonly BitSet _LT_in_forInStatement1261 = new BitSet(new ulong[]{0x1000000UL,0x80000000UL});
		public static readonly BitSet _95_in_forInStatement1264 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_forInStatement1266 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_forInStatement1269 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_forInStatement1271 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_forInStatement1274 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_forInStatement1276 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_forInStatement1279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_forInStatementInitialiserPart1321 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _106_in_forInStatementInitialiserPart1326 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_forInStatementInitialiserPart1328 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forInStatementInitialiserPart1331 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _85_in_continueStatement1346 = new BitSet(new ulong[]{0x8000000001200000UL});
		public static readonly BitSet _Identifier_in_continueStatement1348 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_continueStatement1352 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_continueStatement1356 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _82_in_breakStatement1390 = new BitSet(new ulong[]{0x8000000001200000UL});
		public static readonly BitSet _Identifier_in_breakStatement1392 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_breakStatement1396 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_breakStatement1400 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _99_in_returnStatement1431 = new BitSet(new ulong[]{0x8331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_returnStatement1433 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_returnStatement1437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_returnStatement1441 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _109_in_withStatement1468 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_withStatement1470 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_withStatement1473 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_withStatement1475 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_withStatement1478 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_withStatement1480 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_withStatement1483 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_withStatement1485 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_withStatement1488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_labelledStatement1517 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_labelledStatement1519 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_labelledStatement1522 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_labelledStatement1524 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_labelledStatement1527 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _100_in_switchStatement1568 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_switchStatement1570 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_switchStatement1573 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_switchStatement1575 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_switchStatement1578 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_switchStatement1580 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_switchStatement1583 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_switchStatement1585 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _caseBlock_in_switchStatement1588 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_caseBlock1617 = new BitSet(new ulong[]{0x1000000UL,0x4000000480000UL});
		public static readonly BitSet _LT_in_caseBlock1621 = new BitSet(new ulong[]{0x1000000UL,0x80000UL});
		public static readonly BitSet _caseClause_in_caseBlock1625 = new BitSet(new ulong[]{0x1000000UL,0x4000000480000UL});
		public static readonly BitSet _LT_in_caseBlock1630 = new BitSet(new ulong[]{0x1000000UL,0x400000UL});
		public static readonly BitSet _defaultClause_in_caseBlock1634 = new BitSet(new ulong[]{0x1000000UL,0x4000000080000UL});
		public static readonly BitSet _LT_in_caseBlock1637 = new BitSet(new ulong[]{0x1000000UL,0x80000UL});
		public static readonly BitSet _caseClause_in_caseBlock1641 = new BitSet(new ulong[]{0x1000000UL,0x4000000080000UL});
		public static readonly BitSet _LT_in_caseBlock1647 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_caseBlock1651 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _83_in_caseClause1663 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_caseClause1665 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_caseClause1668 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_caseClause1670 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_caseClause1673 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_caseClause1675 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _statementList_in_caseClause1678 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _86_in_defaultClause1707 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_defaultClause1709 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_defaultClause1712 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_defaultClause1714 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _statementList_in_defaultClause1717 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _102_in_throwStatement1744 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_throwStatement1746 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_throwStatement1749 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_throwStatement1753 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _104_in_tryStatement1778 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_tryStatement1780 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _statementBlock_in_tryStatement1783 = new BitSet(new ulong[]{0x1000000UL,0x8100000UL});
		public static readonly BitSet _LT_in_tryStatement1785 = new BitSet(new ulong[]{0x1000000UL,0x8100000UL});
		public static readonly BitSet _finallyClause_in_tryStatement1789 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _catchClause_in_tryStatement1793 = new BitSet(new ulong[]{0x1000002UL,0x8000000UL});
		public static readonly BitSet _LT_in_tryStatement1796 = new BitSet(new ulong[]{0x1000000UL,0x8000000UL});
		public static readonly BitSet _finallyClause_in_tryStatement1799 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _84_in_catchClause1841 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_catchClause1843 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_catchClause1846 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_catchClause1848 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_catchClause1851 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_catchClause1853 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_catchClause1856 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_catchClause1858 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _statementBlock_in_catchClause1861 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _91_in_finallyClause1895 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_finallyClause1897 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _statementBlock_in_finallyClause1900 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression1925 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_expression1928 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_expression1931 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_expression1933 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_expression1936 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn1955 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_expressionNoIn1958 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_expressionNoIn1961 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_expressionNoIn1963 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn1966 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression1985 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_assignmentExpression1996 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _LT_in_assignmentExpression1998 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression2003 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_assignmentExpression2005 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression2010 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn2297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_assignmentExpressionNoIn2308 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _LT_in_assignmentExpressionNoIn2310 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn2315 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_assignmentExpressionNoIn2317 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn2322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callExpression_in_leftHandSideExpression2663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_leftHandSideExpression2668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_newExpression2680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _97_in_newExpression2685 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _LT_in_newExpression2687 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _newExpression_in_newExpression2690 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonMemberExpression_in_memberExpression2727 = new BitSet(new ulong[]{0x800000001000002UL,0x4000UL});
		public static readonly BitSet _LT_in_memberExpression2756 = new BitSet(new ulong[]{0x800000001000000UL,0x4000UL});
		public static readonly BitSet _indexSuffix_in_memberExpression2790 = new BitSet(new ulong[]{0x800000001000002UL,0x4000UL});
		public static readonly BitSet _propertyReferenceSuffix_in_memberExpression2854 = new BitSet(new ulong[]{0x800000001000002UL,0x4000UL});
		public static readonly BitSet _primaryExpression_in_nonMemberExpression2926 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionExpression_in_nonMemberExpression2959 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _97_in_nonMemberExpression2991 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _LT_in_nonMemberExpression2993 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _memberExpression_in_nonMemberExpression2996 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_nonMemberExpression2999 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _arguments_in_nonMemberExpression3002 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryCallExpression_in_callExpression3043 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _LT_in_callExpression3073 = new BitSet(new ulong[]{0x801000001000000UL,0x4000UL});
		public static readonly BitSet _arguments_in_callExpression3109 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _indexSuffix_in_callExpression3162 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _propertyReferenceSuffix_in_callExpression3212 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _memberExpression_in_primaryCallExpression3274 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_primaryCallExpression3276 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _arguments_in_primaryCallExpression3281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_arguments3313 = new BitSet(new ulong[]{0x333010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_arguments3316 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_arguments3319 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_arguments3322 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_arguments3325 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_arguments3327 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_arguments3330 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_arguments3336 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_arguments3339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _78_in_indexSuffix3367 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_indexSuffix3369 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_indexSuffix3372 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
		public static readonly BitSet _LT_in_indexSuffix3374 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
		public static readonly BitSet _79_in_indexSuffix3377 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _59_in_propertyReferenceSuffix3394 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_propertyReferenceSuffix3396 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_propertyReferenceSuffix3399 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpression_in_conditionalExpression3421 = new BitSet(new ulong[]{0x1000002UL,0x2000UL});
		public static readonly BitSet _LT_in_conditionalExpression3431 = new BitSet(new ulong[]{0x1000000UL,0x2000UL});
		public static readonly BitSet _77_in_conditionalExpression3434 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpression3436 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression3441 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_conditionalExpression3443 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_conditionalExpression3446 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpression3448 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression3453 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn3503 = new BitSet(new ulong[]{0x1000002UL,0x2000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3513 = new BitSet(new ulong[]{0x1000000UL,0x2000UL});
		public static readonly BitSet _77_in_conditionalExpressionNoIn3516 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3518 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn3523 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3525 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_conditionalExpressionNoIn3528 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3530 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn3535 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression3586 = new BitSet(new ulong[]{0x1000002UL,0x2000000000000UL});
		public static readonly BitSet _LT_in_logicalORExpression3597 = new BitSet(new ulong[]{0x1000000UL,0x2000000000000UL});
		public static readonly BitSet _113_in_logicalORExpression3600 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalORExpression3602 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalORExpression_in_logicalORExpression3605 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn3653 = new BitSet(new ulong[]{0x1000002UL,0x2000000000000UL});
		public static readonly BitSet _LT_in_logicalORExpressionNoIn3663 = new BitSet(new ulong[]{0x1000000UL,0x2000000000000UL});
		public static readonly BitSet _113_in_logicalORExpressionNoIn3666 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalORExpressionNoIn3668 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_logicalORExpressionNoIn3671 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression3719 = new BitSet(new ulong[]{0x200001000002UL});
		public static readonly BitSet _LT_in_logicalANDExpression3730 = new BitSet(new ulong[]{0x200001000000UL});
		public static readonly BitSet _45_in_logicalANDExpression3733 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalANDExpression3735 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalANDExpression_in_logicalANDExpression3738 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn3786 = new BitSet(new ulong[]{0x200001000002UL});
		public static readonly BitSet _LT_in_logicalANDExpressionNoIn3796 = new BitSet(new ulong[]{0x200001000000UL});
		public static readonly BitSet _45_in_logicalANDExpressionNoIn3799 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalANDExpressionNoIn3801 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalANDExpressionNoIn3804 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression3852 = new BitSet(new ulong[]{0x1000002UL,0x800000000000UL});
		public static readonly BitSet _LT_in_bitwiseORExpression3862 = new BitSet(new ulong[]{0x1000000UL,0x800000000000UL});
		public static readonly BitSet _111_in_bitwiseORExpression3865 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseORExpression3867 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseORExpression_in_bitwiseORExpression3870 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3918 = new BitSet(new ulong[]{0x1000002UL,0x800000000000UL});
		public static readonly BitSet _LT_in_bitwiseORExpressionNoIn3928 = new BitSet(new ulong[]{0x1000000UL,0x800000000000UL});
		public static readonly BitSet _111_in_bitwiseORExpressionNoIn3931 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseORExpressionNoIn3933 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_bitwiseORExpressionNoIn3936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression3984 = new BitSet(new ulong[]{0x1000002UL,0x10000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpression3995 = new BitSet(new ulong[]{0x1000000UL,0x10000UL});
		public static readonly BitSet _80_in_bitwiseXORExpression3998 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpression4000 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseXORExpression4003 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4051 = new BitSet(new ulong[]{0x1000002UL,0x10000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpressionNoIn4061 = new BitSet(new ulong[]{0x1000000UL,0x10000UL});
		public static readonly BitSet _80_in_bitwiseXORExpressionNoIn4064 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpressionNoIn4066 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseXORExpressionNoIn4069 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression4117 = new BitSet(new ulong[]{0x400001000002UL});
		public static readonly BitSet _LT_in_bitwiseANDExpression4128 = new BitSet(new ulong[]{0x400001000000UL});
		public static readonly BitSet _46_in_bitwiseANDExpression4131 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseANDExpression4133 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseANDExpression4136 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn4184 = new BitSet(new ulong[]{0x400001000002UL});
		public static readonly BitSet _LT_in_bitwiseANDExpressionNoIn4194 = new BitSet(new ulong[]{0x400001000000UL});
		public static readonly BitSet _46_in_bitwiseANDExpressionNoIn4197 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseANDExpressionNoIn4199 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseANDExpressionNoIn4202 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4251 = new BitSet(new ulong[]{0x60001000002UL,0x60UL});
		public static readonly BitSet _LT_in_equalityExpression4262 = new BitSet(new ulong[]{0x60001000000UL,0x60UL});
		public static readonly BitSet _69_in_equalityExpression4268 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _41_in_equalityExpression4274 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _70_in_equalityExpression4280 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _42_in_equalityExpression4286 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_equalityExpression4289 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _equalityExpression_in_equalityExpression4294 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn4481 = new BitSet(new ulong[]{0x60001000002UL,0x60UL});
		public static readonly BitSet _LT_in_equalityExpressionNoIn4496 = new BitSet(new ulong[]{0x60001000000UL,0x60UL});
		public static readonly BitSet _69_in_equalityExpressionNoIn4511 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _41_in_equalityExpressionNoIn4535 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _70_in_equalityExpressionNoIn4559 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _42_in_equalityExpressionNoIn4583 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_equalityExpressionNoIn4606 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _equalityExpressionNoIn_in_equalityExpressionNoIn4609 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression4644 = new BitSet(new ulong[]{0x1000002UL,0x180000189UL});
		public static readonly BitSet _LT_in_relationalExpression4655 = new BitSet(new ulong[]{0x1000000UL,0x180000189UL});
		public static readonly BitSet _64_in_relationalExpression4661 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _71_in_relationalExpression4667 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _67_in_relationalExpression4673 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _72_in_relationalExpression4679 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _96_in_relationalExpression4685 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _95_in_relationalExpression4691 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_relationalExpression4694 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _relationalExpression_in_relationalExpression4699 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn4958 = new BitSet(new ulong[]{0x1000002UL,0x100000189UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn4974 = new BitSet(new ulong[]{0x1000000UL,0x100000189UL});
		public static readonly BitSet _64_in_relationalExpressionNoIn4989 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _71_in_relationalExpressionNoIn5017 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _67_in_relationalExpressionNoIn5044 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _72_in_relationalExpressionNoIn5071 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _96_in_relationalExpressionNoIn5098 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn5122 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _relationalExpressionNoIn_in_relationalExpressionNoIn5125 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression5165 = new BitSet(new ulong[]{0x1000002UL,0xA02UL});
		public static readonly BitSet _LT_in_shiftExpression5191 = new BitSet(new ulong[]{0x1000000UL,0xA02UL});
		public static readonly BitSet _65_in_shiftExpression5197 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _73_in_shiftExpression5203 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _75_in_shiftExpression5209 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_shiftExpression5212 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _shiftExpression_in_shiftExpression5217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression5388 = new BitSet(new ulong[]{0x110000001000002UL});
		public static readonly BitSet _LT_in_additiveExpression5397 = new BitSet(new ulong[]{0x110000001000000UL});
		public static readonly BitSet _52_in_additiveExpression5403 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _56_in_additiveExpression5409 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_additiveExpression5412 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _additiveExpression_in_additiveExpression5417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression5530 = new BitSet(new ulong[]{0x1004080001000002UL});
		public static readonly BitSet _LT_in_multiplicativeExpression5541 = new BitSet(new ulong[]{0x1004080001000000UL});
		public static readonly BitSet _50_in_multiplicativeExpression5547 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _60_in_multiplicativeExpression5553 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _43_in_multiplicativeExpression5559 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_multiplicativeExpression5562 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _multiplicativeExpression_in_multiplicativeExpression5567 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression5720 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _87_in_unaryExpression5756 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _107_in_unaryExpression5762 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _105_in_unaryExpression5768 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _53_in_unaryExpression5774 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _57_in_unaryExpression5780 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _52_in_unaryExpression5786 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _56_in_unaryExpression5792 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _115_in_unaryExpression5798 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _40_in_unaryExpression5804 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression5822 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_postfixExpression6074 = new BitSet(new ulong[]{0x220000000000002UL});
		public static readonly BitSet _53_in_postfixExpression6084 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _57_in_postfixExpression6104 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _101_in_primaryExpression6142 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_primaryExpression6163 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_primaryExpression6183 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression6197 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression6210 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_primaryExpression6223 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_primaryExpression6225 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_primaryExpression6228 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_primaryExpression6230 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_primaryExpression6233 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _78_in_arrayLiteral6250 = new BitSet(new ulong[]{0x3B1010109200000UL,0x84AA62480C000UL});
		public static readonly BitSet _LT_in_arrayLiteral6252 = new BitSet(new ulong[]{0x3B1010109200000UL,0x84AA62480C000UL});
		public static readonly BitSet _assignmentExpression_in_arrayLiteral6255 = new BitSet(new ulong[]{0x80000001000000UL,0x8000UL});
		public static readonly BitSet _LT_in_arrayLiteral6259 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_arrayLiteral6262 = new BitSet(new ulong[]{0x3B1010109200000UL,0x84AA62480C000UL});
		public static readonly BitSet _LT_in_arrayLiteral6265 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_arrayLiteral6268 = new BitSet(new ulong[]{0x80000001000000UL,0x8000UL});
		public static readonly BitSet _LT_in_arrayLiteral6274 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
		public static readonly BitSet _79_in_arrayLiteral6277 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_objectLiteral6312 = new BitSet(new ulong[]{0x109200000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_objectLiteral6315 = new BitSet(new ulong[]{0x109200000UL});
		public static readonly BitSet _propertyNameAndValue_in_objectLiteral6318 = new BitSet(new ulong[]{0x80000001000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_objectLiteral6321 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_objectLiteral6324 = new BitSet(new ulong[]{0x109200000UL});
		public static readonly BitSet _LT_in_objectLiteral6326 = new BitSet(new ulong[]{0x109200000UL});
		public static readonly BitSet _propertyNameAndValue_in_objectLiteral6329 = new BitSet(new ulong[]{0x80000001000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_objectLiteral6335 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_objectLiteral6338 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_propertyNameAndValue6366 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_propertyNameAndValue6368 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_propertyNameAndValue6371 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_propertyNameAndValue6373 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_propertyNameAndValue6376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_propertyName6405 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_propertyName6420 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NumericLiteral_in_propertyName6435 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _98_in_literal6456 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _103_in_literal6472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _90_in_literal6488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_literal6504 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NumericLiteral_in_literal6519 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_synpred5_JavaScript187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred9_JavaScript274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementBlock_in_synpred21_JavaScript430 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_synpred24_JavaScript445 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_synpred31_JavaScript480 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred34_JavaScript509 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred47_JavaScript668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred49_JavaScript720 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred60_JavaScript883 = new BitSet(new ulong[]{0x1000000UL,0x2000000UL});
		public static readonly BitSet _89_in_synpred60_JavaScript886 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_synpred60_JavaScript888 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_synpred60_JavaScript893 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_synpred63_JavaScript939 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred118_JavaScript1675 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred121_JavaScript1714 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpression_in_synpred140_JavaScript1985 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_synpred143_JavaScript2297 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callExpression_in_synpred157_JavaScript2663 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_synpred158_JavaScript2680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred162_JavaScript2756 = new BitSet(new ulong[]{0x800000001000000UL,0x4000UL});
		public static readonly BitSet _indexSuffix_in_synpred162_JavaScript2790 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyReferenceSuffix_in_synpred162_JavaScript2854 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred170_JavaScript3073 = new BitSet(new ulong[]{0x801000001000000UL,0x4000UL});
		public static readonly BitSet _arguments_in_synpred170_JavaScript3109 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indexSuffix_in_synpred170_JavaScript3162 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyReferenceSuffix_in_synpred170_JavaScript3212 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred256_JavaScript5397 = new BitSet(new ulong[]{0x110000001000000UL});
		public static readonly BitSet _52_in_synpred256_JavaScript5403 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _56_in_synpred256_JavaScript5409 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_synpred256_JavaScript5412 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _additiveExpression_in_synpred256_JavaScript5417 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred280_JavaScript6252 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Jacobsoft.Amd.Internals.AntlrGenerated 
