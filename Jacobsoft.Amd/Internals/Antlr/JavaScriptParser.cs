//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4.1.9004
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4.1.9004 JavaScript.g 2012-07-29 08:47:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace  Jacobsoft.Amd.Internals.AntlrGenerated 
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4.1.9004")]
[System.CLSCompliant(false)]
 internal  partial class JavaScriptParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ASSIGNMENT", "CALLEXPR", "CharacterEscapeSequence", "Comment", "DecimalDigit", "DecimalLiteral", "DoubleStringCharacter", "EscapeCharacter", "EscapeSequence", "ExponentPart", "FORSTMTCOND", "FORSTMTINCR", "FORSTMTINIT", "HexDigit", "HexEscapeSequence", "HexIntegerLiteral", "INDEXEXPR", "Identifier", "IdentifierPart", "IdentifierStart", "LT", "LineComment", "NonEscapeCharacter", "NumericLiteral", "PROGRAM", "PROPEXPR", "SingleEscapeCharacter", "SingleStringCharacter", "StringLiteral", "UnicodeCombiningMark", "UnicodeConnectorPunctuation", "UnicodeDigit", "UnicodeEscapeSequence", "UnicodeLetter", "VARIABLEDECL", "WhiteSpace", "'!'", "'!='", "'!=='", "'%'", "'%='", "'&&'", "'&'", "'&='", "'('", "')'", "'*'", "'*='", "'+'", "'++'", "'+='", "','", "'-'", "'--'", "'-='", "'.'", "'/'", "'/='", "':'", "';'", "'<'", "'<<'", "'<<='", "'<='", "'='", "'=='", "'==='", "'>'", "'>='", "'>>'", "'>>='", "'>>>'", "'>>>='", "'?'", "'['", "']'", "'^'", "'^='", "'break'", "'case'", "'catch'", "'continue'", "'default'", "'delete'", "'do'", "'else'", "'false'", "'finally'", "'for'", "'function'", "'if'", "'in'", "'instanceof'", "'new'", "'null'", "'return'", "'switch'", "'this'", "'throw'", "'true'", "'try'", "'typeof'", "'var'", "'void'", "'while'", "'with'", "'{'", "'|'", "'|='", "'||'", "'}'", "'~'"
	};
	public const int EOF=-1;
	public const int ASSIGNMENT=4;
	public const int CALLEXPR=5;
	public const int CharacterEscapeSequence=6;
	public const int Comment=7;
	public const int DecimalDigit=8;
	public const int DecimalLiteral=9;
	public const int DoubleStringCharacter=10;
	public const int EscapeCharacter=11;
	public const int EscapeSequence=12;
	public const int ExponentPart=13;
	public const int FORSTMTCOND=14;
	public const int FORSTMTINCR=15;
	public const int FORSTMTINIT=16;
	public const int HexDigit=17;
	public const int HexEscapeSequence=18;
	public const int HexIntegerLiteral=19;
	public const int INDEXEXPR=20;
	public const int Identifier=21;
	public const int IdentifierPart=22;
	public const int IdentifierStart=23;
	public const int LT=24;
	public const int LineComment=25;
	public const int NonEscapeCharacter=26;
	public const int NumericLiteral=27;
	public const int PROGRAM=28;
	public const int PROPEXPR=29;
	public const int SingleEscapeCharacter=30;
	public const int SingleStringCharacter=31;
	public const int StringLiteral=32;
	public const int UnicodeCombiningMark=33;
	public const int UnicodeConnectorPunctuation=34;
	public const int UnicodeDigit=35;
	public const int UnicodeEscapeSequence=36;
	public const int UnicodeLetter=37;
	public const int VARIABLEDECL=38;
	public const int WhiteSpace=39;
	public const int T__40=40;
	public const int T__41=41;
	public const int T__42=42;
	public const int T__43=43;
	public const int T__44=44;
	public const int T__45=45;
	public const int T__46=46;
	public const int T__47=47;
	public const int T__48=48;
	public const int T__49=49;
	public const int T__50=50;
	public const int T__51=51;
	public const int T__52=52;
	public const int T__53=53;
	public const int T__54=54;
	public const int T__55=55;
	public const int T__56=56;
	public const int T__57=57;
	public const int T__58=58;
	public const int T__59=59;
	public const int T__60=60;
	public const int T__61=61;
	public const int T__62=62;
	public const int T__63=63;
	public const int T__64=64;
	public const int T__65=65;
	public const int T__66=66;
	public const int T__67=67;
	public const int T__68=68;
	public const int T__69=69;
	public const int T__70=70;
	public const int T__71=71;
	public const int T__72=72;
	public const int T__73=73;
	public const int T__74=74;
	public const int T__75=75;
	public const int T__76=76;
	public const int T__77=77;
	public const int T__78=78;
	public const int T__79=79;
	public const int T__80=80;
	public const int T__81=81;
	public const int T__82=82;
	public const int T__83=83;
	public const int T__84=84;
	public const int T__85=85;
	public const int T__86=86;
	public const int T__87=87;
	public const int T__88=88;
	public const int T__89=89;
	public const int T__90=90;
	public const int T__91=91;
	public const int T__92=92;
	public const int T__93=93;
	public const int T__94=94;
	public const int T__95=95;
	public const int T__96=96;
	public const int T__97=97;
	public const int T__98=98;
	public const int T__99=99;
	public const int T__100=100;
	public const int T__101=101;
	public const int T__102=102;
	public const int T__103=103;
	public const int T__104=104;
	public const int T__105=105;
	public const int T__106=106;
	public const int T__107=107;
	public const int T__108=108;
	public const int T__109=109;
	public const int T__110=110;
	public const int T__111=111;
	public const int T__112=112;
	public const int T__113=113;
	public const int T__114=114;
	public const int T__115=115;

	public JavaScriptParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public JavaScriptParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		this.state.ruleMemo = new System.Collections.Generic.Dictionary<int, int>[382+1];


		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return JavaScriptParser.tokenNames; } }
	public override string GrammarFileName { get { return "JavaScript.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();
	// $ANTLR start "program"
	// JavaScript.g:35:8: public program : ( LT )* sourceElements ( LT )* EOF -> ^( PROGRAM sourceElements ) ;
	[GrammarRule("program")]
	public AstParserRuleReturnScope<CommonTree, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int program_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT1 = default(IToken);
		IToken LT3 = default(IToken);
		IToken EOF4 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElements2 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT1_tree = default(CommonTree);
		CommonTree LT3_tree = default(CommonTree);
		CommonTree EOF4_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_sourceElements=new RewriteRuleSubtreeStream(adaptor,"rule sourceElements");
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(35, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 1)) { return retval; }

			// JavaScript.g:36:2: ( ( LT )* sourceElements ( LT )* EOF -> ^( PROGRAM sourceElements ) )
			DebugEnterAlt(1);
			// JavaScript.g:36:4: ( LT )* sourceElements ( LT )* EOF
			{
			DebugLocation(36, 4);
			// JavaScript.g:36:4: ( LT )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_1 = input.LA(1);

				if ((LA1_1==LT))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:36:4: LT
					{
					DebugLocation(36, 4);
					LT1=(IToken)Match(input,LT,Follow._LT_in_program129); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT1);


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(36, 8);
			PushFollow(Follow._sourceElements_in_program132);
			sourceElements2=sourceElements();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sourceElements.Add(sourceElements2.Tree);
			DebugLocation(36, 23);
			// JavaScript.g:36:23: ( LT )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_1 = input.LA(1);

				if ((LA2_1==LT))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:36:23: LT
					{
					DebugLocation(36, 23);
					LT3=(IToken)Match(input,LT,Follow._LT_in_program134); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT3);


					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }

			DebugLocation(36, 27);
			EOF4=(IToken)Match(input,EOF,Follow._EOF_in_program137); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF4);



			{
			// AST REWRITE
			// elements: sourceElements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 36:31: -> ^( PROGRAM sourceElements )
			{
				DebugLocation(36, 34);
				// JavaScript.g:36:34: ^( PROGRAM sourceElements )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(36, 36);
				root_1 = (CommonTree)adaptor.BecomeRoot(new Program(PROGRAM), root_1);

				DebugLocation(36, 58);
				adaptor.AddChild(root_1, stream_sourceElements.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
			if (state.backtracking > 0) { Memoize(input, 1, program_StartIndex); }

		}
		DebugLocation(37, 1);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return retval;

	}
	// $ANTLR end "program"

	partial void EnterRule_sourceElements();
	partial void LeaveRule_sourceElements();
	// $ANTLR start "sourceElements"
	// JavaScript.g:39:1: sourceElements : sourceElement ( ( LT )* sourceElement )* -> ( sourceElement )+ ;
	[GrammarRule("sourceElements")]
	private AstParserRuleReturnScope<CommonTree, IToken> sourceElements()
	{
		EnterRule_sourceElements();
		EnterRule("sourceElements", 2);
		TraceIn("sourceElements", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sourceElements_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT6 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElement5 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElement7 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT6_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_sourceElement=new RewriteRuleSubtreeStream(adaptor,"rule sourceElement");
		try { DebugEnterRule(GrammarFileName, "sourceElements");
		DebugLocation(39, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 2)) { return retval; }

			// JavaScript.g:40:2: ( sourceElement ( ( LT )* sourceElement )* -> ( sourceElement )+ )
			DebugEnterAlt(1);
			// JavaScript.g:40:4: sourceElement ( ( LT )* sourceElement )*
			{
			DebugLocation(40, 4);
			PushFollow(Follow._sourceElement_in_sourceElements162);
			sourceElement5=sourceElement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_sourceElement.Add(sourceElement5.Tree);
			DebugLocation(40, 18);
			// JavaScript.g:40:18: ( ( LT )* sourceElement )*
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				try
				{
					alt4 = dfa4.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(4); }
				switch ( alt4 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:40:19: ( LT )* sourceElement
					{
					DebugLocation(40, 19);
					// JavaScript.g:40:19: ( LT )*
					try { DebugEnterSubRule(3);
					while (true)
					{
						int alt3=2;
						try { DebugEnterDecision(3, false);
						int LA3_1 = input.LA(1);

						if ((LA3_1==LT))
						{
							alt3 = 1;
						}


						} finally { DebugExitDecision(3); }
						switch ( alt3 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:40:19: LT
							{
							DebugLocation(40, 19);
							LT6=(IToken)Match(input,LT,Follow._LT_in_sourceElements165); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT6);


							}
							break;

						default:
							goto loop3;
						}
					}

					loop3:
						;

					} finally { DebugExitSubRule(3); }

					DebugLocation(40, 23);
					PushFollow(Follow._sourceElement_in_sourceElements168);
					sourceElement7=sourceElement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_sourceElement.Add(sourceElement7.Tree);

					}
					break;

				default:
					goto loop4;
				}
			}

			loop4:
				;

			} finally { DebugExitSubRule(4); }



			{
			// AST REWRITE
			// elements: sourceElement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 40:39: -> ( sourceElement )+
			{
				DebugLocation(40, 42);
				if (!(stream_sourceElement.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_sourceElement.HasNext )
				{
					DebugLocation(40, 42);
					adaptor.AddChild(root_0, stream_sourceElement.NextTree());

				}
				stream_sourceElement.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElements", 2);
			LeaveRule("sourceElements", 2);
			LeaveRule_sourceElements();
			if (state.backtracking > 0) { Memoize(input, 2, sourceElements_StartIndex); }

		}
		DebugLocation(41, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElements"); }
		return retval;

	}
	// $ANTLR end "sourceElements"

	partial void EnterRule_sourceElement();
	partial void LeaveRule_sourceElement();
	// $ANTLR start "sourceElement"
	// JavaScript.g:43:1: sourceElement : ( functionDeclaration | statement );
	[GrammarRule("sourceElement")]
	private AstParserRuleReturnScope<CommonTree, IToken> sourceElement()
	{
		EnterRule_sourceElement();
		EnterRule("sourceElement", 3);
		TraceIn("sourceElement", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int sourceElement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> functionDeclaration8 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement9 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "sourceElement");
		DebugLocation(43, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 3)) { return retval; }

			// JavaScript.g:44:2: ( functionDeclaration | statement )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_1 = input.LA(1);

			if ((LA5_1==93))
			{
				int LA5_2 = input.LA(2);

				if ((EvaluatePredicate(synpred5_JavaScript_fragment)))
				{
					alt5 = 1;
				}
				else if ((true))
				{
					alt5 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 5, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA5_1==Identifier||LA5_1==NumericLiteral||LA5_1==StringLiteral||LA5_1==40||LA5_1==48||(LA5_1>=52 && LA5_1<=53)||(LA5_1>=56 && LA5_1<=57)||LA5_1==63||LA5_1==78||LA5_1==82||LA5_1==85||(LA5_1>=87 && LA5_1<=88)||LA5_1==90||LA5_1==92||LA5_1==94||(LA5_1>=97 && LA5_1<=110)||LA5_1==115))
			{
				alt5 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:44:4: functionDeclaration
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(44, 4);
				PushFollow(Follow._functionDeclaration_in_sourceElement187);
				functionDeclaration8=functionDeclaration();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, functionDeclaration8.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:45:4: statement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(45, 4);
				PushFollow(Follow._statement_in_sourceElement192);
				statement9=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statement9.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("sourceElement", 3);
			LeaveRule("sourceElement", 3);
			LeaveRule_sourceElement();
			if (state.backtracking > 0) { Memoize(input, 3, sourceElement_StartIndex); }

		}
		DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "sourceElement"); }
		return retval;

	}
	// $ANTLR end "sourceElement"

	partial void EnterRule_functionDeclaration();
	partial void LeaveRule_functionDeclaration();
	// $ANTLR start "functionDeclaration"
	// JavaScript.g:49:1: functionDeclaration : 'function' ( LT )* Identifier ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' Identifier formalParameterList functionBody ) ;
	[GrammarRule("functionDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionDeclaration()
	{
		EnterRule_functionDeclaration();
		EnterRule("functionDeclaration", 4);
		TraceIn("functionDeclaration", 4);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionDeclaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal10 = default(IToken);
		IToken LT11 = default(IToken);
		IToken Identifier12 = default(IToken);
		IToken LT13 = default(IToken);
		IToken LT15 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> formalParameterList14 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionBody16 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal10_tree = default(CommonTree);
		CommonTree LT11_tree = default(CommonTree);
		CommonTree Identifier12_tree = default(CommonTree);
		CommonTree LT13_tree = default(CommonTree);
		CommonTree LT15_tree = default(CommonTree);
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_formalParameterList=new RewriteRuleSubtreeStream(adaptor,"rule formalParameterList");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionDeclaration");
		DebugLocation(49, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 4)) { return retval; }

			// JavaScript.g:50:2: ( 'function' ( LT )* Identifier ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' Identifier formalParameterList functionBody ) )
			DebugEnterAlt(1);
			// JavaScript.g:50:4: 'function' ( LT )* Identifier ( LT )* formalParameterList ( LT )* functionBody
			{
			DebugLocation(50, 4);
			string_literal10=(IToken)Match(input,93,Follow._93_in_functionDeclaration205); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_93.Add(string_literal10);

			DebugLocation(50, 15);
			// JavaScript.g:50:15: ( LT )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_1 = input.LA(1);

				if ((LA6_1==LT))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:50:15: LT
					{
					DebugLocation(50, 15);
					LT11=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration207); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT11);


					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(50, 19);
			Identifier12=(IToken)Match(input,Identifier,Follow._Identifier_in_functionDeclaration210); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier12);

			DebugLocation(50, 30);
			// JavaScript.g:50:30: ( LT )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_1 = input.LA(1);

				if ((LA7_1==LT))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:50:30: LT
					{
					DebugLocation(50, 30);
					LT13=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration212); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT13);


					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(50, 34);
			PushFollow(Follow._formalParameterList_in_functionDeclaration215);
			formalParameterList14=formalParameterList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_formalParameterList.Add(formalParameterList14.Tree);
			DebugLocation(50, 54);
			// JavaScript.g:50:54: ( LT )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_1 = input.LA(1);

				if ((LA8_1==LT))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:50:54: LT
					{
					DebugLocation(50, 54);
					LT15=(IToken)Match(input,LT,Follow._LT_in_functionDeclaration217); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT15);


					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }

			DebugLocation(50, 58);
			PushFollow(Follow._functionBody_in_functionDeclaration220);
			functionBody16=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody16.Tree);


			{
			// AST REWRITE
			// elements: 93, Identifier, formalParameterList, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 51:3: -> ^( 'function' Identifier formalParameterList functionBody )
			{
				DebugLocation(51, 6);
				// JavaScript.g:51:6: ^( 'function' Identifier formalParameterList functionBody )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(51, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FunctionDeclaration(stream_93.NextToken()), root_1);

				DebugLocation(52, 5);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(53, 5);
				adaptor.AddChild(root_1, stream_formalParameterList.NextTree());
				DebugLocation(54, 5);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionDeclaration", 4);
			LeaveRule("functionDeclaration", 4);
			LeaveRule_functionDeclaration();
			if (state.backtracking > 0) { Memoize(input, 4, functionDeclaration_StartIndex); }

		}
		DebugLocation(55, 1);
		} finally { DebugExitRule(GrammarFileName, "functionDeclaration"); }
		return retval;

	}
	// $ANTLR end "functionDeclaration"

	partial void EnterRule_functionExpression();
	partial void LeaveRule_functionExpression();
	// $ANTLR start "functionExpression"
	// JavaScript.g:57:1: functionExpression : 'function' ( LT )* ( Identifier )? ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' ( Identifier )? formalParameterList functionBody ) ;
	[GrammarRule("functionExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionExpression()
	{
		EnterRule_functionExpression();
		EnterRule("functionExpression", 5);
		TraceIn("functionExpression", 5);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal17 = default(IToken);
		IToken LT18 = default(IToken);
		IToken Identifier19 = default(IToken);
		IToken LT20 = default(IToken);
		IToken LT22 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> formalParameterList21 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionBody23 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal17_tree = default(CommonTree);
		CommonTree LT18_tree = default(CommonTree);
		CommonTree Identifier19_tree = default(CommonTree);
		CommonTree LT20_tree = default(CommonTree);
		CommonTree LT22_tree = default(CommonTree);
		RewriteRuleITokenStream stream_93=new RewriteRuleITokenStream(adaptor,"token 93");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleSubtreeStream stream_formalParameterList=new RewriteRuleSubtreeStream(adaptor,"rule formalParameterList");
		RewriteRuleSubtreeStream stream_functionBody=new RewriteRuleSubtreeStream(adaptor,"rule functionBody");
		try { DebugEnterRule(GrammarFileName, "functionExpression");
		DebugLocation(57, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 5)) { return retval; }

			// JavaScript.g:58:2: ( 'function' ( LT )* ( Identifier )? ( LT )* formalParameterList ( LT )* functionBody -> ^( 'function' ( Identifier )? formalParameterList functionBody ) )
			DebugEnterAlt(1);
			// JavaScript.g:58:4: 'function' ( LT )* ( Identifier )? ( LT )* formalParameterList ( LT )* functionBody
			{
			DebugLocation(58, 4);
			string_literal17=(IToken)Match(input,93,Follow._93_in_functionExpression272); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_93.Add(string_literal17);

			DebugLocation(58, 15);
			// JavaScript.g:58:15: ( LT )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_1 = input.LA(1);

				if ((LA9_1==LT))
				{
					int LA9_2 = input.LA(2);

					if ((EvaluatePredicate(synpred9_JavaScript_fragment)))
					{
						alt9 = 1;
					}


				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:58:15: LT
					{
					DebugLocation(58, 15);
					LT18=(IToken)Match(input,LT,Follow._LT_in_functionExpression274); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT18);


					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }

			DebugLocation(58, 19);
			// JavaScript.g:58:19: ( Identifier )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_1 = input.LA(1);

			if ((LA10_1==Identifier))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:58:19: Identifier
				{
				DebugLocation(58, 19);
				Identifier19=(IToken)Match(input,Identifier,Follow._Identifier_in_functionExpression277); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier19);


				}
				break;

			}
			} finally { DebugExitSubRule(10); }

			DebugLocation(58, 31);
			// JavaScript.g:58:31: ( LT )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_1 = input.LA(1);

				if ((LA11_1==LT))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:58:31: LT
					{
					DebugLocation(58, 31);
					LT20=(IToken)Match(input,LT,Follow._LT_in_functionExpression280); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT20);


					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }

			DebugLocation(58, 35);
			PushFollow(Follow._formalParameterList_in_functionExpression283);
			formalParameterList21=formalParameterList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_formalParameterList.Add(formalParameterList21.Tree);
			DebugLocation(58, 55);
			// JavaScript.g:58:55: ( LT )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_1 = input.LA(1);

				if ((LA12_1==LT))
				{
					alt12 = 1;
				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:58:55: LT
					{
					DebugLocation(58, 55);
					LT22=(IToken)Match(input,LT,Follow._LT_in_functionExpression285); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT22);


					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(58, 59);
			PushFollow(Follow._functionBody_in_functionExpression288);
			functionBody23=functionBody();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_functionBody.Add(functionBody23.Tree);


			{
			// AST REWRITE
			// elements: 93, Identifier, formalParameterList, functionBody
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 59:3: -> ^( 'function' ( Identifier )? formalParameterList functionBody )
			{
				DebugLocation(59, 6);
				// JavaScript.g:59:6: ^( 'function' ( Identifier )? formalParameterList functionBody )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(59, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FunctionExpression(stream_93.NextToken()), root_1);

				DebugLocation(60, 5);
				// JavaScript.g:60:5: ( Identifier )?
				if (stream_Identifier.HasNext)
				{
					DebugLocation(60, 5);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();
				DebugLocation(61, 5);
				adaptor.AddChild(root_1, stream_formalParameterList.NextTree());
				DebugLocation(62, 5);
				adaptor.AddChild(root_1, stream_functionBody.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionExpression", 5);
			LeaveRule("functionExpression", 5);
			LeaveRule_functionExpression();
			if (state.backtracking > 0) { Memoize(input, 5, functionExpression_StartIndex); }

		}
		DebugLocation(63, 1);
		} finally { DebugExitRule(GrammarFileName, "functionExpression"); }
		return retval;

	}
	// $ANTLR end "functionExpression"

	partial void EnterRule_formalParameterList();
	partial void LeaveRule_formalParameterList();
	// $ANTLR start "formalParameterList"
	// JavaScript.g:65:1: formalParameterList : '(' ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )? ( LT )* ')' -> ^( '(' ( Identifier )* ) ;
	[GrammarRule("formalParameterList")]
	private AstParserRuleReturnScope<CommonTree, IToken> formalParameterList()
	{
		EnterRule_formalParameterList();
		EnterRule("formalParameterList", 6);
		TraceIn("formalParameterList", 6);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int formalParameterList_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal24 = default(IToken);
		IToken LT25 = default(IToken);
		IToken Identifier26 = default(IToken);
		IToken LT27 = default(IToken);
		IToken char_literal28 = default(IToken);
		IToken LT29 = default(IToken);
		IToken Identifier30 = default(IToken);
		IToken LT31 = default(IToken);
		IToken char_literal32 = default(IToken);

		CommonTree char_literal24_tree = default(CommonTree);
		CommonTree LT25_tree = default(CommonTree);
		CommonTree Identifier26_tree = default(CommonTree);
		CommonTree LT27_tree = default(CommonTree);
		CommonTree char_literal28_tree = default(CommonTree);
		CommonTree LT29_tree = default(CommonTree);
		CommonTree Identifier30_tree = default(CommonTree);
		CommonTree LT31_tree = default(CommonTree);
		CommonTree char_literal32_tree = default(CommonTree);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		try { DebugEnterRule(GrammarFileName, "formalParameterList");
		DebugLocation(65, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 6)) { return retval; }

			// JavaScript.g:66:2: ( '(' ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )? ( LT )* ')' -> ^( '(' ( Identifier )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:66:4: '(' ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )? ( LT )* ')'
			{
			DebugLocation(66, 4);
			char_literal24=(IToken)Match(input,48,Follow._48_in_formalParameterList337); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal24);

			DebugLocation(66, 8);
			// JavaScript.g:66:8: ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )?
			int alt17=2;
			try { DebugEnterSubRule(17);
			try { DebugEnterDecision(17, false);
			try
			{
				alt17 = dfa17.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:66:9: ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )*
				{
				DebugLocation(66, 9);
				// JavaScript.g:66:9: ( LT )*
				try { DebugEnterSubRule(13);
				while (true)
				{
					int alt13=2;
					try { DebugEnterDecision(13, false);
					int LA13_1 = input.LA(1);

					if ((LA13_1==LT))
					{
						alt13 = 1;
					}


					} finally { DebugExitDecision(13); }
					switch ( alt13 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:66:9: LT
						{
						DebugLocation(66, 9);
						LT25=(IToken)Match(input,LT,Follow._LT_in_formalParameterList340); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT25);


						}
						break;

					default:
						goto loop13;
					}
				}

				loop13:
					;

				} finally { DebugExitSubRule(13); }

				DebugLocation(66, 13);
				Identifier26=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList343); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier26);

				DebugLocation(66, 24);
				// JavaScript.g:66:24: ( ( LT )* ',' ( LT )* Identifier )*
				try { DebugEnterSubRule(16);
				while (true)
				{
					int alt16=2;
					try { DebugEnterDecision(16, false);
					try
					{
						alt16 = dfa16.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(16); }
					switch ( alt16 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:66:25: ( LT )* ',' ( LT )* Identifier
						{
						DebugLocation(66, 25);
						// JavaScript.g:66:25: ( LT )*
						try { DebugEnterSubRule(14);
						while (true)
						{
							int alt14=2;
							try { DebugEnterDecision(14, false);
							int LA14_1 = input.LA(1);

							if ((LA14_1==LT))
							{
								alt14 = 1;
							}


							} finally { DebugExitDecision(14); }
							switch ( alt14 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:66:25: LT
								{
								DebugLocation(66, 25);
								LT27=(IToken)Match(input,LT,Follow._LT_in_formalParameterList346); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT27);


								}
								break;

							default:
								goto loop14;
							}
						}

						loop14:
							;

						} finally { DebugExitSubRule(14); }

						DebugLocation(66, 29);
						char_literal28=(IToken)Match(input,55,Follow._55_in_formalParameterList349); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal28);

						DebugLocation(66, 33);
						// JavaScript.g:66:33: ( LT )*
						try { DebugEnterSubRule(15);
						while (true)
						{
							int alt15=2;
							try { DebugEnterDecision(15, false);
							int LA15_1 = input.LA(1);

							if ((LA15_1==LT))
							{
								alt15 = 1;
							}


							} finally { DebugExitDecision(15); }
							switch ( alt15 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:66:33: LT
								{
								DebugLocation(66, 33);
								LT29=(IToken)Match(input,LT,Follow._LT_in_formalParameterList351); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT29);


								}
								break;

							default:
								goto loop15;
							}
						}

						loop15:
							;

						} finally { DebugExitSubRule(15); }

						DebugLocation(66, 37);
						Identifier30=(IToken)Match(input,Identifier,Follow._Identifier_in_formalParameterList354); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_Identifier.Add(Identifier30);


						}
						break;

					default:
						goto loop16;
					}
				}

				loop16:
					;

				} finally { DebugExitSubRule(16); }


				}
				break;

			}
			} finally { DebugExitSubRule(17); }

			DebugLocation(66, 52);
			// JavaScript.g:66:52: ( LT )*
			try { DebugEnterSubRule(18);
			while (true)
			{
				int alt18=2;
				try { DebugEnterDecision(18, false);
				int LA18_1 = input.LA(1);

				if ((LA18_1==LT))
				{
					alt18 = 1;
				}


				} finally { DebugExitDecision(18); }
				switch ( alt18 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:66:52: LT
					{
					DebugLocation(66, 52);
					LT31=(IToken)Match(input,LT,Follow._LT_in_formalParameterList360); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT31);


					}
					break;

				default:
					goto loop18;
				}
			}

			loop18:
				;

			} finally { DebugExitSubRule(18); }

			DebugLocation(66, 56);
			char_literal32=(IToken)Match(input,49,Follow._49_in_formalParameterList363); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal32);



			{
			// AST REWRITE
			// elements: 48, Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 67:3: -> ^( '(' ( Identifier )* )
			{
				DebugLocation(67, 6);
				// JavaScript.g:67:6: ^( '(' ( Identifier )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(67, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FormalParameterList(stream_48.NextToken()), root_1);

				DebugLocation(67, 38);
				// JavaScript.g:67:38: ( Identifier )*
				while ( stream_Identifier.HasNext )
				{
					DebugLocation(67, 38);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("formalParameterList", 6);
			LeaveRule("formalParameterList", 6);
			LeaveRule_formalParameterList();
			if (state.backtracking > 0) { Memoize(input, 6, formalParameterList_StartIndex); }

		}
		DebugLocation(68, 1);
		} finally { DebugExitRule(GrammarFileName, "formalParameterList"); }
		return retval;

	}
	// $ANTLR end "formalParameterList"

	partial void EnterRule_functionBody();
	partial void LeaveRule_functionBody();
	// $ANTLR start "functionBody"
	// JavaScript.g:70:1: functionBody : '{' ( LT )* ( sourceElements )? ( LT )* '}' -> ^( '{' ( sourceElements )? ) ;
	[GrammarRule("functionBody")]
	private AstParserRuleReturnScope<CommonTree, IToken> functionBody()
	{
		EnterRule_functionBody();
		EnterRule("functionBody", 7);
		TraceIn("functionBody", 7);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int functionBody_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal33 = default(IToken);
		IToken LT34 = default(IToken);
		IToken LT36 = default(IToken);
		IToken char_literal37 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> sourceElements35 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal33_tree = default(CommonTree);
		CommonTree LT34_tree = default(CommonTree);
		CommonTree LT36_tree = default(CommonTree);
		CommonTree char_literal37_tree = default(CommonTree);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_sourceElements=new RewriteRuleSubtreeStream(adaptor,"rule sourceElements");
		try { DebugEnterRule(GrammarFileName, "functionBody");
		DebugLocation(70, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 7)) { return retval; }

			// JavaScript.g:71:2: ( '{' ( LT )* ( sourceElements )? ( LT )* '}' -> ^( '{' ( sourceElements )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:71:4: '{' ( LT )* ( sourceElements )? ( LT )* '}'
			{
			DebugLocation(71, 4);
			char_literal33=(IToken)Match(input,110,Follow._110_in_functionBody395); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_110.Add(char_literal33);

			DebugLocation(71, 8);
			// JavaScript.g:71:8: ( LT )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_1 = input.LA(1);

				if ((LA19_1==LT))
				{
					int LA19_2 = input.LA(2);

					if ((EvaluatePredicate(synpred19_JavaScript_fragment)))
					{
						alt19 = 1;
					}


				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:71:8: LT
					{
					DebugLocation(71, 8);
					LT34=(IToken)Match(input,LT,Follow._LT_in_functionBody397); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT34);


					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }

			DebugLocation(71, 12);
			// JavaScript.g:71:12: ( sourceElements )?
			int alt20=2;
			try { DebugEnterSubRule(20);
			try { DebugEnterDecision(20, false);
			int LA20_1 = input.LA(1);

			if ((LA20_1==Identifier||LA20_1==NumericLiteral||LA20_1==StringLiteral||LA20_1==40||LA20_1==48||(LA20_1>=52 && LA20_1<=53)||(LA20_1>=56 && LA20_1<=57)||LA20_1==63||LA20_1==78||LA20_1==82||LA20_1==85||(LA20_1>=87 && LA20_1<=88)||LA20_1==90||(LA20_1>=92 && LA20_1<=94)||(LA20_1>=97 && LA20_1<=110)||LA20_1==115))
			{
				alt20 = 1;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:71:12: sourceElements
				{
				DebugLocation(71, 12);
				PushFollow(Follow._sourceElements_in_functionBody400);
				sourceElements35=sourceElements();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_sourceElements.Add(sourceElements35.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(20); }

			DebugLocation(71, 28);
			// JavaScript.g:71:28: ( LT )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_1 = input.LA(1);

				if ((LA21_1==LT))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:71:28: LT
					{
					DebugLocation(71, 28);
					LT36=(IToken)Match(input,LT,Follow._LT_in_functionBody403); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT36);


					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }

			DebugLocation(71, 32);
			char_literal37=(IToken)Match(input,114,Follow._114_in_functionBody406); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_114.Add(char_literal37);



			{
			// AST REWRITE
			// elements: 110, sourceElements
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 71:36: -> ^( '{' ( sourceElements )? )
			{
				DebugLocation(71, 39);
				// JavaScript.g:71:39: ^( '{' ( sourceElements )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(71, 41);
				root_1 = (CommonTree)adaptor.BecomeRoot(new StatementBlock(stream_110.NextToken()), root_1);

				DebugLocation(71, 66);
				// JavaScript.g:71:66: ( sourceElements )?
				if (stream_sourceElements.HasNext)
				{
					DebugLocation(71, 66);
					adaptor.AddChild(root_1, stream_sourceElements.NextTree());

				}
				stream_sourceElements.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("functionBody", 7);
			LeaveRule("functionBody", 7);
			LeaveRule_functionBody();
			if (state.backtracking > 0) { Memoize(input, 7, functionBody_StartIndex); }

		}
		DebugLocation(72, 1);
		} finally { DebugExitRule(GrammarFileName, "functionBody"); }
		return retval;

	}
	// $ANTLR end "functionBody"

	partial void EnterRule_statement();
	partial void LeaveRule_statement();
	// $ANTLR start "statement"
	// JavaScript.g:75:1: statement : ( statementBlock | variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement );
	[GrammarRule("statement")]
	private AstParserRuleReturnScope<CommonTree, IToken> statement()
	{
		EnterRule_statement();
		EnterRule("statement", 8);
		TraceIn("statement", 8);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> statementBlock38 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableStatement39 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> emptyStatement40 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expressionStatement41 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ifStatement42 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> iterationStatement43 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> continueStatement44 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> breakStatement45 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> returnStatement46 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> withStatement47 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> labelledStatement48 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> switchStatement49 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> throwStatement50 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> tryStatement51 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "statement");
		DebugLocation(75, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 8)) { return retval; }

			// JavaScript.g:76:2: ( statementBlock | variableStatement | emptyStatement | expressionStatement | ifStatement | iterationStatement | continueStatement | breakStatement | returnStatement | withStatement | labelledStatement | switchStatement | throwStatement | tryStatement )
			int alt22=14;
			try { DebugEnterDecision(22, false);
			switch (input.LA(1))
			{
			case 110:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred22_JavaScript_fragment)))
				{
					alt22 = 1;
				}
				else if ((EvaluatePredicate(synpred25_JavaScript_fragment)))
				{
					alt22 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 106:
				{
				alt22 = 2;
				}
				break;
			case 63:
				{
				alt22 = 3;
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 40:
			case 48:
			case 52:
			case 53:
			case 56:
			case 57:
			case 78:
			case 87:
			case 90:
			case 93:
			case 97:
			case 98:
			case 101:
			case 103:
			case 105:
			case 107:
			case 115:
				{
				alt22 = 4;
				}
				break;
			case Identifier:
				{
				int LA22_2 = input.LA(2);

				if ((EvaluatePredicate(synpred25_JavaScript_fragment)))
				{
					alt22 = 4;
				}
				else if ((EvaluatePredicate(synpred32_JavaScript_fragment)))
				{
					alt22 = 11;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 94:
				{
				alt22 = 5;
				}
				break;
			case 88:
			case 92:
			case 108:
				{
				alt22 = 6;
				}
				break;
			case 85:
				{
				alt22 = 7;
				}
				break;
			case 82:
				{
				alt22 = 8;
				}
				break;
			case 99:
				{
				alt22 = 9;
				}
				break;
			case 109:
				{
				alt22 = 10;
				}
				break;
			case 100:
				{
				alt22 = 12;
				}
				break;
			case 102:
				{
				alt22 = 13;
				}
				break;
			case 104:
				{
				alt22 = 14;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 22, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(22); }
			switch (alt22)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:76:4: statementBlock
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(76, 4);
				PushFollow(Follow._statementBlock_in_statement432);
				statementBlock38=statementBlock();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, statementBlock38.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:77:4: variableStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(77, 4);
				PushFollow(Follow._variableStatement_in_statement437);
				variableStatement39=variableStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, variableStatement39.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:78:4: emptyStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(78, 4);
				PushFollow(Follow._emptyStatement_in_statement442);
				emptyStatement40=emptyStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, emptyStatement40.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:79:4: expressionStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(79, 4);
				PushFollow(Follow._expressionStatement_in_statement447);
				expressionStatement41=expressionStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionStatement41.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:80:4: ifStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(80, 4);
				PushFollow(Follow._ifStatement_in_statement452);
				ifStatement42=ifStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, ifStatement42.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:81:4: iterationStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(81, 4);
				PushFollow(Follow._iterationStatement_in_statement457);
				iterationStatement43=iterationStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, iterationStatement43.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// JavaScript.g:82:4: continueStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(82, 4);
				PushFollow(Follow._continueStatement_in_statement462);
				continueStatement44=continueStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, continueStatement44.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// JavaScript.g:83:4: breakStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(83, 4);
				PushFollow(Follow._breakStatement_in_statement467);
				breakStatement45=breakStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, breakStatement45.Tree);

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// JavaScript.g:84:4: returnStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(84, 4);
				PushFollow(Follow._returnStatement_in_statement472);
				returnStatement46=returnStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, returnStatement46.Tree);

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// JavaScript.g:85:4: withStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(85, 4);
				PushFollow(Follow._withStatement_in_statement477);
				withStatement47=withStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, withStatement47.Tree);

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// JavaScript.g:86:4: labelledStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(86, 4);
				PushFollow(Follow._labelledStatement_in_statement482);
				labelledStatement48=labelledStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, labelledStatement48.Tree);

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// JavaScript.g:87:4: switchStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(87, 4);
				PushFollow(Follow._switchStatement_in_statement487);
				switchStatement49=switchStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, switchStatement49.Tree);

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// JavaScript.g:88:4: throwStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(88, 4);
				PushFollow(Follow._throwStatement_in_statement492);
				throwStatement50=throwStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, throwStatement50.Tree);

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// JavaScript.g:89:4: tryStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(89, 4);
				PushFollow(Follow._tryStatement_in_statement497);
				tryStatement51=tryStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, tryStatement51.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statement", 8);
			LeaveRule("statement", 8);
			LeaveRule_statement();
			if (state.backtracking > 0) { Memoize(input, 8, statement_StartIndex); }

		}
		DebugLocation(90, 1);
		} finally { DebugExitRule(GrammarFileName, "statement"); }
		return retval;

	}
	// $ANTLR end "statement"

	partial void EnterRule_statementBlock();
	partial void LeaveRule_statementBlock();
	// $ANTLR start "statementBlock"
	// JavaScript.g:92:1: statementBlock : '{' ( LT )* ( statementList )? ( LT )* '}' -> ^( '{' ( statementList )? ) ;
	[GrammarRule("statementBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> statementBlock()
	{
		EnterRule_statementBlock();
		EnterRule("statementBlock", 9);
		TraceIn("statementBlock", 9);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statementBlock_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal52 = default(IToken);
		IToken LT53 = default(IToken);
		IToken LT55 = default(IToken);
		IToken char_literal56 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementList54 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal52_tree = default(CommonTree);
		CommonTree LT53_tree = default(CommonTree);
		CommonTree LT55_tree = default(CommonTree);
		CommonTree char_literal56_tree = default(CommonTree);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_statementList=new RewriteRuleSubtreeStream(adaptor,"rule statementList");
		try { DebugEnterRule(GrammarFileName, "statementBlock");
		DebugLocation(92, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 9)) { return retval; }

			// JavaScript.g:93:2: ( '{' ( LT )* ( statementList )? ( LT )* '}' -> ^( '{' ( statementList )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:93:4: '{' ( LT )* ( statementList )? ( LT )* '}'
			{
			DebugLocation(93, 4);
			char_literal52=(IToken)Match(input,110,Follow._110_in_statementBlock509); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_110.Add(char_literal52);

			DebugLocation(93, 8);
			// JavaScript.g:93:8: ( LT )*
			try { DebugEnterSubRule(23);
			while (true)
			{
				int alt23=2;
				try { DebugEnterDecision(23, false);
				int LA23_1 = input.LA(1);

				if ((LA23_1==LT))
				{
					int LA23_2 = input.LA(2);

					if ((EvaluatePredicate(synpred35_JavaScript_fragment)))
					{
						alt23 = 1;
					}


				}


				} finally { DebugExitDecision(23); }
				switch ( alt23 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:93:8: LT
					{
					DebugLocation(93, 8);
					LT53=(IToken)Match(input,LT,Follow._LT_in_statementBlock511); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT53);


					}
					break;

				default:
					goto loop23;
				}
			}

			loop23:
				;

			} finally { DebugExitSubRule(23); }

			DebugLocation(93, 12);
			// JavaScript.g:93:12: ( statementList )?
			int alt24=2;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			int LA24_1 = input.LA(1);

			if ((LA24_1==Identifier||LA24_1==NumericLiteral||LA24_1==StringLiteral||LA24_1==40||LA24_1==48||(LA24_1>=52 && LA24_1<=53)||(LA24_1>=56 && LA24_1<=57)||LA24_1==63||LA24_1==78||LA24_1==82||LA24_1==85||(LA24_1>=87 && LA24_1<=88)||LA24_1==90||(LA24_1>=92 && LA24_1<=94)||(LA24_1>=97 && LA24_1<=110)||LA24_1==115))
			{
				alt24 = 1;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:93:12: statementList
				{
				DebugLocation(93, 12);
				PushFollow(Follow._statementList_in_statementBlock514);
				statementList54=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statementList.Add(statementList54.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(24); }

			DebugLocation(93, 27);
			// JavaScript.g:93:27: ( LT )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_1 = input.LA(1);

				if ((LA25_1==LT))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:93:27: LT
					{
					DebugLocation(93, 27);
					LT55=(IToken)Match(input,LT,Follow._LT_in_statementBlock517); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT55);


					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }

			DebugLocation(93, 31);
			char_literal56=(IToken)Match(input,114,Follow._114_in_statementBlock520); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_114.Add(char_literal56);



			{
			// AST REWRITE
			// elements: 110, statementList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 93:35: -> ^( '{' ( statementList )? )
			{
				DebugLocation(93, 38);
				// JavaScript.g:93:38: ^( '{' ( statementList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(93, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(new StatementBlock(stream_110.NextToken()), root_1);

				DebugLocation(93, 65);
				// JavaScript.g:93:65: ( statementList )?
				if (stream_statementList.HasNext)
				{
					DebugLocation(93, 65);
					adaptor.AddChild(root_1, stream_statementList.NextTree());

				}
				stream_statementList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementBlock", 9);
			LeaveRule("statementBlock", 9);
			LeaveRule_statementBlock();
			if (state.backtracking > 0) { Memoize(input, 9, statementBlock_StartIndex); }

		}
		DebugLocation(94, 1);
		} finally { DebugExitRule(GrammarFileName, "statementBlock"); }
		return retval;

	}
	// $ANTLR end "statementBlock"

	partial void EnterRule_statementList();
	partial void LeaveRule_statementList();
	// $ANTLR start "statementList"
	// JavaScript.g:96:1: statementList : statement ( ( LT !)* statement )* ;
	[GrammarRule("statementList")]
	private AstParserRuleReturnScope<CommonTree, IToken> statementList()
	{
		EnterRule_statementList();
		EnterRule("statementList", 10);
		TraceIn("statementList", 10);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int statementList_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT58 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement57 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement59 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT58_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "statementList");
		DebugLocation(96, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 10)) { return retval; }

			// JavaScript.g:97:2: ( statement ( ( LT !)* statement )* )
			DebugEnterAlt(1);
			// JavaScript.g:97:4: statement ( ( LT !)* statement )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(97, 4);
			PushFollow(Follow._statement_in_statementList546);
			statement57=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, statement57.Tree);
			DebugLocation(97, 14);
			// JavaScript.g:97:14: ( ( LT !)* statement )*
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				try
				{
					alt27 = dfa27.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(27); }
				switch ( alt27 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:97:15: ( LT !)* statement
					{
					DebugLocation(97, 17);
					// JavaScript.g:97:17: ( LT !)*
					try { DebugEnterSubRule(26);
					while (true)
					{
						int alt26=2;
						try { DebugEnterDecision(26, false);
						int LA26_1 = input.LA(1);

						if ((LA26_1==LT))
						{
							alt26 = 1;
						}


						} finally { DebugExitDecision(26); }
						switch ( alt26 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:97:17: LT !
							{
							DebugLocation(97, 17);
							LT58=(IToken)Match(input,LT,Follow._LT_in_statementList549); if (state.failed) return retval;

							}
							break;

						default:
							goto loop26;
						}
					}

					loop26:
						;

					} finally { DebugExitSubRule(26); }

					DebugLocation(97, 20);
					PushFollow(Follow._statement_in_statementList553);
					statement59=statement();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, statement59.Tree);

					}
					break;

				default:
					goto loop27;
				}
			}

			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("statementList", 10);
			LeaveRule("statementList", 10);
			LeaveRule_statementList();
			if (state.backtracking > 0) { Memoize(input, 10, statementList_StartIndex); }

		}
		DebugLocation(98, 1);
		} finally { DebugExitRule(GrammarFileName, "statementList"); }
		return retval;

	}
	// $ANTLR end "statementList"

	partial void EnterRule_variableStatement();
	partial void LeaveRule_variableStatement();
	// $ANTLR start "variableStatement"
	// JavaScript.g:100:1: variableStatement : 'var' ( LT )* variableDeclarationList ( LT | ';' ) -> ^( 'var' variableDeclarationList ) ;
	[GrammarRule("variableStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableStatement()
	{
		EnterRule_variableStatement();
		EnterRule("variableStatement", 11);
		TraceIn("variableStatement", 11);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal60 = default(IToken);
		IToken LT61 = default(IToken);
		IToken LT63 = default(IToken);
		IToken char_literal64 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationList62 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal60_tree = default(CommonTree);
		CommonTree LT61_tree = default(CommonTree);
		CommonTree LT63_tree = default(CommonTree);
		CommonTree char_literal64_tree = default(CommonTree);
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_variableDeclarationList=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationList");
		try { DebugEnterRule(GrammarFileName, "variableStatement");
		DebugLocation(100, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 11)) { return retval; }

			// JavaScript.g:101:2: ( 'var' ( LT )* variableDeclarationList ( LT | ';' ) -> ^( 'var' variableDeclarationList ) )
			DebugEnterAlt(1);
			// JavaScript.g:101:4: 'var' ( LT )* variableDeclarationList ( LT | ';' )
			{
			DebugLocation(101, 4);
			string_literal60=(IToken)Match(input,106,Follow._106_in_variableStatement567); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_106.Add(string_literal60);

			DebugLocation(101, 10);
			// JavaScript.g:101:10: ( LT )*
			try { DebugEnterSubRule(28);
			while (true)
			{
				int alt28=2;
				try { DebugEnterDecision(28, false);
				int LA28_1 = input.LA(1);

				if ((LA28_1==LT))
				{
					alt28 = 1;
				}


				} finally { DebugExitDecision(28); }
				switch ( alt28 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:101:10: LT
					{
					DebugLocation(101, 10);
					LT61=(IToken)Match(input,LT,Follow._LT_in_variableStatement569); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT61);


					}
					break;

				default:
					goto loop28;
				}
			}

			loop28:
				;

			} finally { DebugExitSubRule(28); }

			DebugLocation(101, 14);
			PushFollow(Follow._variableDeclarationList_in_variableStatement572);
			variableDeclarationList62=variableDeclarationList();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationList.Add(variableDeclarationList62.Tree);
			DebugLocation(101, 38);
			// JavaScript.g:101:38: ( LT | ';' )
			int alt29=2;
			try { DebugEnterSubRule(29);
			try { DebugEnterDecision(29, false);
			int LA29_1 = input.LA(1);

			if ((LA29_1==LT))
			{
				alt29 = 1;
			}
			else if ((LA29_1==63))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:101:39: LT
				{
				DebugLocation(101, 39);
				LT63=(IToken)Match(input,LT,Follow._LT_in_variableStatement575); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT63);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:101:44: ';'
				{
				DebugLocation(101, 44);
				char_literal64=(IToken)Match(input,63,Follow._63_in_variableStatement579); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal64);


				}
				break;

			}
			} finally { DebugExitSubRule(29); }



			{
			// AST REWRITE
			// elements: 106, variableDeclarationList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 102:3: -> ^( 'var' variableDeclarationList )
			{
				DebugLocation(102, 6);
				// JavaScript.g:102:6: ^( 'var' variableDeclarationList )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(102, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new VariableStatement(stream_106.NextToken()), root_1);

				DebugLocation(102, 38);
				adaptor.AddChild(root_1, stream_variableDeclarationList.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableStatement", 11);
			LeaveRule("variableStatement", 11);
			LeaveRule_variableStatement();
			if (state.backtracking > 0) { Memoize(input, 11, variableStatement_StartIndex); }

		}
		DebugLocation(103, 1);
		} finally { DebugExitRule(GrammarFileName, "variableStatement"); }
		return retval;

	}
	// $ANTLR end "variableStatement"

	partial void EnterRule_variableDeclarationList();
	partial void LeaveRule_variableDeclarationList();
	// $ANTLR start "variableDeclarationList"
	// JavaScript.g:105:1: variableDeclarationList : variableDeclaration ( ( LT )* ',' ( LT )* variableDeclaration )* -> ( variableDeclaration )+ ;
	[GrammarRule("variableDeclarationList")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationList()
	{
		EnterRule_variableDeclarationList();
		EnterRule("variableDeclarationList", 12);
		TraceIn("variableDeclarationList", 12);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationList_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT66 = default(IToken);
		IToken char_literal67 = default(IToken);
		IToken LT68 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclaration65 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclaration69 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT66_tree = default(CommonTree);
		CommonTree char_literal67_tree = default(CommonTree);
		CommonTree LT68_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_variableDeclaration=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclaration");
		try { DebugEnterRule(GrammarFileName, "variableDeclarationList");
		DebugLocation(105, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 12)) { return retval; }

			// JavaScript.g:106:2: ( variableDeclaration ( ( LT )* ',' ( LT )* variableDeclaration )* -> ( variableDeclaration )+ )
			DebugEnterAlt(1);
			// JavaScript.g:106:4: variableDeclaration ( ( LT )* ',' ( LT )* variableDeclaration )*
			{
			DebugLocation(106, 4);
			PushFollow(Follow._variableDeclaration_in_variableDeclarationList608);
			variableDeclaration65=variableDeclaration();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration65.Tree);
			DebugLocation(106, 24);
			// JavaScript.g:106:24: ( ( LT )* ',' ( LT )* variableDeclaration )*
			try { DebugEnterSubRule(32);
			while (true)
			{
				int alt32=2;
				try { DebugEnterDecision(32, false);
				try
				{
					alt32 = dfa32.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(32); }
				switch ( alt32 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:106:25: ( LT )* ',' ( LT )* variableDeclaration
					{
					DebugLocation(106, 25);
					// JavaScript.g:106:25: ( LT )*
					try { DebugEnterSubRule(30);
					while (true)
					{
						int alt30=2;
						try { DebugEnterDecision(30, false);
						int LA30_1 = input.LA(1);

						if ((LA30_1==LT))
						{
							alt30 = 1;
						}


						} finally { DebugExitDecision(30); }
						switch ( alt30 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:106:25: LT
							{
							DebugLocation(106, 25);
							LT66=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationList611); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT66);


							}
							break;

						default:
							goto loop30;
						}
					}

					loop30:
						;

					} finally { DebugExitSubRule(30); }

					DebugLocation(106, 29);
					char_literal67=(IToken)Match(input,55,Follow._55_in_variableDeclarationList614); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal67);

					DebugLocation(106, 33);
					// JavaScript.g:106:33: ( LT )*
					try { DebugEnterSubRule(31);
					while (true)
					{
						int alt31=2;
						try { DebugEnterDecision(31, false);
						int LA31_1 = input.LA(1);

						if ((LA31_1==LT))
						{
							alt31 = 1;
						}


						} finally { DebugExitDecision(31); }
						switch ( alt31 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:106:33: LT
							{
							DebugLocation(106, 33);
							LT68=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationList616); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT68);


							}
							break;

						default:
							goto loop31;
						}
					}

					loop31:
						;

					} finally { DebugExitSubRule(31); }

					DebugLocation(106, 37);
					PushFollow(Follow._variableDeclaration_in_variableDeclarationList619);
					variableDeclaration69=variableDeclaration();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclaration.Add(variableDeclaration69.Tree);

					}
					break;

				default:
					goto loop32;
				}
			}

			loop32:
				;

			} finally { DebugExitSubRule(32); }



			{
			// AST REWRITE
			// elements: variableDeclaration
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 106:59: -> ( variableDeclaration )+
			{
				DebugLocation(106, 62);
				if (!(stream_variableDeclaration.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclaration.HasNext )
				{
					DebugLocation(106, 62);
					adaptor.AddChild(root_0, stream_variableDeclaration.NextTree());

				}
				stream_variableDeclaration.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationList", 12);
			LeaveRule("variableDeclarationList", 12);
			LeaveRule_variableDeclarationList();
			if (state.backtracking > 0) { Memoize(input, 12, variableDeclarationList_StartIndex); }

		}
		DebugLocation(107, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationList"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationList"

	partial void EnterRule_variableDeclarationListNoIn();
	partial void LeaveRule_variableDeclarationListNoIn();
	// $ANTLR start "variableDeclarationListNoIn"
	// JavaScript.g:109:1: variableDeclarationListNoIn : variableDeclarationNoIn ( ( LT )* ',' ( LT )* variableDeclarationNoIn )* -> ( variableDeclarationNoIn )+ ;
	[GrammarRule("variableDeclarationListNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationListNoIn()
	{
		EnterRule_variableDeclarationListNoIn();
		EnterRule("variableDeclarationListNoIn", 13);
		TraceIn("variableDeclarationListNoIn", 13);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationListNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT71 = default(IToken);
		IToken char_literal72 = default(IToken);
		IToken LT73 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn70 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn74 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT71_tree = default(CommonTree);
		CommonTree char_literal72_tree = default(CommonTree);
		CommonTree LT73_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_variableDeclarationNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationNoIn");
		try { DebugEnterRule(GrammarFileName, "variableDeclarationListNoIn");
		DebugLocation(109, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 13)) { return retval; }

			// JavaScript.g:110:2: ( variableDeclarationNoIn ( ( LT )* ',' ( LT )* variableDeclarationNoIn )* -> ( variableDeclarationNoIn )+ )
			DebugEnterAlt(1);
			// JavaScript.g:110:4: variableDeclarationNoIn ( ( LT )* ',' ( LT )* variableDeclarationNoIn )*
			{
			DebugLocation(110, 4);
			PushFollow(Follow._variableDeclarationNoIn_in_variableDeclarationListNoIn638);
			variableDeclarationNoIn70=variableDeclarationNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn70.Tree);
			DebugLocation(110, 28);
			// JavaScript.g:110:28: ( ( LT )* ',' ( LT )* variableDeclarationNoIn )*
			try { DebugEnterSubRule(35);
			while (true)
			{
				int alt35=2;
				try { DebugEnterDecision(35, false);
				try
				{
					alt35 = dfa35.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(35); }
				switch ( alt35 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:110:29: ( LT )* ',' ( LT )* variableDeclarationNoIn
					{
					DebugLocation(110, 29);
					// JavaScript.g:110:29: ( LT )*
					try { DebugEnterSubRule(33);
					while (true)
					{
						int alt33=2;
						try { DebugEnterDecision(33, false);
						int LA33_1 = input.LA(1);

						if ((LA33_1==LT))
						{
							alt33 = 1;
						}


						} finally { DebugExitDecision(33); }
						switch ( alt33 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:110:29: LT
							{
							DebugLocation(110, 29);
							LT71=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationListNoIn641); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT71);


							}
							break;

						default:
							goto loop33;
						}
					}

					loop33:
						;

					} finally { DebugExitSubRule(33); }

					DebugLocation(110, 33);
					char_literal72=(IToken)Match(input,55,Follow._55_in_variableDeclarationListNoIn644); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal72);

					DebugLocation(110, 37);
					// JavaScript.g:110:37: ( LT )*
					try { DebugEnterSubRule(34);
					while (true)
					{
						int alt34=2;
						try { DebugEnterDecision(34, false);
						int LA34_1 = input.LA(1);

						if ((LA34_1==LT))
						{
							alt34 = 1;
						}


						} finally { DebugExitDecision(34); }
						switch ( alt34 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:110:37: LT
							{
							DebugLocation(110, 37);
							LT73=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationListNoIn646); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT73);


							}
							break;

						default:
							goto loop34;
						}
					}

					loop34:
						;

					} finally { DebugExitSubRule(34); }

					DebugLocation(110, 41);
					PushFollow(Follow._variableDeclarationNoIn_in_variableDeclarationListNoIn649);
					variableDeclarationNoIn74=variableDeclarationNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn74.Tree);

					}
					break;

				default:
					goto loop35;
				}
			}

			loop35:
				;

			} finally { DebugExitSubRule(35); }



			{
			// AST REWRITE
			// elements: variableDeclarationNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 110:67: -> ( variableDeclarationNoIn )+
			{
				DebugLocation(110, 70);
				if (!(stream_variableDeclarationNoIn.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_variableDeclarationNoIn.HasNext )
				{
					DebugLocation(110, 70);
					adaptor.AddChild(root_0, stream_variableDeclarationNoIn.NextTree());

				}
				stream_variableDeclarationNoIn.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationListNoIn", 13);
			LeaveRule("variableDeclarationListNoIn", 13);
			LeaveRule_variableDeclarationListNoIn();
			if (state.backtracking > 0) { Memoize(input, 13, variableDeclarationListNoIn_StartIndex); }

		}
		DebugLocation(111, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationListNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationListNoIn"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();
	// $ANTLR start "variableDeclaration"
	// JavaScript.g:113:1: variableDeclaration : Identifier ( LT )* ( initialiser )? -> ^( VARIABLEDECL Identifier ( initialiser )? ) ;
	[GrammarRule("variableDeclaration")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 14);
		TraceIn("variableDeclaration", 14);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclaration_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier75 = default(IToken);
		IToken LT76 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> initialiser77 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Identifier75_tree = default(CommonTree);
		CommonTree LT76_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_initialiser=new RewriteRuleSubtreeStream(adaptor,"rule initialiser");
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(113, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 14)) { return retval; }

			// JavaScript.g:114:2: ( Identifier ( LT )* ( initialiser )? -> ^( VARIABLEDECL Identifier ( initialiser )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:114:4: Identifier ( LT )* ( initialiser )?
			{
			DebugLocation(114, 4);
			Identifier75=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclaration668); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier75);

			DebugLocation(114, 15);
			// JavaScript.g:114:15: ( LT )*
			try { DebugEnterSubRule(36);
			while (true)
			{
				int alt36=2;
				try { DebugEnterDecision(36, false);
				int LA36_1 = input.LA(1);

				if ((LA36_1==LT))
				{
					int LA36_2 = input.LA(2);

					if ((EvaluatePredicate(synpred48_JavaScript_fragment)))
					{
						alt36 = 1;
					}


				}


				} finally { DebugExitDecision(36); }
				switch ( alt36 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:114:15: LT
					{
					DebugLocation(114, 15);
					LT76=(IToken)Match(input,LT,Follow._LT_in_variableDeclaration670); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT76);


					}
					break;

				default:
					goto loop36;
				}
			}

			loop36:
				;

			} finally { DebugExitSubRule(36); }

			DebugLocation(114, 19);
			// JavaScript.g:114:19: ( initialiser )?
			int alt37=2;
			try { DebugEnterSubRule(37);
			try { DebugEnterDecision(37, false);
			int LA37_1 = input.LA(1);

			if ((LA37_1==68))
			{
				alt37 = 1;
			}
			} finally { DebugExitDecision(37); }
			switch (alt37)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:114:19: initialiser
				{
				DebugLocation(114, 19);
				PushFollow(Follow._initialiser_in_variableDeclaration673);
				initialiser77=initialiser();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_initialiser.Add(initialiser77.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(37); }



			{
			// AST REWRITE
			// elements: Identifier, initialiser
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 115:3: -> ^( VARIABLEDECL Identifier ( initialiser )? )
			{
				DebugLocation(115, 6);
				// JavaScript.g:115:6: ^( VARIABLEDECL Identifier ( initialiser )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(115, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new VariableDeclaration(VARIABLEDECL), root_1);

				DebugLocation(116, 5);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(117, 5);
				// JavaScript.g:117:5: ( initialiser )?
				if (stream_initialiser.HasNext)
				{
					DebugLocation(117, 5);
					adaptor.AddChild(root_1, stream_initialiser.NextTree());

				}
				stream_initialiser.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 14);
			LeaveRule("variableDeclaration", 14);
			LeaveRule_variableDeclaration();
			if (state.backtracking > 0) { Memoize(input, 14, variableDeclaration_StartIndex); }

		}
		DebugLocation(118, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_variableDeclarationNoIn();
	partial void LeaveRule_variableDeclarationNoIn();
	// $ANTLR start "variableDeclarationNoIn"
	// JavaScript.g:120:1: variableDeclarationNoIn : Identifier ( LT )* ( initialiserNoIn )? -> ^( VARIABLEDECL Identifier ( initialiserNoIn )? ) ;
	[GrammarRule("variableDeclarationNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn()
	{
		EnterRule_variableDeclarationNoIn();
		EnterRule("variableDeclarationNoIn", 15);
		TraceIn("variableDeclarationNoIn", 15);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int variableDeclarationNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier78 = default(IToken);
		IToken LT79 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> initialiserNoIn80 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Identifier78_tree = default(CommonTree);
		CommonTree LT79_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_initialiserNoIn=new RewriteRuleSubtreeStream(adaptor,"rule initialiserNoIn");
		try { DebugEnterRule(GrammarFileName, "variableDeclarationNoIn");
		DebugLocation(120, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 15)) { return retval; }

			// JavaScript.g:121:2: ( Identifier ( LT )* ( initialiserNoIn )? -> ^( VARIABLEDECL Identifier ( initialiserNoIn )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:121:4: Identifier ( LT )* ( initialiserNoIn )?
			{
			DebugLocation(121, 4);
			Identifier78=(IToken)Match(input,Identifier,Follow._Identifier_in_variableDeclarationNoIn720); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier78);

			DebugLocation(121, 15);
			// JavaScript.g:121:15: ( LT )*
			try { DebugEnterSubRule(38);
			while (true)
			{
				int alt38=2;
				try { DebugEnterDecision(38, false);
				int LA38_1 = input.LA(1);

				if ((LA38_1==LT))
				{
					int LA38_2 = input.LA(2);

					if ((EvaluatePredicate(synpred50_JavaScript_fragment)))
					{
						alt38 = 1;
					}


				}


				} finally { DebugExitDecision(38); }
				switch ( alt38 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:121:15: LT
					{
					DebugLocation(121, 15);
					LT79=(IToken)Match(input,LT,Follow._LT_in_variableDeclarationNoIn722); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT79);


					}
					break;

				default:
					goto loop38;
				}
			}

			loop38:
				;

			} finally { DebugExitSubRule(38); }

			DebugLocation(121, 19);
			// JavaScript.g:121:19: ( initialiserNoIn )?
			int alt39=2;
			try { DebugEnterSubRule(39);
			try { DebugEnterDecision(39, false);
			int LA39_1 = input.LA(1);

			if ((LA39_1==68))
			{
				alt39 = 1;
			}
			} finally { DebugExitDecision(39); }
			switch (alt39)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:121:19: initialiserNoIn
				{
				DebugLocation(121, 19);
				PushFollow(Follow._initialiserNoIn_in_variableDeclarationNoIn725);
				initialiserNoIn80=initialiserNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_initialiserNoIn.Add(initialiserNoIn80.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(39); }



			{
			// AST REWRITE
			// elements: Identifier, initialiserNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 122:3: -> ^( VARIABLEDECL Identifier ( initialiserNoIn )? )
			{
				DebugLocation(122, 6);
				// JavaScript.g:122:6: ^( VARIABLEDECL Identifier ( initialiserNoIn )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(122, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new VariableDeclaration(VARIABLEDECL), root_1);

				DebugLocation(123, 5);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(124, 5);
				// JavaScript.g:124:5: ( initialiserNoIn )?
				if (stream_initialiserNoIn.HasNext)
				{
					DebugLocation(124, 5);
					adaptor.AddChild(root_1, stream_initialiserNoIn.NextTree());

				}
				stream_initialiserNoIn.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationNoIn", 15);
			LeaveRule("variableDeclarationNoIn", 15);
			LeaveRule_variableDeclarationNoIn();
			if (state.backtracking > 0) { Memoize(input, 15, variableDeclarationNoIn_StartIndex); }

		}
		DebugLocation(125, 1);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationNoIn"); }
		return retval;

	}
	// $ANTLR end "variableDeclarationNoIn"

	partial void EnterRule_initialiser();
	partial void LeaveRule_initialiser();
	// $ANTLR start "initialiser"
	// JavaScript.g:127:1: initialiser : '=' ( LT )* assignmentExpression -> assignmentExpression ;
	[GrammarRule("initialiser")]
	private AstParserRuleReturnScope<CommonTree, IToken> initialiser()
	{
		EnterRule_initialiser();
		EnterRule("initialiser", 16);
		TraceIn("initialiser", 16);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int initialiser_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal81 = default(IToken);
		IToken LT82 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression83 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal81_tree = default(CommonTree);
		CommonTree LT82_tree = default(CommonTree);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "initialiser");
		DebugLocation(127, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 16)) { return retval; }

			// JavaScript.g:128:2: ( '=' ( LT )* assignmentExpression -> assignmentExpression )
			DebugEnterAlt(1);
			// JavaScript.g:128:4: '=' ( LT )* assignmentExpression
			{
			DebugLocation(128, 4);
			char_literal81=(IToken)Match(input,68,Follow._68_in_initialiser770); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(char_literal81);

			DebugLocation(128, 8);
			// JavaScript.g:128:8: ( LT )*
			try { DebugEnterSubRule(40);
			while (true)
			{
				int alt40=2;
				try { DebugEnterDecision(40, false);
				int LA40_1 = input.LA(1);

				if ((LA40_1==LT))
				{
					alt40 = 1;
				}


				} finally { DebugExitDecision(40); }
				switch ( alt40 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:128:8: LT
					{
					DebugLocation(128, 8);
					LT82=(IToken)Match(input,LT,Follow._LT_in_initialiser772); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT82);


					}
					break;

				default:
					goto loop40;
				}
			}

			loop40:
				;

			} finally { DebugExitSubRule(40); }

			DebugLocation(128, 12);
			PushFollow(Follow._assignmentExpression_in_initialiser775);
			assignmentExpression83=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression83.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 128:33: -> assignmentExpression
			{
				DebugLocation(128, 36);
				adaptor.AddChild(root_0, stream_assignmentExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initialiser", 16);
			LeaveRule("initialiser", 16);
			LeaveRule_initialiser();
			if (state.backtracking > 0) { Memoize(input, 16, initialiser_StartIndex); }

		}
		DebugLocation(129, 4);
		} finally { DebugExitRule(GrammarFileName, "initialiser"); }
		return retval;

	}
	// $ANTLR end "initialiser"

	partial void EnterRule_initialiserNoIn();
	partial void LeaveRule_initialiserNoIn();
	// $ANTLR start "initialiserNoIn"
	// JavaScript.g:131:1: initialiserNoIn : '=' ( LT )* assignmentExpressionNoIn -> assignmentExpressionNoIn ;
	[GrammarRule("initialiserNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> initialiserNoIn()
	{
		EnterRule_initialiserNoIn();
		EnterRule("initialiserNoIn", 17);
		TraceIn("initialiserNoIn", 17);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int initialiserNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal84 = default(IToken);
		IToken LT85 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn86 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal84_tree = default(CommonTree);
		CommonTree LT85_tree = default(CommonTree);
		RewriteRuleITokenStream stream_68=new RewriteRuleITokenStream(adaptor,"token 68");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "initialiserNoIn");
		DebugLocation(131, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 17)) { return retval; }

			// JavaScript.g:132:2: ( '=' ( LT )* assignmentExpressionNoIn -> assignmentExpressionNoIn )
			DebugEnterAlt(1);
			// JavaScript.g:132:4: '=' ( LT )* assignmentExpressionNoIn
			{
			DebugLocation(132, 4);
			char_literal84=(IToken)Match(input,68,Follow._68_in_initialiserNoIn794); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_68.Add(char_literal84);

			DebugLocation(132, 8);
			// JavaScript.g:132:8: ( LT )*
			try { DebugEnterSubRule(41);
			while (true)
			{
				int alt41=2;
				try { DebugEnterDecision(41, false);
				int LA41_1 = input.LA(1);

				if ((LA41_1==LT))
				{
					alt41 = 1;
				}


				} finally { DebugExitDecision(41); }
				switch ( alt41 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:132:8: LT
					{
					DebugLocation(132, 8);
					LT85=(IToken)Match(input,LT,Follow._LT_in_initialiserNoIn796); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT85);


					}
					break;

				default:
					goto loop41;
				}
			}

			loop41:
				;

			} finally { DebugExitSubRule(41); }

			DebugLocation(132, 12);
			PushFollow(Follow._assignmentExpressionNoIn_in_initialiserNoIn799);
			assignmentExpressionNoIn86=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(assignmentExpressionNoIn86.Tree);


			{
			// AST REWRITE
			// elements: assignmentExpressionNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 132:37: -> assignmentExpressionNoIn
			{
				DebugLocation(132, 40);
				adaptor.AddChild(root_0, stream_assignmentExpressionNoIn.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("initialiserNoIn", 17);
			LeaveRule("initialiserNoIn", 17);
			LeaveRule_initialiserNoIn();
			if (state.backtracking > 0) { Memoize(input, 17, initialiserNoIn_StartIndex); }

		}
		DebugLocation(133, 1);
		} finally { DebugExitRule(GrammarFileName, "initialiserNoIn"); }
		return retval;

	}
	// $ANTLR end "initialiserNoIn"

	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();
	// $ANTLR start "emptyStatement"
	// JavaScript.g:135:1: emptyStatement : ';' -> ';' ;
	[GrammarRule("emptyStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 18);
		TraceIn("emptyStatement", 18);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int emptyStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal87 = default(IToken);

		CommonTree char_literal87_tree = default(CommonTree);
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(135, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 18)) { return retval; }

			// JavaScript.g:136:2: ( ';' -> ';' )
			DebugEnterAlt(1);
			// JavaScript.g:136:4: ';'
			{
			DebugLocation(136, 4);
			char_literal87=(IToken)Match(input,63,Follow._63_in_emptyStatement815); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal87);



			{
			// AST REWRITE
			// elements: 63
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 136:8: -> ';'
			{
				DebugLocation(136, 11);
				adaptor.AddChild(root_0, new EmptyStatement(stream_63.NextToken()));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("emptyStatement", 18);
			LeaveRule("emptyStatement", 18);
			LeaveRule_emptyStatement();
			if (state.backtracking > 0) { Memoize(input, 18, emptyStatement_StartIndex); }

		}
		DebugLocation(137, 1);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		return retval;

	}
	// $ANTLR end "emptyStatement"

	partial void EnterRule_expressionStatement();
	partial void LeaveRule_expressionStatement();
	// $ANTLR start "expressionStatement"
	// JavaScript.g:139:1: expressionStatement : expression ( LT | ';' ) -> expression ;
	[GrammarRule("expressionStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> expressionStatement()
	{
		EnterRule_expressionStatement();
		EnterRule("expressionStatement", 19);
		TraceIn("expressionStatement", 19);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expressionStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT89 = default(IToken);
		IToken char_literal90 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression88 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT89_tree = default(CommonTree);
		CommonTree char_literal90_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "expressionStatement");
		DebugLocation(139, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 19)) { return retval; }

			// JavaScript.g:140:2: ( expression ( LT | ';' ) -> expression )
			DebugEnterAlt(1);
			// JavaScript.g:140:4: expression ( LT | ';' )
			{
			DebugLocation(140, 4);
			PushFollow(Follow._expression_in_expressionStatement836);
			expression88=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression88.Tree);
			DebugLocation(140, 15);
			// JavaScript.g:140:15: ( LT | ';' )
			int alt42=2;
			try { DebugEnterSubRule(42);
			try { DebugEnterDecision(42, false);
			int LA42_1 = input.LA(1);

			if ((LA42_1==LT))
			{
				alt42 = 1;
			}
			else if ((LA42_1==63))
			{
				alt42 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 42, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(42); }
			switch (alt42)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:140:16: LT
				{
				DebugLocation(140, 16);
				LT89=(IToken)Match(input,LT,Follow._LT_in_expressionStatement839); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT89);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:140:21: ';'
				{
				DebugLocation(140, 21);
				char_literal90=(IToken)Match(input,63,Follow._63_in_expressionStatement843); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal90);


				}
				break;

			}
			} finally { DebugExitSubRule(42); }



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 140:26: -> expression
			{
				DebugLocation(140, 29);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionStatement", 19);
			LeaveRule("expressionStatement", 19);
			LeaveRule_expressionStatement();
			if (state.backtracking > 0) { Memoize(input, 19, expressionStatement_StartIndex); }

		}
		DebugLocation(141, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionStatement"); }
		return retval;

	}
	// $ANTLR end "expressionStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();
	// $ANTLR start "ifStatement"
	// JavaScript.g:143:1: ifStatement : 'if' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* ifstmt= statement ( ( LT )* 'else' ( LT )* elsestmt= statement )? -> ^( 'if' expression $ifstmt ( $elsestmt)? ) ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 20);
		TraceIn("ifStatement", 20);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int ifStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal91 = default(IToken);
		IToken LT92 = default(IToken);
		IToken char_literal93 = default(IToken);
		IToken LT94 = default(IToken);
		IToken LT96 = default(IToken);
		IToken char_literal97 = default(IToken);
		IToken LT98 = default(IToken);
		IToken LT99 = default(IToken);
		IToken string_literal100 = default(IToken);
		IToken LT101 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ifstmt = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> elsestmt = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression95 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal91_tree = default(CommonTree);
		CommonTree LT92_tree = default(CommonTree);
		CommonTree char_literal93_tree = default(CommonTree);
		CommonTree LT94_tree = default(CommonTree);
		CommonTree LT96_tree = default(CommonTree);
		CommonTree char_literal97_tree = default(CommonTree);
		CommonTree LT98_tree = default(CommonTree);
		CommonTree LT99_tree = default(CommonTree);
		CommonTree string_literal100_tree = default(CommonTree);
		CommonTree LT101_tree = default(CommonTree);
		RewriteRuleITokenStream stream_94=new RewriteRuleITokenStream(adaptor,"token 94");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_89=new RewriteRuleITokenStream(adaptor,"token 89");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(143, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 20)) { return retval; }

			// JavaScript.g:144:2: ( 'if' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* ifstmt= statement ( ( LT )* 'else' ( LT )* elsestmt= statement )? -> ^( 'if' expression $ifstmt ( $elsestmt)? ) )
			DebugEnterAlt(1);
			// JavaScript.g:144:4: 'if' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* ifstmt= statement ( ( LT )* 'else' ( LT )* elsestmt= statement )?
			{
			DebugLocation(144, 4);
			string_literal91=(IToken)Match(input,94,Follow._94_in_ifStatement860); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_94.Add(string_literal91);

			DebugLocation(144, 9);
			// JavaScript.g:144:9: ( LT )*
			try { DebugEnterSubRule(43);
			while (true)
			{
				int alt43=2;
				try { DebugEnterDecision(43, false);
				int LA43_1 = input.LA(1);

				if ((LA43_1==LT))
				{
					alt43 = 1;
				}


				} finally { DebugExitDecision(43); }
				switch ( alt43 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:9: LT
					{
					DebugLocation(144, 9);
					LT92=(IToken)Match(input,LT,Follow._LT_in_ifStatement862); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT92);


					}
					break;

				default:
					goto loop43;
				}
			}

			loop43:
				;

			} finally { DebugExitSubRule(43); }

			DebugLocation(144, 13);
			char_literal93=(IToken)Match(input,48,Follow._48_in_ifStatement865); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal93);

			DebugLocation(144, 17);
			// JavaScript.g:144:17: ( LT )*
			try { DebugEnterSubRule(44);
			while (true)
			{
				int alt44=2;
				try { DebugEnterDecision(44, false);
				int LA44_1 = input.LA(1);

				if ((LA44_1==LT))
				{
					alt44 = 1;
				}


				} finally { DebugExitDecision(44); }
				switch ( alt44 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:17: LT
					{
					DebugLocation(144, 17);
					LT94=(IToken)Match(input,LT,Follow._LT_in_ifStatement867); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT94);


					}
					break;

				default:
					goto loop44;
				}
			}

			loop44:
				;

			} finally { DebugExitSubRule(44); }

			DebugLocation(144, 21);
			PushFollow(Follow._expression_in_ifStatement870);
			expression95=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression95.Tree);
			DebugLocation(144, 32);
			// JavaScript.g:144:32: ( LT )*
			try { DebugEnterSubRule(45);
			while (true)
			{
				int alt45=2;
				try { DebugEnterDecision(45, false);
				int LA45_1 = input.LA(1);

				if ((LA45_1==LT))
				{
					alt45 = 1;
				}


				} finally { DebugExitDecision(45); }
				switch ( alt45 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:32: LT
					{
					DebugLocation(144, 32);
					LT96=(IToken)Match(input,LT,Follow._LT_in_ifStatement872); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT96);


					}
					break;

				default:
					goto loop45;
				}
			}

			loop45:
				;

			} finally { DebugExitSubRule(45); }

			DebugLocation(144, 36);
			char_literal97=(IToken)Match(input,49,Follow._49_in_ifStatement875); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal97);

			DebugLocation(144, 40);
			// JavaScript.g:144:40: ( LT )*
			try { DebugEnterSubRule(46);
			while (true)
			{
				int alt46=2;
				try { DebugEnterDecision(46, false);
				int LA46_1 = input.LA(1);

				if ((LA46_1==LT))
				{
					alt46 = 1;
				}


				} finally { DebugExitDecision(46); }
				switch ( alt46 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:40: LT
					{
					DebugLocation(144, 40);
					LT98=(IToken)Match(input,LT,Follow._LT_in_ifStatement877); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT98);


					}
					break;

				default:
					goto loop46;
				}
			}

			loop46:
				;

			} finally { DebugExitSubRule(46); }

			DebugLocation(144, 50);
			PushFollow(Follow._statement_in_ifStatement882);
			ifstmt=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(ifstmt.Tree);
			DebugLocation(144, 61);
			// JavaScript.g:144:61: ( ( LT )* 'else' ( LT )* elsestmt= statement )?
			int alt49=2;
			try { DebugEnterSubRule(49);
			try { DebugEnterDecision(49, false);
			int LA49_1 = input.LA(1);

			if ((LA49_1==LT))
			{
				int LA49_2 = input.LA(2);

				if ((EvaluatePredicate(synpred61_JavaScript_fragment)))
				{
					alt49 = 1;
				}
			}
			else if ((LA49_1==89))
			{
				int LA49_2 = input.LA(2);

				if ((EvaluatePredicate(synpred61_JavaScript_fragment)))
				{
					alt49 = 1;
				}
			}
			} finally { DebugExitDecision(49); }
			switch (alt49)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:144:62: ( LT )* 'else' ( LT )* elsestmt= statement
				{
				DebugLocation(144, 62);
				// JavaScript.g:144:62: ( LT )*
				try { DebugEnterSubRule(47);
				while (true)
				{
					int alt47=2;
					try { DebugEnterDecision(47, false);
					int LA47_1 = input.LA(1);

					if ((LA47_1==LT))
					{
						alt47 = 1;
					}


					} finally { DebugExitDecision(47); }
					switch ( alt47 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:144:62: LT
						{
						DebugLocation(144, 62);
						LT99=(IToken)Match(input,LT,Follow._LT_in_ifStatement885); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT99);


						}
						break;

					default:
						goto loop47;
					}
				}

				loop47:
					;

				} finally { DebugExitSubRule(47); }

				DebugLocation(144, 66);
				string_literal100=(IToken)Match(input,89,Follow._89_in_ifStatement888); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_89.Add(string_literal100);

				DebugLocation(144, 73);
				// JavaScript.g:144:73: ( LT )*
				try { DebugEnterSubRule(48);
				while (true)
				{
					int alt48=2;
					try { DebugEnterDecision(48, false);
					int LA48_1 = input.LA(1);

					if ((LA48_1==LT))
					{
						alt48 = 1;
					}


					} finally { DebugExitDecision(48); }
					switch ( alt48 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:144:73: LT
						{
						DebugLocation(144, 73);
						LT101=(IToken)Match(input,LT,Follow._LT_in_ifStatement890); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT101);


						}
						break;

					default:
						goto loop48;
					}
				}

				loop48:
					;

				} finally { DebugExitSubRule(48); }

				DebugLocation(144, 85);
				PushFollow(Follow._statement_in_ifStatement895);
				elsestmt=statement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statement.Add(elsestmt.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(49); }



			{
			// AST REWRITE
			// elements: 94, expression, ifstmt, elsestmt
			// token labels: 
			// rule labels: ifstmt, elsestmt, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_ifstmt=new RewriteRuleSubtreeStream(adaptor,"rule ifstmt",ifstmt!=null?ifstmt.Tree:null);
			RewriteRuleSubtreeStream stream_elsestmt=new RewriteRuleSubtreeStream(adaptor,"rule elsestmt",elsestmt!=null?elsestmt.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 145:3: -> ^( 'if' expression $ifstmt ( $elsestmt)? )
			{
				DebugLocation(145, 6);
				// JavaScript.g:145:6: ^( 'if' expression $ifstmt ( $elsestmt)? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(145, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new IfStatement(stream_94.NextToken()), root_1);

				DebugLocation(145, 31);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(145, 43);
				adaptor.AddChild(root_1, stream_ifstmt.NextTree());
				DebugLocation(145, 51);
				// JavaScript.g:145:51: ( $elsestmt)?
				if (stream_elsestmt.HasNext)
				{
					DebugLocation(145, 51);
					adaptor.AddChild(root_1, stream_elsestmt.NextTree());

				}
				stream_elsestmt.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 20);
			LeaveRule("ifStatement", 20);
			LeaveRule_ifStatement();
			if (state.backtracking > 0) { Memoize(input, 20, ifStatement_StartIndex); }

		}
		DebugLocation(146, 1);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_iterationStatement();
	partial void LeaveRule_iterationStatement();
	// $ANTLR start "iterationStatement"
	// JavaScript.g:148:1: iterationStatement : ( doWhileStatement | whileStatement | forStatement | forInStatement );
	[GrammarRule("iterationStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> iterationStatement()
	{
		EnterRule_iterationStatement();
		EnterRule("iterationStatement", 21);
		TraceIn("iterationStatement", 21);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int iterationStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> doWhileStatement102 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> whileStatement103 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forStatement104 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forInStatement105 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "iterationStatement");
		DebugLocation(148, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 21)) { return retval; }

			// JavaScript.g:149:2: ( doWhileStatement | whileStatement | forStatement | forInStatement )
			int alt50=4;
			try { DebugEnterDecision(50, false);
			switch (input.LA(1))
			{
			case 88:
				{
				alt50 = 1;
				}
				break;
			case 108:
				{
				alt50 = 2;
				}
				break;
			case 92:
				{
				int LA50_2 = input.LA(2);

				if ((EvaluatePredicate(synpred64_JavaScript_fragment)))
				{
					alt50 = 3;
				}
				else if ((true))
				{
					alt50 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 50, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(50); }
			switch (alt50)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:149:4: doWhileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(149, 4);
				PushFollow(Follow._doWhileStatement_in_iterationStatement931);
				doWhileStatement102=doWhileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, doWhileStatement102.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:150:4: whileStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(150, 4);
				PushFollow(Follow._whileStatement_in_iterationStatement936);
				whileStatement103=whileStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, whileStatement103.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:151:4: forStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(151, 4);
				PushFollow(Follow._forStatement_in_iterationStatement941);
				forStatement104=forStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forStatement104.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:152:4: forInStatement
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(152, 4);
				PushFollow(Follow._forInStatement_in_iterationStatement946);
				forInStatement105=forInStatement();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, forInStatement105.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("iterationStatement", 21);
			LeaveRule("iterationStatement", 21);
			LeaveRule_iterationStatement();
			if (state.backtracking > 0) { Memoize(input, 21, iterationStatement_StartIndex); }

		}
		DebugLocation(153, 1);
		} finally { DebugExitRule(GrammarFileName, "iterationStatement"); }
		return retval;

	}
	// $ANTLR end "iterationStatement"

	partial void EnterRule_doWhileStatement();
	partial void LeaveRule_doWhileStatement();
	// $ANTLR start "doWhileStatement"
	// JavaScript.g:155:1: doWhileStatement : 'do' ( LT )* statement ( LT )* 'while' ( LT )* '(' expression ')' ( LT | ';' ) -> ^( 'do' statement expression ) ;
	[GrammarRule("doWhileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> doWhileStatement()
	{
		EnterRule_doWhileStatement();
		EnterRule("doWhileStatement", 22);
		TraceIn("doWhileStatement", 22);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int doWhileStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal106 = default(IToken);
		IToken LT107 = default(IToken);
		IToken LT109 = default(IToken);
		IToken string_literal110 = default(IToken);
		IToken LT111 = default(IToken);
		IToken char_literal112 = default(IToken);
		IToken char_literal114 = default(IToken);
		IToken LT115 = default(IToken);
		IToken char_literal116 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement108 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression113 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal106_tree = default(CommonTree);
		CommonTree LT107_tree = default(CommonTree);
		CommonTree LT109_tree = default(CommonTree);
		CommonTree string_literal110_tree = default(CommonTree);
		CommonTree LT111_tree = default(CommonTree);
		CommonTree char_literal112_tree = default(CommonTree);
		CommonTree char_literal114_tree = default(CommonTree);
		CommonTree LT115_tree = default(CommonTree);
		CommonTree char_literal116_tree = default(CommonTree);
		RewriteRuleITokenStream stream_88=new RewriteRuleITokenStream(adaptor,"token 88");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_108=new RewriteRuleITokenStream(adaptor,"token 108");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "doWhileStatement");
		DebugLocation(155, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 22)) { return retval; }

			// JavaScript.g:156:2: ( 'do' ( LT )* statement ( LT )* 'while' ( LT )* '(' expression ')' ( LT | ';' ) -> ^( 'do' statement expression ) )
			DebugEnterAlt(1);
			// JavaScript.g:156:4: 'do' ( LT )* statement ( LT )* 'while' ( LT )* '(' expression ')' ( LT | ';' )
			{
			DebugLocation(156, 4);
			string_literal106=(IToken)Match(input,88,Follow._88_in_doWhileStatement958); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_88.Add(string_literal106);

			DebugLocation(156, 9);
			// JavaScript.g:156:9: ( LT )*
			try { DebugEnterSubRule(51);
			while (true)
			{
				int alt51=2;
				try { DebugEnterDecision(51, false);
				int LA51_1 = input.LA(1);

				if ((LA51_1==LT))
				{
					alt51 = 1;
				}


				} finally { DebugExitDecision(51); }
				switch ( alt51 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:156:9: LT
					{
					DebugLocation(156, 9);
					LT107=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement960); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT107);


					}
					break;

				default:
					goto loop51;
				}
			}

			loop51:
				;

			} finally { DebugExitSubRule(51); }

			DebugLocation(156, 13);
			PushFollow(Follow._statement_in_doWhileStatement963);
			statement108=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement108.Tree);
			DebugLocation(156, 23);
			// JavaScript.g:156:23: ( LT )*
			try { DebugEnterSubRule(52);
			while (true)
			{
				int alt52=2;
				try { DebugEnterDecision(52, false);
				int LA52_1 = input.LA(1);

				if ((LA52_1==LT))
				{
					alt52 = 1;
				}


				} finally { DebugExitDecision(52); }
				switch ( alt52 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:156:23: LT
					{
					DebugLocation(156, 23);
					LT109=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement965); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT109);


					}
					break;

				default:
					goto loop52;
				}
			}

			loop52:
				;

			} finally { DebugExitSubRule(52); }

			DebugLocation(156, 27);
			string_literal110=(IToken)Match(input,108,Follow._108_in_doWhileStatement968); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_108.Add(string_literal110);

			DebugLocation(156, 35);
			// JavaScript.g:156:35: ( LT )*
			try { DebugEnterSubRule(53);
			while (true)
			{
				int alt53=2;
				try { DebugEnterDecision(53, false);
				int LA53_1 = input.LA(1);

				if ((LA53_1==LT))
				{
					alt53 = 1;
				}


				} finally { DebugExitDecision(53); }
				switch ( alt53 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:156:35: LT
					{
					DebugLocation(156, 35);
					LT111=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement970); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT111);


					}
					break;

				default:
					goto loop53;
				}
			}

			loop53:
				;

			} finally { DebugExitSubRule(53); }

			DebugLocation(156, 39);
			char_literal112=(IToken)Match(input,48,Follow._48_in_doWhileStatement973); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal112);

			DebugLocation(156, 43);
			PushFollow(Follow._expression_in_doWhileStatement975);
			expression113=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression113.Tree);
			DebugLocation(156, 54);
			char_literal114=(IToken)Match(input,49,Follow._49_in_doWhileStatement977); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal114);

			DebugLocation(156, 58);
			// JavaScript.g:156:58: ( LT | ';' )
			int alt54=2;
			try { DebugEnterSubRule(54);
			try { DebugEnterDecision(54, false);
			int LA54_1 = input.LA(1);

			if ((LA54_1==LT))
			{
				alt54 = 1;
			}
			else if ((LA54_1==63))
			{
				alt54 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 54, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(54); }
			switch (alt54)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:156:59: LT
				{
				DebugLocation(156, 59);
				LT115=(IToken)Match(input,LT,Follow._LT_in_doWhileStatement980); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT115);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:156:64: ';'
				{
				DebugLocation(156, 64);
				char_literal116=(IToken)Match(input,63,Follow._63_in_doWhileStatement984); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal116);


				}
				break;

			}
			} finally { DebugExitSubRule(54); }



			{
			// AST REWRITE
			// elements: 88, statement, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 157:3: -> ^( 'do' statement expression )
			{
				DebugLocation(157, 6);
				// JavaScript.g:157:6: ^( 'do' statement expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(157, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new DoWhileStatement(stream_88.NextToken()), root_1);

				DebugLocation(157, 36);
				adaptor.AddChild(root_1, stream_statement.NextTree());
				DebugLocation(157, 46);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("doWhileStatement", 22);
			LeaveRule("doWhileStatement", 22);
			LeaveRule_doWhileStatement();
			if (state.backtracking > 0) { Memoize(input, 22, doWhileStatement_StartIndex); }

		}
		DebugLocation(158, 1);
		} finally { DebugExitRule(GrammarFileName, "doWhileStatement"); }
		return retval;

	}
	// $ANTLR end "doWhileStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();
	// $ANTLR start "whileStatement"
	// JavaScript.g:160:1: whileStatement : 'while' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'while' expression statement ) ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 23);
		TraceIn("whileStatement", 23);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int whileStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal117 = default(IToken);
		IToken LT118 = default(IToken);
		IToken char_literal119 = default(IToken);
		IToken LT120 = default(IToken);
		IToken LT122 = default(IToken);
		IToken char_literal123 = default(IToken);
		IToken LT124 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression121 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement125 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal117_tree = default(CommonTree);
		CommonTree LT118_tree = default(CommonTree);
		CommonTree char_literal119_tree = default(CommonTree);
		CommonTree LT120_tree = default(CommonTree);
		CommonTree LT122_tree = default(CommonTree);
		CommonTree char_literal123_tree = default(CommonTree);
		CommonTree LT124_tree = default(CommonTree);
		RewriteRuleITokenStream stream_108=new RewriteRuleITokenStream(adaptor,"token 108");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(160, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 23)) { return retval; }

			// JavaScript.g:161:2: ( 'while' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'while' expression statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:161:4: 'while' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement
			{
			DebugLocation(161, 4);
			string_literal117=(IToken)Match(input,108,Follow._108_in_whileStatement1014); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_108.Add(string_literal117);

			DebugLocation(161, 12);
			// JavaScript.g:161:12: ( LT )*
			try { DebugEnterSubRule(55);
			while (true)
			{
				int alt55=2;
				try { DebugEnterDecision(55, false);
				int LA55_1 = input.LA(1);

				if ((LA55_1==LT))
				{
					alt55 = 1;
				}


				} finally { DebugExitDecision(55); }
				switch ( alt55 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:12: LT
					{
					DebugLocation(161, 12);
					LT118=(IToken)Match(input,LT,Follow._LT_in_whileStatement1016); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT118);


					}
					break;

				default:
					goto loop55;
				}
			}

			loop55:
				;

			} finally { DebugExitSubRule(55); }

			DebugLocation(161, 16);
			char_literal119=(IToken)Match(input,48,Follow._48_in_whileStatement1019); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal119);

			DebugLocation(161, 20);
			// JavaScript.g:161:20: ( LT )*
			try { DebugEnterSubRule(56);
			while (true)
			{
				int alt56=2;
				try { DebugEnterDecision(56, false);
				int LA56_1 = input.LA(1);

				if ((LA56_1==LT))
				{
					alt56 = 1;
				}


				} finally { DebugExitDecision(56); }
				switch ( alt56 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:20: LT
					{
					DebugLocation(161, 20);
					LT120=(IToken)Match(input,LT,Follow._LT_in_whileStatement1021); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT120);


					}
					break;

				default:
					goto loop56;
				}
			}

			loop56:
				;

			} finally { DebugExitSubRule(56); }

			DebugLocation(161, 24);
			PushFollow(Follow._expression_in_whileStatement1024);
			expression121=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression121.Tree);
			DebugLocation(161, 35);
			// JavaScript.g:161:35: ( LT )*
			try { DebugEnterSubRule(57);
			while (true)
			{
				int alt57=2;
				try { DebugEnterDecision(57, false);
				int LA57_1 = input.LA(1);

				if ((LA57_1==LT))
				{
					alt57 = 1;
				}


				} finally { DebugExitDecision(57); }
				switch ( alt57 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:35: LT
					{
					DebugLocation(161, 35);
					LT122=(IToken)Match(input,LT,Follow._LT_in_whileStatement1026); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT122);


					}
					break;

				default:
					goto loop57;
				}
			}

			loop57:
				;

			} finally { DebugExitSubRule(57); }

			DebugLocation(161, 39);
			char_literal123=(IToken)Match(input,49,Follow._49_in_whileStatement1029); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal123);

			DebugLocation(161, 43);
			// JavaScript.g:161:43: ( LT )*
			try { DebugEnterSubRule(58);
			while (true)
			{
				int alt58=2;
				try { DebugEnterDecision(58, false);
				int LA58_1 = input.LA(1);

				if ((LA58_1==LT))
				{
					alt58 = 1;
				}


				} finally { DebugExitDecision(58); }
				switch ( alt58 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:161:43: LT
					{
					DebugLocation(161, 43);
					LT124=(IToken)Match(input,LT,Follow._LT_in_whileStatement1031); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT124);


					}
					break;

				default:
					goto loop58;
				}
			}

			loop58:
				;

			} finally { DebugExitSubRule(58); }

			DebugLocation(161, 47);
			PushFollow(Follow._statement_in_whileStatement1034);
			statement125=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement125.Tree);


			{
			// AST REWRITE
			// elements: 108, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 162:3: -> ^( 'while' expression statement )
			{
				DebugLocation(162, 6);
				// JavaScript.g:162:6: ^( 'while' expression statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(162, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new WhileStatement(stream_108.NextToken()), root_1);

				DebugLocation(162, 37);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(162, 48);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 23);
			LeaveRule("whileStatement", 23);
			LeaveRule_whileStatement();
			if (state.backtracking > 0) { Memoize(input, 23, whileStatement_StartIndex); }

		}
		DebugLocation(163, 1);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();
	// $ANTLR start "forStatement"
	// JavaScript.g:165:1: forStatement : 'for' ( LT )* '(' ( ( LT )* forStatementInitialiserPart )? ( LT )* ';' ( ( LT )* condition= expression )? ( LT )* ';' ( ( LT )* incr= expression )? ( LT )* ')' ( LT )* statement -> ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement ) ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 24);
		TraceIn("forStatement", 24);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal126 = default(IToken);
		IToken LT127 = default(IToken);
		IToken char_literal128 = default(IToken);
		IToken LT129 = default(IToken);
		IToken LT131 = default(IToken);
		IToken char_literal132 = default(IToken);
		IToken LT133 = default(IToken);
		IToken LT134 = default(IToken);
		IToken char_literal135 = default(IToken);
		IToken LT136 = default(IToken);
		IToken LT137 = default(IToken);
		IToken char_literal138 = default(IToken);
		IToken LT139 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> condition = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> incr = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> forStatementInitialiserPart130 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement140 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal126_tree = default(CommonTree);
		CommonTree LT127_tree = default(CommonTree);
		CommonTree char_literal128_tree = default(CommonTree);
		CommonTree LT129_tree = default(CommonTree);
		CommonTree LT131_tree = default(CommonTree);
		CommonTree char_literal132_tree = default(CommonTree);
		CommonTree LT133_tree = default(CommonTree);
		CommonTree LT134_tree = default(CommonTree);
		CommonTree char_literal135_tree = default(CommonTree);
		CommonTree LT136_tree = default(CommonTree);
		CommonTree LT137_tree = default(CommonTree);
		CommonTree char_literal138_tree = default(CommonTree);
		CommonTree LT139_tree = default(CommonTree);
		RewriteRuleITokenStream stream_92=new RewriteRuleITokenStream(adaptor,"token 92");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_forStatementInitialiserPart=new RewriteRuleSubtreeStream(adaptor,"rule forStatementInitialiserPart");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(165, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 24)) { return retval; }

			// JavaScript.g:166:2: ( 'for' ( LT )* '(' ( ( LT )* forStatementInitialiserPart )? ( LT )* ';' ( ( LT )* condition= expression )? ( LT )* ';' ( ( LT )* incr= expression )? ( LT )* ')' ( LT )* statement -> ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:166:4: 'for' ( LT )* '(' ( ( LT )* forStatementInitialiserPart )? ( LT )* ';' ( ( LT )* condition= expression )? ( LT )* ';' ( ( LT )* incr= expression )? ( LT )* ')' ( LT )* statement
			{
			DebugLocation(166, 4);
			string_literal126=(IToken)Match(input,92,Follow._92_in_forStatement1064); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_92.Add(string_literal126);

			DebugLocation(166, 10);
			// JavaScript.g:166:10: ( LT )*
			try { DebugEnterSubRule(59);
			while (true)
			{
				int alt59=2;
				try { DebugEnterDecision(59, false);
				int LA59_1 = input.LA(1);

				if ((LA59_1==LT))
				{
					alt59 = 1;
				}


				} finally { DebugExitDecision(59); }
				switch ( alt59 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:10: LT
					{
					DebugLocation(166, 10);
					LT127=(IToken)Match(input,LT,Follow._LT_in_forStatement1066); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT127);


					}
					break;

				default:
					goto loop59;
				}
			}

			loop59:
				;

			} finally { DebugExitSubRule(59); }

			DebugLocation(166, 14);
			char_literal128=(IToken)Match(input,48,Follow._48_in_forStatement1069); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal128);

			DebugLocation(166, 18);
			// JavaScript.g:166:18: ( ( LT )* forStatementInitialiserPart )?
			int alt61=2;
			try { DebugEnterSubRule(61);
			try { DebugEnterDecision(61, false);
			try
			{
				alt61 = dfa61.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(61); }
			switch (alt61)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:166:19: ( LT )* forStatementInitialiserPart
				{
				DebugLocation(166, 19);
				// JavaScript.g:166:19: ( LT )*
				try { DebugEnterSubRule(60);
				while (true)
				{
					int alt60=2;
					try { DebugEnterDecision(60, false);
					int LA60_1 = input.LA(1);

					if ((LA60_1==LT))
					{
						alt60 = 1;
					}


					} finally { DebugExitDecision(60); }
					switch ( alt60 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:166:19: LT
						{
						DebugLocation(166, 19);
						LT129=(IToken)Match(input,LT,Follow._LT_in_forStatement1072); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT129);


						}
						break;

					default:
						goto loop60;
					}
				}

				loop60:
					;

				} finally { DebugExitSubRule(60); }

				DebugLocation(166, 23);
				PushFollow(Follow._forStatementInitialiserPart_in_forStatement1075);
				forStatementInitialiserPart130=forStatementInitialiserPart();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_forStatementInitialiserPart.Add(forStatementInitialiserPart130.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(61); }

			DebugLocation(166, 53);
			// JavaScript.g:166:53: ( LT )*
			try { DebugEnterSubRule(62);
			while (true)
			{
				int alt62=2;
				try { DebugEnterDecision(62, false);
				int LA62_1 = input.LA(1);

				if ((LA62_1==LT))
				{
					alt62 = 1;
				}


				} finally { DebugExitDecision(62); }
				switch ( alt62 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:53: LT
					{
					DebugLocation(166, 53);
					LT131=(IToken)Match(input,LT,Follow._LT_in_forStatement1079); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT131);


					}
					break;

				default:
					goto loop62;
				}
			}

			loop62:
				;

			} finally { DebugExitSubRule(62); }

			DebugLocation(166, 57);
			char_literal132=(IToken)Match(input,63,Follow._63_in_forStatement1082); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal132);

			DebugLocation(166, 61);
			// JavaScript.g:166:61: ( ( LT )* condition= expression )?
			int alt64=2;
			try { DebugEnterSubRule(64);
			try { DebugEnterDecision(64, false);
			try
			{
				alt64 = dfa64.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(64); }
			switch (alt64)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:166:62: ( LT )* condition= expression
				{
				DebugLocation(166, 62);
				// JavaScript.g:166:62: ( LT )*
				try { DebugEnterSubRule(63);
				while (true)
				{
					int alt63=2;
					try { DebugEnterDecision(63, false);
					int LA63_1 = input.LA(1);

					if ((LA63_1==LT))
					{
						alt63 = 1;
					}


					} finally { DebugExitDecision(63); }
					switch ( alt63 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:166:62: LT
						{
						DebugLocation(166, 62);
						LT133=(IToken)Match(input,LT,Follow._LT_in_forStatement1085); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT133);


						}
						break;

					default:
						goto loop63;
					}
				}

				loop63:
					;

				} finally { DebugExitSubRule(63); }

				DebugLocation(166, 75);
				PushFollow(Follow._expression_in_forStatement1090);
				condition=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(condition.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(64); }

			DebugLocation(166, 89);
			// JavaScript.g:166:89: ( LT )*
			try { DebugEnterSubRule(65);
			while (true)
			{
				int alt65=2;
				try { DebugEnterDecision(65, false);
				int LA65_1 = input.LA(1);

				if ((LA65_1==LT))
				{
					alt65 = 1;
				}


				} finally { DebugExitDecision(65); }
				switch ( alt65 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:89: LT
					{
					DebugLocation(166, 89);
					LT134=(IToken)Match(input,LT,Follow._LT_in_forStatement1094); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT134);


					}
					break;

				default:
					goto loop65;
				}
			}

			loop65:
				;

			} finally { DebugExitSubRule(65); }

			DebugLocation(166, 93);
			char_literal135=(IToken)Match(input,63,Follow._63_in_forStatement1097); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_63.Add(char_literal135);

			DebugLocation(166, 97);
			// JavaScript.g:166:97: ( ( LT )* incr= expression )?
			int alt67=2;
			try { DebugEnterSubRule(67);
			try { DebugEnterDecision(67, false);
			try
			{
				alt67 = dfa67.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(67); }
			switch (alt67)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:166:98: ( LT )* incr= expression
				{
				DebugLocation(166, 98);
				// JavaScript.g:166:98: ( LT )*
				try { DebugEnterSubRule(66);
				while (true)
				{
					int alt66=2;
					try { DebugEnterDecision(66, false);
					int LA66_1 = input.LA(1);

					if ((LA66_1==LT))
					{
						alt66 = 1;
					}


					} finally { DebugExitDecision(66); }
					switch ( alt66 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:166:98: LT
						{
						DebugLocation(166, 98);
						LT136=(IToken)Match(input,LT,Follow._LT_in_forStatement1100); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT136);


						}
						break;

					default:
						goto loop66;
					}
				}

				loop66:
					;

				} finally { DebugExitSubRule(66); }

				DebugLocation(166, 106);
				PushFollow(Follow._expression_in_forStatement1105);
				incr=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(incr.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(67); }

			DebugLocation(166, 120);
			// JavaScript.g:166:120: ( LT )*
			try { DebugEnterSubRule(68);
			while (true)
			{
				int alt68=2;
				try { DebugEnterDecision(68, false);
				int LA68_1 = input.LA(1);

				if ((LA68_1==LT))
				{
					alt68 = 1;
				}


				} finally { DebugExitDecision(68); }
				switch ( alt68 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:120: LT
					{
					DebugLocation(166, 120);
					LT137=(IToken)Match(input,LT,Follow._LT_in_forStatement1109); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT137);


					}
					break;

				default:
					goto loop68;
				}
			}

			loop68:
				;

			} finally { DebugExitSubRule(68); }

			DebugLocation(166, 124);
			char_literal138=(IToken)Match(input,49,Follow._49_in_forStatement1112); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal138);

			DebugLocation(166, 128);
			// JavaScript.g:166:128: ( LT )*
			try { DebugEnterSubRule(69);
			while (true)
			{
				int alt69=2;
				try { DebugEnterDecision(69, false);
				int LA69_1 = input.LA(1);

				if ((LA69_1==LT))
				{
					alt69 = 1;
				}


				} finally { DebugExitDecision(69); }
				switch ( alt69 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:166:128: LT
					{
					DebugLocation(166, 128);
					LT139=(IToken)Match(input,LT,Follow._LT_in_forStatement1114); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT139);


					}
					break;

				default:
					goto loop69;
				}
			}

			loop69:
				;

			} finally { DebugExitSubRule(69); }

			DebugLocation(166, 132);
			PushFollow(Follow._statement_in_forStatement1117);
			statement140=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement140.Tree);


			{
			// AST REWRITE
			// elements: 92, forStatementInitialiserPart, condition, incr, statement
			// token labels: 
			// rule labels: condition, incr, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_condition=new RewriteRuleSubtreeStream(adaptor,"rule condition",condition!=null?condition.Tree:null);
			RewriteRuleSubtreeStream stream_incr=new RewriteRuleSubtreeStream(adaptor,"rule incr",incr!=null?incr.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 167:3: -> ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement )
			{
				DebugLocation(167, 6);
				// JavaScript.g:167:6: ^( 'for' ^( FORSTMTINIT ( forStatementInitialiserPart )? ) ^( FORSTMTCOND ( $condition)? ) ^( FORSTMTINCR ( $incr)? ) statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(167, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ForStatement(stream_92.NextToken()), root_1);

				DebugLocation(168, 8);
				// JavaScript.g:168:8: ^( FORSTMTINIT ( forStatementInitialiserPart )? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(168, 10);
				root_2 = (CommonTree)adaptor.BecomeRoot(new ForStatementInitializer(FORSTMTINIT), root_2);

				DebugLocation(168, 52);
				// JavaScript.g:168:52: ( forStatementInitialiserPart )?
				if (stream_forStatementInitialiserPart.HasNext)
				{
					DebugLocation(168, 52);
					adaptor.AddChild(root_2, stream_forStatementInitialiserPart.NextTree());

				}
				stream_forStatementInitialiserPart.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(169, 8);
				// JavaScript.g:169:8: ^( FORSTMTCOND ( $condition)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(169, 10);
				root_2 = (CommonTree)adaptor.BecomeRoot(new ForStatementCondition(FORSTMTCOND), root_2);

				DebugLocation(169, 51);
				// JavaScript.g:169:51: ( $condition)?
				if (stream_condition.HasNext)
				{
					DebugLocation(169, 51);
					adaptor.AddChild(root_2, stream_condition.NextTree());

				}
				stream_condition.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(170, 8);
				// JavaScript.g:170:8: ^( FORSTMTINCR ( $incr)? )
				{
				CommonTree root_2 = (CommonTree)adaptor.Nil();
				DebugLocation(170, 10);
				root_2 = (CommonTree)adaptor.BecomeRoot(new ForStatementIncrementer(FORSTMTINCR), root_2);

				DebugLocation(170, 53);
				// JavaScript.g:170:53: ( $incr)?
				if (stream_incr.HasNext)
				{
					DebugLocation(170, 53);
					adaptor.AddChild(root_2, stream_incr.NextTree());

				}
				stream_incr.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(171, 8);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 24);
			LeaveRule("forStatement", 24);
			LeaveRule_forStatement();
			if (state.backtracking > 0) { Memoize(input, 24, forStatement_StartIndex); }

		}
		DebugLocation(172, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_forStatementInitialiserPart();
	partial void LeaveRule_forStatementInitialiserPart();
	// $ANTLR start "forStatementInitialiserPart"
	// JavaScript.g:174:1: forStatementInitialiserPart : ( expressionNoIn | 'var' ( LT )* variableDeclarationListNoIn -> ^( 'var' variableDeclarationListNoIn ) );
	[GrammarRule("forStatementInitialiserPart")]
	private AstParserRuleReturnScope<CommonTree, IToken> forStatementInitialiserPart()
	{
		EnterRule_forStatementInitialiserPart();
		EnterRule("forStatementInitialiserPart", 25);
		TraceIn("forStatementInitialiserPart", 25);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forStatementInitialiserPart_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal142 = default(IToken);
		IToken LT143 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expressionNoIn141 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationListNoIn144 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal142_tree = default(CommonTree);
		CommonTree LT143_tree = default(CommonTree);
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_variableDeclarationListNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationListNoIn");
		try { DebugEnterRule(GrammarFileName, "forStatementInitialiserPart");
		DebugLocation(174, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 25)) { return retval; }

			// JavaScript.g:175:2: ( expressionNoIn | 'var' ( LT )* variableDeclarationListNoIn -> ^( 'var' variableDeclarationListNoIn ) )
			int alt71=2;
			try { DebugEnterDecision(71, false);
			int LA71_1 = input.LA(1);

			if ((LA71_1==Identifier||LA71_1==NumericLiteral||LA71_1==StringLiteral||LA71_1==40||LA71_1==48||(LA71_1>=52 && LA71_1<=53)||(LA71_1>=56 && LA71_1<=57)||LA71_1==78||LA71_1==87||LA71_1==90||LA71_1==93||(LA71_1>=97 && LA71_1<=98)||LA71_1==101||LA71_1==103||LA71_1==105||LA71_1==107||LA71_1==110||LA71_1==115))
			{
				alt71 = 1;
			}
			else if ((LA71_1==106))
			{
				alt71 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 71, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(71); }
			switch (alt71)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:175:4: expressionNoIn
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(175, 4);
				PushFollow(Follow._expressionNoIn_in_forStatementInitialiserPart1213);
				expressionNoIn141=expressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, expressionNoIn141.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:176:4: 'var' ( LT )* variableDeclarationListNoIn
				{
				DebugLocation(176, 4);
				string_literal142=(IToken)Match(input,106,Follow._106_in_forStatementInitialiserPart1218); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_106.Add(string_literal142);

				DebugLocation(176, 10);
				// JavaScript.g:176:10: ( LT )*
				try { DebugEnterSubRule(70);
				while (true)
				{
					int alt70=2;
					try { DebugEnterDecision(70, false);
					int LA70_1 = input.LA(1);

					if ((LA70_1==LT))
					{
						alt70 = 1;
					}


					} finally { DebugExitDecision(70); }
					switch ( alt70 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:176:10: LT
						{
						DebugLocation(176, 10);
						LT143=(IToken)Match(input,LT,Follow._LT_in_forStatementInitialiserPart1220); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT143);


						}
						break;

					default:
						goto loop70;
					}
				}

				loop70:
					;

				} finally { DebugExitSubRule(70); }

				DebugLocation(176, 14);
				PushFollow(Follow._variableDeclarationListNoIn_in_forStatementInitialiserPart1223);
				variableDeclarationListNoIn144=variableDeclarationListNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDeclarationListNoIn.Add(variableDeclarationListNoIn144.Tree);


				{
				// AST REWRITE
				// elements: 106, variableDeclarationListNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 177:3: -> ^( 'var' variableDeclarationListNoIn )
				{
					DebugLocation(177, 6);
					// JavaScript.g:177:6: ^( 'var' variableDeclarationListNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(177, 8);
					root_1 = (CommonTree)adaptor.BecomeRoot(new VariableStatement(stream_106.NextToken()), root_1);

					DebugLocation(177, 38);
					adaptor.AddChild(root_1, stream_variableDeclarationListNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatementInitialiserPart", 25);
			LeaveRule("forStatementInitialiserPart", 25);
			LeaveRule_forStatementInitialiserPart();
			if (state.backtracking > 0) { Memoize(input, 25, forStatementInitialiserPart_StartIndex); }

		}
		DebugLocation(178, 1);
		} finally { DebugExitRule(GrammarFileName, "forStatementInitialiserPart"); }
		return retval;

	}
	// $ANTLR end "forStatementInitialiserPart"

	partial void EnterRule_forInStatement();
	partial void LeaveRule_forInStatement();
	// $ANTLR start "forInStatement"
	// JavaScript.g:180:1: forInStatement : 'for' ( LT )* '(' ( LT )* forInStatementInitialiserPart ( LT )* 'in' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'for' forInStatementInitialiserPart expression statement ) ;
	[GrammarRule("forInStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInStatement()
	{
		EnterRule_forInStatement();
		EnterRule("forInStatement", 26);
		TraceIn("forInStatement", 26);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forInStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal145 = default(IToken);
		IToken LT146 = default(IToken);
		IToken char_literal147 = default(IToken);
		IToken LT148 = default(IToken);
		IToken LT150 = default(IToken);
		IToken string_literal151 = default(IToken);
		IToken LT152 = default(IToken);
		IToken LT154 = default(IToken);
		IToken char_literal155 = default(IToken);
		IToken LT156 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> forInStatementInitialiserPart149 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression153 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement157 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal145_tree = default(CommonTree);
		CommonTree LT146_tree = default(CommonTree);
		CommonTree char_literal147_tree = default(CommonTree);
		CommonTree LT148_tree = default(CommonTree);
		CommonTree LT150_tree = default(CommonTree);
		CommonTree string_literal151_tree = default(CommonTree);
		CommonTree LT152_tree = default(CommonTree);
		CommonTree LT154_tree = default(CommonTree);
		CommonTree char_literal155_tree = default(CommonTree);
		CommonTree LT156_tree = default(CommonTree);
		RewriteRuleITokenStream stream_92=new RewriteRuleITokenStream(adaptor,"token 92");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_forInStatementInitialiserPart=new RewriteRuleSubtreeStream(adaptor,"rule forInStatementInitialiserPart");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "forInStatement");
		DebugLocation(180, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 26)) { return retval; }

			// JavaScript.g:181:2: ( 'for' ( LT )* '(' ( LT )* forInStatementInitialiserPart ( LT )* 'in' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'for' forInStatementInitialiserPart expression statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:181:4: 'for' ( LT )* '(' ( LT )* forInStatementInitialiserPart ( LT )* 'in' ( LT )* expression ( LT )* ')' ( LT )* statement
			{
			DebugLocation(181, 4);
			string_literal145=(IToken)Match(input,92,Follow._92_in_forInStatement1251); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_92.Add(string_literal145);

			DebugLocation(181, 10);
			// JavaScript.g:181:10: ( LT )*
			try { DebugEnterSubRule(72);
			while (true)
			{
				int alt72=2;
				try { DebugEnterDecision(72, false);
				int LA72_1 = input.LA(1);

				if ((LA72_1==LT))
				{
					alt72 = 1;
				}


				} finally { DebugExitDecision(72); }
				switch ( alt72 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:10: LT
					{
					DebugLocation(181, 10);
					LT146=(IToken)Match(input,LT,Follow._LT_in_forInStatement1253); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT146);


					}
					break;

				default:
					goto loop72;
				}
			}

			loop72:
				;

			} finally { DebugExitSubRule(72); }

			DebugLocation(181, 14);
			char_literal147=(IToken)Match(input,48,Follow._48_in_forInStatement1256); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal147);

			DebugLocation(181, 18);
			// JavaScript.g:181:18: ( LT )*
			try { DebugEnterSubRule(73);
			while (true)
			{
				int alt73=2;
				try { DebugEnterDecision(73, false);
				int LA73_1 = input.LA(1);

				if ((LA73_1==LT))
				{
					alt73 = 1;
				}


				} finally { DebugExitDecision(73); }
				switch ( alt73 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:18: LT
					{
					DebugLocation(181, 18);
					LT148=(IToken)Match(input,LT,Follow._LT_in_forInStatement1258); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT148);


					}
					break;

				default:
					goto loop73;
				}
			}

			loop73:
				;

			} finally { DebugExitSubRule(73); }

			DebugLocation(181, 22);
			PushFollow(Follow._forInStatementInitialiserPart_in_forInStatement1261);
			forInStatementInitialiserPart149=forInStatementInitialiserPart();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_forInStatementInitialiserPart.Add(forInStatementInitialiserPart149.Tree);
			DebugLocation(181, 52);
			// JavaScript.g:181:52: ( LT )*
			try { DebugEnterSubRule(74);
			while (true)
			{
				int alt74=2;
				try { DebugEnterDecision(74, false);
				int LA74_1 = input.LA(1);

				if ((LA74_1==LT))
				{
					alt74 = 1;
				}


				} finally { DebugExitDecision(74); }
				switch ( alt74 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:52: LT
					{
					DebugLocation(181, 52);
					LT150=(IToken)Match(input,LT,Follow._LT_in_forInStatement1263); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT150);


					}
					break;

				default:
					goto loop74;
				}
			}

			loop74:
				;

			} finally { DebugExitSubRule(74); }

			DebugLocation(181, 56);
			string_literal151=(IToken)Match(input,95,Follow._95_in_forInStatement1266); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_95.Add(string_literal151);

			DebugLocation(181, 61);
			// JavaScript.g:181:61: ( LT )*
			try { DebugEnterSubRule(75);
			while (true)
			{
				int alt75=2;
				try { DebugEnterDecision(75, false);
				int LA75_1 = input.LA(1);

				if ((LA75_1==LT))
				{
					alt75 = 1;
				}


				} finally { DebugExitDecision(75); }
				switch ( alt75 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:61: LT
					{
					DebugLocation(181, 61);
					LT152=(IToken)Match(input,LT,Follow._LT_in_forInStatement1268); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT152);


					}
					break;

				default:
					goto loop75;
				}
			}

			loop75:
				;

			} finally { DebugExitSubRule(75); }

			DebugLocation(181, 65);
			PushFollow(Follow._expression_in_forInStatement1271);
			expression153=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression153.Tree);
			DebugLocation(181, 76);
			// JavaScript.g:181:76: ( LT )*
			try { DebugEnterSubRule(76);
			while (true)
			{
				int alt76=2;
				try { DebugEnterDecision(76, false);
				int LA76_1 = input.LA(1);

				if ((LA76_1==LT))
				{
					alt76 = 1;
				}


				} finally { DebugExitDecision(76); }
				switch ( alt76 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:76: LT
					{
					DebugLocation(181, 76);
					LT154=(IToken)Match(input,LT,Follow._LT_in_forInStatement1273); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT154);


					}
					break;

				default:
					goto loop76;
				}
			}

			loop76:
				;

			} finally { DebugExitSubRule(76); }

			DebugLocation(181, 80);
			char_literal155=(IToken)Match(input,49,Follow._49_in_forInStatement1276); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal155);

			DebugLocation(181, 84);
			// JavaScript.g:181:84: ( LT )*
			try { DebugEnterSubRule(77);
			while (true)
			{
				int alt77=2;
				try { DebugEnterDecision(77, false);
				int LA77_1 = input.LA(1);

				if ((LA77_1==LT))
				{
					alt77 = 1;
				}


				} finally { DebugExitDecision(77); }
				switch ( alt77 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:181:84: LT
					{
					DebugLocation(181, 84);
					LT156=(IToken)Match(input,LT,Follow._LT_in_forInStatement1278); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT156);


					}
					break;

				default:
					goto loop77;
				}
			}

			loop77:
				;

			} finally { DebugExitSubRule(77); }

			DebugLocation(181, 88);
			PushFollow(Follow._statement_in_forInStatement1281);
			statement157=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement157.Tree);


			{
			// AST REWRITE
			// elements: 92, forInStatementInitialiserPart, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 182:3: -> ^( 'for' forInStatementInitialiserPart expression statement )
			{
				DebugLocation(182, 6);
				// JavaScript.g:182:6: ^( 'for' forInStatementInitialiserPart expression statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(182, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ForInStatement(stream_92.NextToken()), root_1);

				DebugLocation(183, 4);
				adaptor.AddChild(root_1, stream_forInStatementInitialiserPart.NextTree());
				DebugLocation(184, 4);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(185, 4);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInStatement", 26);
			LeaveRule("forInStatement", 26);
			LeaveRule_forInStatement();
			if (state.backtracking > 0) { Memoize(input, 26, forInStatement_StartIndex); }

		}
		DebugLocation(186, 1);
		} finally { DebugExitRule(GrammarFileName, "forInStatement"); }
		return retval;

	}
	// $ANTLR end "forInStatement"

	partial void EnterRule_forInStatementInitialiserPart();
	partial void LeaveRule_forInStatementInitialiserPart();
	// $ANTLR start "forInStatementInitialiserPart"
	// JavaScript.g:188:1: forInStatementInitialiserPart : ( leftHandSideExpression | 'var' ( LT )* variableDeclarationNoIn -> variableDeclarationNoIn );
	[GrammarRule("forInStatementInitialiserPart")]
	private AstParserRuleReturnScope<CommonTree, IToken> forInStatementInitialiserPart()
	{
		EnterRule_forInStatementInitialiserPart();
		EnterRule("forInStatementInitialiserPart", 27);
		TraceIn("forInStatementInitialiserPart", 27);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int forInStatementInitialiserPart_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal159 = default(IToken);
		IToken LT160 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> leftHandSideExpression158 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> variableDeclarationNoIn161 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal159_tree = default(CommonTree);
		CommonTree LT160_tree = default(CommonTree);
		RewriteRuleITokenStream stream_106=new RewriteRuleITokenStream(adaptor,"token 106");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_variableDeclarationNoIn=new RewriteRuleSubtreeStream(adaptor,"rule variableDeclarationNoIn");
		try { DebugEnterRule(GrammarFileName, "forInStatementInitialiserPart");
		DebugLocation(188, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 27)) { return retval; }

			// JavaScript.g:189:2: ( leftHandSideExpression | 'var' ( LT )* variableDeclarationNoIn -> variableDeclarationNoIn )
			int alt79=2;
			try { DebugEnterDecision(79, false);
			int LA79_1 = input.LA(1);

			if ((LA79_1==Identifier||LA79_1==NumericLiteral||LA79_1==StringLiteral||LA79_1==48||LA79_1==78||LA79_1==90||LA79_1==93||(LA79_1>=97 && LA79_1<=98)||LA79_1==101||LA79_1==103||LA79_1==110))
			{
				alt79 = 1;
			}
			else if ((LA79_1==106))
			{
				alt79 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 79, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(79); }
			switch (alt79)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:189:4: leftHandSideExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(189, 4);
				PushFollow(Follow._leftHandSideExpression_in_forInStatementInitialiserPart1323);
				leftHandSideExpression158=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, leftHandSideExpression158.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:190:4: 'var' ( LT )* variableDeclarationNoIn
				{
				DebugLocation(190, 4);
				string_literal159=(IToken)Match(input,106,Follow._106_in_forInStatementInitialiserPart1328); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_106.Add(string_literal159);

				DebugLocation(190, 10);
				// JavaScript.g:190:10: ( LT )*
				try { DebugEnterSubRule(78);
				while (true)
				{
					int alt78=2;
					try { DebugEnterDecision(78, false);
					int LA78_1 = input.LA(1);

					if ((LA78_1==LT))
					{
						alt78 = 1;
					}


					} finally { DebugExitDecision(78); }
					switch ( alt78 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:190:10: LT
						{
						DebugLocation(190, 10);
						LT160=(IToken)Match(input,LT,Follow._LT_in_forInStatementInitialiserPart1330); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT160);


						}
						break;

					default:
						goto loop78;
					}
				}

				loop78:
					;

				} finally { DebugExitSubRule(78); }

				DebugLocation(190, 14);
				PushFollow(Follow._variableDeclarationNoIn_in_forInStatementInitialiserPart1333);
				variableDeclarationNoIn161=variableDeclarationNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_variableDeclarationNoIn.Add(variableDeclarationNoIn161.Tree);


				{
				// AST REWRITE
				// elements: variableDeclarationNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 190:38: -> variableDeclarationNoIn
				{
					DebugLocation(190, 41);
					adaptor.AddChild(root_0, stream_variableDeclarationNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forInStatementInitialiserPart", 27);
			LeaveRule("forInStatementInitialiserPart", 27);
			LeaveRule_forInStatementInitialiserPart();
			if (state.backtracking > 0) { Memoize(input, 27, forInStatementInitialiserPart_StartIndex); }

		}
		DebugLocation(191, 1);
		} finally { DebugExitRule(GrammarFileName, "forInStatementInitialiserPart"); }
		return retval;

	}
	// $ANTLR end "forInStatementInitialiserPart"

	partial void EnterRule_continueStatement();
	partial void LeaveRule_continueStatement();
	// $ANTLR start "continueStatement"
	// JavaScript.g:193:1: continueStatement : 'continue' ( Identifier )? ( LT | ';' ) -> ^( 'continue' ( Identifier )? ) ;
	[GrammarRule("continueStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> continueStatement()
	{
		EnterRule_continueStatement();
		EnterRule("continueStatement", 28);
		TraceIn("continueStatement", 28);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int continueStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal162 = default(IToken);
		IToken Identifier163 = default(IToken);
		IToken LT164 = default(IToken);
		IToken char_literal165 = default(IToken);

		CommonTree string_literal162_tree = default(CommonTree);
		CommonTree Identifier163_tree = default(CommonTree);
		CommonTree LT164_tree = default(CommonTree);
		CommonTree char_literal165_tree = default(CommonTree);
		RewriteRuleITokenStream stream_85=new RewriteRuleITokenStream(adaptor,"token 85");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		try { DebugEnterRule(GrammarFileName, "continueStatement");
		DebugLocation(193, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 28)) { return retval; }

			// JavaScript.g:194:2: ( 'continue' ( Identifier )? ( LT | ';' ) -> ^( 'continue' ( Identifier )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:194:4: 'continue' ( Identifier )? ( LT | ';' )
			{
			DebugLocation(194, 4);
			string_literal162=(IToken)Match(input,85,Follow._85_in_continueStatement1348); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_85.Add(string_literal162);

			DebugLocation(194, 15);
			// JavaScript.g:194:15: ( Identifier )?
			int alt80=2;
			try { DebugEnterSubRule(80);
			try { DebugEnterDecision(80, false);
			int LA80_1 = input.LA(1);

			if ((LA80_1==Identifier))
			{
				alt80 = 1;
			}
			} finally { DebugExitDecision(80); }
			switch (alt80)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:194:15: Identifier
				{
				DebugLocation(194, 15);
				Identifier163=(IToken)Match(input,Identifier,Follow._Identifier_in_continueStatement1350); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier163);


				}
				break;

			}
			} finally { DebugExitSubRule(80); }

			DebugLocation(194, 27);
			// JavaScript.g:194:27: ( LT | ';' )
			int alt81=2;
			try { DebugEnterSubRule(81);
			try { DebugEnterDecision(81, false);
			int LA81_1 = input.LA(1);

			if ((LA81_1==LT))
			{
				alt81 = 1;
			}
			else if ((LA81_1==63))
			{
				alt81 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 81, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(81); }
			switch (alt81)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:194:28: LT
				{
				DebugLocation(194, 28);
				LT164=(IToken)Match(input,LT,Follow._LT_in_continueStatement1354); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT164);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:194:33: ';'
				{
				DebugLocation(194, 33);
				char_literal165=(IToken)Match(input,63,Follow._63_in_continueStatement1358); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal165);


				}
				break;

			}
			} finally { DebugExitSubRule(81); }



			{
			// AST REWRITE
			// elements: 85, Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 195:3: -> ^( 'continue' ( Identifier )? )
			{
				DebugLocation(195, 6);
				// JavaScript.g:195:6: ^( 'continue' ( Identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(195, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ContinueStatement(stream_85.NextToken()), root_1);

				DebugLocation(195, 43);
				// JavaScript.g:195:43: ( Identifier )?
				if (stream_Identifier.HasNext)
				{
					DebugLocation(195, 43);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("continueStatement", 28);
			LeaveRule("continueStatement", 28);
			LeaveRule_continueStatement();
			if (state.backtracking > 0) { Memoize(input, 28, continueStatement_StartIndex); }

		}
		DebugLocation(196, 1);
		} finally { DebugExitRule(GrammarFileName, "continueStatement"); }
		return retval;

	}
	// $ANTLR end "continueStatement"

	partial void EnterRule_breakStatement();
	partial void LeaveRule_breakStatement();
	// $ANTLR start "breakStatement"
	// JavaScript.g:198:1: breakStatement : 'break' ( Identifier )? ( LT | ';' ) -> ^( 'break' ( Identifier )? ) ;
	[GrammarRule("breakStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> breakStatement()
	{
		EnterRule_breakStatement();
		EnterRule("breakStatement", 29);
		TraceIn("breakStatement", 29);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int breakStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal166 = default(IToken);
		IToken Identifier167 = default(IToken);
		IToken LT168 = default(IToken);
		IToken char_literal169 = default(IToken);

		CommonTree string_literal166_tree = default(CommonTree);
		CommonTree Identifier167_tree = default(CommonTree);
		CommonTree LT168_tree = default(CommonTree);
		CommonTree char_literal169_tree = default(CommonTree);
		RewriteRuleITokenStream stream_82=new RewriteRuleITokenStream(adaptor,"token 82");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		try { DebugEnterRule(GrammarFileName, "breakStatement");
		DebugLocation(198, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 29)) { return retval; }

			// JavaScript.g:199:2: ( 'break' ( Identifier )? ( LT | ';' ) -> ^( 'break' ( Identifier )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:199:4: 'break' ( Identifier )? ( LT | ';' )
			{
			DebugLocation(199, 4);
			string_literal166=(IToken)Match(input,82,Follow._82_in_breakStatement1392); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_82.Add(string_literal166);

			DebugLocation(199, 12);
			// JavaScript.g:199:12: ( Identifier )?
			int alt82=2;
			try { DebugEnterSubRule(82);
			try { DebugEnterDecision(82, false);
			int LA82_1 = input.LA(1);

			if ((LA82_1==Identifier))
			{
				alt82 = 1;
			}
			} finally { DebugExitDecision(82); }
			switch (alt82)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:199:12: Identifier
				{
				DebugLocation(199, 12);
				Identifier167=(IToken)Match(input,Identifier,Follow._Identifier_in_breakStatement1394); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier167);


				}
				break;

			}
			} finally { DebugExitSubRule(82); }

			DebugLocation(199, 24);
			// JavaScript.g:199:24: ( LT | ';' )
			int alt83=2;
			try { DebugEnterSubRule(83);
			try { DebugEnterDecision(83, false);
			int LA83_1 = input.LA(1);

			if ((LA83_1==LT))
			{
				alt83 = 1;
			}
			else if ((LA83_1==63))
			{
				alt83 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 83, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(83); }
			switch (alt83)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:199:25: LT
				{
				DebugLocation(199, 25);
				LT168=(IToken)Match(input,LT,Follow._LT_in_breakStatement1398); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT168);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:199:30: ';'
				{
				DebugLocation(199, 30);
				char_literal169=(IToken)Match(input,63,Follow._63_in_breakStatement1402); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal169);


				}
				break;

			}
			} finally { DebugExitSubRule(83); }



			{
			// AST REWRITE
			// elements: 82, Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 199:35: -> ^( 'break' ( Identifier )? )
			{
				DebugLocation(199, 38);
				// JavaScript.g:199:38: ^( 'break' ( Identifier )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(199, 40);
				root_1 = (CommonTree)adaptor.BecomeRoot(new BreakStatement(stream_82.NextToken()), root_1);

				DebugLocation(199, 69);
				// JavaScript.g:199:69: ( Identifier )?
				if (stream_Identifier.HasNext)
				{
					DebugLocation(199, 69);
					adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));

				}
				stream_Identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("breakStatement", 29);
			LeaveRule("breakStatement", 29);
			LeaveRule_breakStatement();
			if (state.backtracking > 0) { Memoize(input, 29, breakStatement_StartIndex); }

		}
		DebugLocation(200, 1);
		} finally { DebugExitRule(GrammarFileName, "breakStatement"); }
		return retval;

	}
	// $ANTLR end "breakStatement"

	partial void EnterRule_returnStatement();
	partial void LeaveRule_returnStatement();
	// $ANTLR start "returnStatement"
	// JavaScript.g:202:1: returnStatement : 'return' ( expression )? ( LT | ';' ) -> ^( 'return' ( expression )? ) ;
	[GrammarRule("returnStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> returnStatement()
	{
		EnterRule_returnStatement();
		EnterRule("returnStatement", 30);
		TraceIn("returnStatement", 30);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int returnStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal170 = default(IToken);
		IToken LT172 = default(IToken);
		IToken char_literal173 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression171 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal170_tree = default(CommonTree);
		CommonTree LT172_tree = default(CommonTree);
		CommonTree char_literal173_tree = default(CommonTree);
		RewriteRuleITokenStream stream_99=new RewriteRuleITokenStream(adaptor,"token 99");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "returnStatement");
		DebugLocation(202, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 30)) { return retval; }

			// JavaScript.g:203:2: ( 'return' ( expression )? ( LT | ';' ) -> ^( 'return' ( expression )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:203:4: 'return' ( expression )? ( LT | ';' )
			{
			DebugLocation(203, 4);
			string_literal170=(IToken)Match(input,99,Follow._99_in_returnStatement1433); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_99.Add(string_literal170);

			DebugLocation(203, 13);
			// JavaScript.g:203:13: ( expression )?
			int alt84=2;
			try { DebugEnterSubRule(84);
			try { DebugEnterDecision(84, false);
			int LA84_1 = input.LA(1);

			if ((LA84_1==Identifier||LA84_1==NumericLiteral||LA84_1==StringLiteral||LA84_1==40||LA84_1==48||(LA84_1>=52 && LA84_1<=53)||(LA84_1>=56 && LA84_1<=57)||LA84_1==78||LA84_1==87||LA84_1==90||LA84_1==93||(LA84_1>=97 && LA84_1<=98)||LA84_1==101||LA84_1==103||LA84_1==105||LA84_1==107||LA84_1==110||LA84_1==115))
			{
				alt84 = 1;
			}
			} finally { DebugExitDecision(84); }
			switch (alt84)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:203:13: expression
				{
				DebugLocation(203, 13);
				PushFollow(Follow._expression_in_returnStatement1435);
				expression171=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression171.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(84); }

			DebugLocation(203, 25);
			// JavaScript.g:203:25: ( LT | ';' )
			int alt85=2;
			try { DebugEnterSubRule(85);
			try { DebugEnterDecision(85, false);
			int LA85_1 = input.LA(1);

			if ((LA85_1==LT))
			{
				alt85 = 1;
			}
			else if ((LA85_1==63))
			{
				alt85 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 85, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(85); }
			switch (alt85)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:203:26: LT
				{
				DebugLocation(203, 26);
				LT172=(IToken)Match(input,LT,Follow._LT_in_returnStatement1439); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT172);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:203:31: ';'
				{
				DebugLocation(203, 31);
				char_literal173=(IToken)Match(input,63,Follow._63_in_returnStatement1443); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal173);


				}
				break;

			}
			} finally { DebugExitSubRule(85); }



			{
			// AST REWRITE
			// elements: 99, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 203:36: -> ^( 'return' ( expression )? )
			{
				DebugLocation(203, 39);
				// JavaScript.g:203:39: ^( 'return' ( expression )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(203, 41);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ReturnStatement(stream_99.NextToken()), root_1);

				DebugLocation(203, 72);
				// JavaScript.g:203:72: ( expression )?
				if (stream_expression.HasNext)
				{
					DebugLocation(203, 72);
					adaptor.AddChild(root_1, stream_expression.NextTree());

				}
				stream_expression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("returnStatement", 30);
			LeaveRule("returnStatement", 30);
			LeaveRule_returnStatement();
			if (state.backtracking > 0) { Memoize(input, 30, returnStatement_StartIndex); }

		}
		DebugLocation(204, 1);
		} finally { DebugExitRule(GrammarFileName, "returnStatement"); }
		return retval;

	}
	// $ANTLR end "returnStatement"

	partial void EnterRule_withStatement();
	partial void LeaveRule_withStatement();
	// $ANTLR start "withStatement"
	// JavaScript.g:206:1: withStatement : 'with' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'with' expression statement ) ;
	[GrammarRule("withStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> withStatement()
	{
		EnterRule_withStatement();
		EnterRule("withStatement", 31);
		TraceIn("withStatement", 31);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int withStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal174 = default(IToken);
		IToken LT175 = default(IToken);
		IToken char_literal176 = default(IToken);
		IToken LT177 = default(IToken);
		IToken LT179 = default(IToken);
		IToken char_literal180 = default(IToken);
		IToken LT181 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression178 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statement182 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal174_tree = default(CommonTree);
		CommonTree LT175_tree = default(CommonTree);
		CommonTree char_literal176_tree = default(CommonTree);
		CommonTree LT177_tree = default(CommonTree);
		CommonTree LT179_tree = default(CommonTree);
		CommonTree char_literal180_tree = default(CommonTree);
		CommonTree LT181_tree = default(CommonTree);
		RewriteRuleITokenStream stream_109=new RewriteRuleITokenStream(adaptor,"token 109");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "withStatement");
		DebugLocation(206, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 31)) { return retval; }

			// JavaScript.g:207:2: ( 'with' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement -> ^( 'with' expression statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:207:4: 'with' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* statement
			{
			DebugLocation(207, 4);
			string_literal174=(IToken)Match(input,109,Follow._109_in_withStatement1470); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_109.Add(string_literal174);

			DebugLocation(207, 11);
			// JavaScript.g:207:11: ( LT )*
			try { DebugEnterSubRule(86);
			while (true)
			{
				int alt86=2;
				try { DebugEnterDecision(86, false);
				int LA86_1 = input.LA(1);

				if ((LA86_1==LT))
				{
					alt86 = 1;
				}


				} finally { DebugExitDecision(86); }
				switch ( alt86 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:11: LT
					{
					DebugLocation(207, 11);
					LT175=(IToken)Match(input,LT,Follow._LT_in_withStatement1472); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT175);


					}
					break;

				default:
					goto loop86;
				}
			}

			loop86:
				;

			} finally { DebugExitSubRule(86); }

			DebugLocation(207, 15);
			char_literal176=(IToken)Match(input,48,Follow._48_in_withStatement1475); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal176);

			DebugLocation(207, 19);
			// JavaScript.g:207:19: ( LT )*
			try { DebugEnterSubRule(87);
			while (true)
			{
				int alt87=2;
				try { DebugEnterDecision(87, false);
				int LA87_1 = input.LA(1);

				if ((LA87_1==LT))
				{
					alt87 = 1;
				}


				} finally { DebugExitDecision(87); }
				switch ( alt87 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:19: LT
					{
					DebugLocation(207, 19);
					LT177=(IToken)Match(input,LT,Follow._LT_in_withStatement1477); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT177);


					}
					break;

				default:
					goto loop87;
				}
			}

			loop87:
				;

			} finally { DebugExitSubRule(87); }

			DebugLocation(207, 23);
			PushFollow(Follow._expression_in_withStatement1480);
			expression178=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression178.Tree);
			DebugLocation(207, 34);
			// JavaScript.g:207:34: ( LT )*
			try { DebugEnterSubRule(88);
			while (true)
			{
				int alt88=2;
				try { DebugEnterDecision(88, false);
				int LA88_1 = input.LA(1);

				if ((LA88_1==LT))
				{
					alt88 = 1;
				}


				} finally { DebugExitDecision(88); }
				switch ( alt88 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:34: LT
					{
					DebugLocation(207, 34);
					LT179=(IToken)Match(input,LT,Follow._LT_in_withStatement1482); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT179);


					}
					break;

				default:
					goto loop88;
				}
			}

			loop88:
				;

			} finally { DebugExitSubRule(88); }

			DebugLocation(207, 38);
			char_literal180=(IToken)Match(input,49,Follow._49_in_withStatement1485); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal180);

			DebugLocation(207, 42);
			// JavaScript.g:207:42: ( LT )*
			try { DebugEnterSubRule(89);
			while (true)
			{
				int alt89=2;
				try { DebugEnterDecision(89, false);
				int LA89_1 = input.LA(1);

				if ((LA89_1==LT))
				{
					alt89 = 1;
				}


				} finally { DebugExitDecision(89); }
				switch ( alt89 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:207:42: LT
					{
					DebugLocation(207, 42);
					LT181=(IToken)Match(input,LT,Follow._LT_in_withStatement1487); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT181);


					}
					break;

				default:
					goto loop89;
				}
			}

			loop89:
				;

			} finally { DebugExitSubRule(89); }

			DebugLocation(207, 46);
			PushFollow(Follow._statement_in_withStatement1490);
			statement182=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement182.Tree);


			{
			// AST REWRITE
			// elements: 109, expression, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 208:3: -> ^( 'with' expression statement )
			{
				DebugLocation(208, 6);
				// JavaScript.g:208:6: ^( 'with' expression statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(208, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new WithStatement(stream_109.NextToken()), root_1);

				DebugLocation(208, 35);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(208, 46);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("withStatement", 31);
			LeaveRule("withStatement", 31);
			LeaveRule_withStatement();
			if (state.backtracking > 0) { Memoize(input, 31, withStatement_StartIndex); }

		}
		DebugLocation(209, 1);
		} finally { DebugExitRule(GrammarFileName, "withStatement"); }
		return retval;

	}
	// $ANTLR end "withStatement"

	partial void EnterRule_labelledStatement();
	partial void LeaveRule_labelledStatement();
	// $ANTLR start "labelledStatement"
	// JavaScript.g:211:1: labelledStatement : Identifier ( LT )* ':' ( LT )* statement -> ^( ':' Identifier statement ) ;
	[GrammarRule("labelledStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> labelledStatement()
	{
		EnterRule_labelledStatement();
		EnterRule("labelledStatement", 32);
		TraceIn("labelledStatement", 32);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int labelledStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier183 = default(IToken);
		IToken LT184 = default(IToken);
		IToken char_literal185 = default(IToken);
		IToken LT186 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statement187 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree Identifier183_tree = default(CommonTree);
		CommonTree LT184_tree = default(CommonTree);
		CommonTree char_literal185_tree = default(CommonTree);
		CommonTree LT186_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_statement=new RewriteRuleSubtreeStream(adaptor,"rule statement");
		try { DebugEnterRule(GrammarFileName, "labelledStatement");
		DebugLocation(211, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 32)) { return retval; }

			// JavaScript.g:212:2: ( Identifier ( LT )* ':' ( LT )* statement -> ^( ':' Identifier statement ) )
			DebugEnterAlt(1);
			// JavaScript.g:212:4: Identifier ( LT )* ':' ( LT )* statement
			{
			DebugLocation(212, 4);
			Identifier183=(IToken)Match(input,Identifier,Follow._Identifier_in_labelledStatement1519); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier183);

			DebugLocation(212, 15);
			// JavaScript.g:212:15: ( LT )*
			try { DebugEnterSubRule(90);
			while (true)
			{
				int alt90=2;
				try { DebugEnterDecision(90, false);
				int LA90_1 = input.LA(1);

				if ((LA90_1==LT))
				{
					alt90 = 1;
				}


				} finally { DebugExitDecision(90); }
				switch ( alt90 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:212:15: LT
					{
					DebugLocation(212, 15);
					LT184=(IToken)Match(input,LT,Follow._LT_in_labelledStatement1521); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT184);


					}
					break;

				default:
					goto loop90;
				}
			}

			loop90:
				;

			} finally { DebugExitSubRule(90); }

			DebugLocation(212, 19);
			char_literal185=(IToken)Match(input,62,Follow._62_in_labelledStatement1524); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal185);

			DebugLocation(212, 23);
			// JavaScript.g:212:23: ( LT )*
			try { DebugEnterSubRule(91);
			while (true)
			{
				int alt91=2;
				try { DebugEnterDecision(91, false);
				int LA91_1 = input.LA(1);

				if ((LA91_1==LT))
				{
					alt91 = 1;
				}


				} finally { DebugExitDecision(91); }
				switch ( alt91 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:212:23: LT
					{
					DebugLocation(212, 23);
					LT186=(IToken)Match(input,LT,Follow._LT_in_labelledStatement1526); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT186);


					}
					break;

				default:
					goto loop91;
				}
			}

			loop91:
				;

			} finally { DebugExitSubRule(91); }

			DebugLocation(212, 27);
			PushFollow(Follow._statement_in_labelledStatement1529);
			statement187=statement();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statement.Add(statement187.Tree);


			{
			// AST REWRITE
			// elements: 62, Identifier, statement
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 213:9: -> ^( ':' Identifier statement )
			{
				DebugLocation(213, 12);
				// JavaScript.g:213:12: ^( ':' Identifier statement )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(213, 14);
				root_1 = (CommonTree)adaptor.BecomeRoot(new LabeledStatement(stream_62.NextToken()), root_1);

				DebugLocation(213, 41);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(213, 69);
				adaptor.AddChild(root_1, stream_statement.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("labelledStatement", 32);
			LeaveRule("labelledStatement", 32);
			LeaveRule_labelledStatement();
			if (state.backtracking > 0) { Memoize(input, 32, labelledStatement_StartIndex); }

		}
		DebugLocation(214, 1);
		} finally { DebugExitRule(GrammarFileName, "labelledStatement"); }
		return retval;

	}
	// $ANTLR end "labelledStatement"

	partial void EnterRule_switchStatement();
	partial void LeaveRule_switchStatement();
	// $ANTLR start "switchStatement"
	// JavaScript.g:216:1: switchStatement : 'switch' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* caseBlock -> ^( 'switch' expression caseBlock ) ;
	[GrammarRule("switchStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> switchStatement()
	{
		EnterRule_switchStatement();
		EnterRule("switchStatement", 33);
		TraceIn("switchStatement", 33);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int switchStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal188 = default(IToken);
		IToken LT189 = default(IToken);
		IToken char_literal190 = default(IToken);
		IToken LT191 = default(IToken);
		IToken LT193 = default(IToken);
		IToken char_literal194 = default(IToken);
		IToken LT195 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression192 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> caseBlock196 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal188_tree = default(CommonTree);
		CommonTree LT189_tree = default(CommonTree);
		CommonTree char_literal190_tree = default(CommonTree);
		CommonTree LT191_tree = default(CommonTree);
		CommonTree LT193_tree = default(CommonTree);
		CommonTree char_literal194_tree = default(CommonTree);
		CommonTree LT195_tree = default(CommonTree);
		RewriteRuleITokenStream stream_100=new RewriteRuleITokenStream(adaptor,"token 100");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_caseBlock=new RewriteRuleSubtreeStream(adaptor,"rule caseBlock");
		try { DebugEnterRule(GrammarFileName, "switchStatement");
		DebugLocation(216, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 33)) { return retval; }

			// JavaScript.g:217:2: ( 'switch' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* caseBlock -> ^( 'switch' expression caseBlock ) )
			DebugEnterAlt(1);
			// JavaScript.g:217:4: 'switch' ( LT )* '(' ( LT )* expression ( LT )* ')' ( LT )* caseBlock
			{
			DebugLocation(217, 4);
			string_literal188=(IToken)Match(input,100,Follow._100_in_switchStatement1570); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_100.Add(string_literal188);

			DebugLocation(217, 13);
			// JavaScript.g:217:13: ( LT )*
			try { DebugEnterSubRule(92);
			while (true)
			{
				int alt92=2;
				try { DebugEnterDecision(92, false);
				int LA92_1 = input.LA(1);

				if ((LA92_1==LT))
				{
					alt92 = 1;
				}


				} finally { DebugExitDecision(92); }
				switch ( alt92 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:13: LT
					{
					DebugLocation(217, 13);
					LT189=(IToken)Match(input,LT,Follow._LT_in_switchStatement1572); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT189);


					}
					break;

				default:
					goto loop92;
				}
			}

			loop92:
				;

			} finally { DebugExitSubRule(92); }

			DebugLocation(217, 17);
			char_literal190=(IToken)Match(input,48,Follow._48_in_switchStatement1575); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal190);

			DebugLocation(217, 21);
			// JavaScript.g:217:21: ( LT )*
			try { DebugEnterSubRule(93);
			while (true)
			{
				int alt93=2;
				try { DebugEnterDecision(93, false);
				int LA93_1 = input.LA(1);

				if ((LA93_1==LT))
				{
					alt93 = 1;
				}


				} finally { DebugExitDecision(93); }
				switch ( alt93 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:21: LT
					{
					DebugLocation(217, 21);
					LT191=(IToken)Match(input,LT,Follow._LT_in_switchStatement1577); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT191);


					}
					break;

				default:
					goto loop93;
				}
			}

			loop93:
				;

			} finally { DebugExitSubRule(93); }

			DebugLocation(217, 25);
			PushFollow(Follow._expression_in_switchStatement1580);
			expression192=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression192.Tree);
			DebugLocation(217, 36);
			// JavaScript.g:217:36: ( LT )*
			try { DebugEnterSubRule(94);
			while (true)
			{
				int alt94=2;
				try { DebugEnterDecision(94, false);
				int LA94_1 = input.LA(1);

				if ((LA94_1==LT))
				{
					alt94 = 1;
				}


				} finally { DebugExitDecision(94); }
				switch ( alt94 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:36: LT
					{
					DebugLocation(217, 36);
					LT193=(IToken)Match(input,LT,Follow._LT_in_switchStatement1582); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT193);


					}
					break;

				default:
					goto loop94;
				}
			}

			loop94:
				;

			} finally { DebugExitSubRule(94); }

			DebugLocation(217, 40);
			char_literal194=(IToken)Match(input,49,Follow._49_in_switchStatement1585); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal194);

			DebugLocation(217, 44);
			// JavaScript.g:217:44: ( LT )*
			try { DebugEnterSubRule(95);
			while (true)
			{
				int alt95=2;
				try { DebugEnterDecision(95, false);
				int LA95_1 = input.LA(1);

				if ((LA95_1==LT))
				{
					alt95 = 1;
				}


				} finally { DebugExitDecision(95); }
				switch ( alt95 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:217:44: LT
					{
					DebugLocation(217, 44);
					LT195=(IToken)Match(input,LT,Follow._LT_in_switchStatement1587); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT195);


					}
					break;

				default:
					goto loop95;
				}
			}

			loop95:
				;

			} finally { DebugExitSubRule(95); }

			DebugLocation(217, 48);
			PushFollow(Follow._caseBlock_in_switchStatement1590);
			caseBlock196=caseBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_caseBlock.Add(caseBlock196.Tree);


			{
			// AST REWRITE
			// elements: 100, expression, caseBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 218:3: -> ^( 'switch' expression caseBlock )
			{
				DebugLocation(218, 6);
				// JavaScript.g:218:6: ^( 'switch' expression caseBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(218, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new SwitchStatement(stream_100.NextToken()), root_1);

				DebugLocation(218, 39);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(218, 50);
				adaptor.AddChild(root_1, stream_caseBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("switchStatement", 33);
			LeaveRule("switchStatement", 33);
			LeaveRule_switchStatement();
			if (state.backtracking > 0) { Memoize(input, 33, switchStatement_StartIndex); }

		}
		DebugLocation(219, 1);
		} finally { DebugExitRule(GrammarFileName, "switchStatement"); }
		return retval;

	}
	// $ANTLR end "switchStatement"

	partial void EnterRule_caseBlock();
	partial void LeaveRule_caseBlock();
	// $ANTLR start "caseBlock"
	// JavaScript.g:221:1: caseBlock : '{' ! ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' !;
	[GrammarRule("caseBlock")]
	private AstParserRuleReturnScope<CommonTree, IToken> caseBlock()
	{
		EnterRule_caseBlock();
		EnterRule("caseBlock", 34);
		TraceIn("caseBlock", 34);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int caseBlock_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal197 = default(IToken);
		IToken LT198 = default(IToken);
		IToken LT200 = default(IToken);
		IToken LT202 = default(IToken);
		IToken LT204 = default(IToken);
		IToken char_literal205 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> caseClause199 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> defaultClause201 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> caseClause203 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal197_tree = default(CommonTree);
		CommonTree LT198_tree = default(CommonTree);
		CommonTree LT200_tree = default(CommonTree);
		CommonTree LT202_tree = default(CommonTree);
		CommonTree LT204_tree = default(CommonTree);
		CommonTree char_literal205_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "caseBlock");
		DebugLocation(221, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 34)) { return retval; }

			// JavaScript.g:222:2: ( '{' ! ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' !)
			DebugEnterAlt(1);
			// JavaScript.g:222:4: '{' ! ( ( LT !)* caseClause )* ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )? ( LT !)* '}' !
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(222, 7);
			char_literal197=(IToken)Match(input,110,Follow._110_in_caseBlock1619); if (state.failed) return retval;
			DebugLocation(222, 9);
			// JavaScript.g:222:9: ( ( LT !)* caseClause )*
			try { DebugEnterSubRule(97);
			while (true)
			{
				int alt97=2;
				try { DebugEnterDecision(97, false);
				try
				{
					alt97 = dfa97.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(97); }
				switch ( alt97 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:222:10: ( LT !)* caseClause
					{
					DebugLocation(222, 12);
					// JavaScript.g:222:12: ( LT !)*
					try { DebugEnterSubRule(96);
					while (true)
					{
						int alt96=2;
						try { DebugEnterDecision(96, false);
						int LA96_1 = input.LA(1);

						if ((LA96_1==LT))
						{
							alt96 = 1;
						}


						} finally { DebugExitDecision(96); }
						switch ( alt96 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:222:12: LT !
							{
							DebugLocation(222, 12);
							LT198=(IToken)Match(input,LT,Follow._LT_in_caseBlock1623); if (state.failed) return retval;

							}
							break;

						default:
							goto loop96;
						}
					}

					loop96:
						;

					} finally { DebugExitSubRule(96); }

					DebugLocation(222, 15);
					PushFollow(Follow._caseClause_in_caseBlock1627);
					caseClause199=caseClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, caseClause199.Tree);

					}
					break;

				default:
					goto loop97;
				}
			}

			loop97:
				;

			} finally { DebugExitSubRule(97); }

			DebugLocation(222, 28);
			// JavaScript.g:222:28: ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )?
			int alt101=2;
			try { DebugEnterSubRule(101);
			try { DebugEnterDecision(101, false);
			try
			{
				alt101 = dfa101.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(101); }
			switch (alt101)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:222:29: ( LT !)* defaultClause ( ( LT !)* caseClause )*
				{
				DebugLocation(222, 31);
				// JavaScript.g:222:31: ( LT !)*
				try { DebugEnterSubRule(98);
				while (true)
				{
					int alt98=2;
					try { DebugEnterDecision(98, false);
					int LA98_1 = input.LA(1);

					if ((LA98_1==LT))
					{
						alt98 = 1;
					}


					} finally { DebugExitDecision(98); }
					switch ( alt98 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:222:31: LT !
						{
						DebugLocation(222, 31);
						LT200=(IToken)Match(input,LT,Follow._LT_in_caseBlock1632); if (state.failed) return retval;

						}
						break;

					default:
						goto loop98;
					}
				}

				loop98:
					;

				} finally { DebugExitSubRule(98); }

				DebugLocation(222, 34);
				PushFollow(Follow._defaultClause_in_caseBlock1636);
				defaultClause201=defaultClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, defaultClause201.Tree);
				DebugLocation(222, 48);
				// JavaScript.g:222:48: ( ( LT !)* caseClause )*
				try { DebugEnterSubRule(100);
				while (true)
				{
					int alt100=2;
					try { DebugEnterDecision(100, false);
					try
					{
						alt100 = dfa100.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(100); }
					switch ( alt100 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:222:49: ( LT !)* caseClause
						{
						DebugLocation(222, 51);
						// JavaScript.g:222:51: ( LT !)*
						try { DebugEnterSubRule(99);
						while (true)
						{
							int alt99=2;
							try { DebugEnterDecision(99, false);
							int LA99_1 = input.LA(1);

							if ((LA99_1==LT))
							{
								alt99 = 1;
							}


							} finally { DebugExitDecision(99); }
							switch ( alt99 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:222:51: LT !
								{
								DebugLocation(222, 51);
								LT202=(IToken)Match(input,LT,Follow._LT_in_caseBlock1639); if (state.failed) return retval;

								}
								break;

							default:
								goto loop99;
							}
						}

						loop99:
							;

						} finally { DebugExitSubRule(99); }

						DebugLocation(222, 54);
						PushFollow(Follow._caseClause_in_caseBlock1643);
						caseClause203=caseClause();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) adaptor.AddChild(root_0, caseClause203.Tree);

						}
						break;

					default:
						goto loop100;
					}
				}

				loop100:
					;

				} finally { DebugExitSubRule(100); }


				}
				break;

			}
			} finally { DebugExitSubRule(101); }

			DebugLocation(222, 71);
			// JavaScript.g:222:71: ( LT !)*
			try { DebugEnterSubRule(102);
			while (true)
			{
				int alt102=2;
				try { DebugEnterDecision(102, false);
				int LA102_1 = input.LA(1);

				if ((LA102_1==LT))
				{
					alt102 = 1;
				}


				} finally { DebugExitDecision(102); }
				switch ( alt102 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:222:71: LT !
					{
					DebugLocation(222, 71);
					LT204=(IToken)Match(input,LT,Follow._LT_in_caseBlock1649); if (state.failed) return retval;

					}
					break;

				default:
					goto loop102;
				}
			}

			loop102:
				;

			} finally { DebugExitSubRule(102); }

			DebugLocation(222, 77);
			char_literal205=(IToken)Match(input,114,Follow._114_in_caseBlock1653); if (state.failed) return retval;

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseBlock", 34);
			LeaveRule("caseBlock", 34);
			LeaveRule_caseBlock();
			if (state.backtracking > 0) { Memoize(input, 34, caseBlock_StartIndex); }

		}
		DebugLocation(223, 1);
		} finally { DebugExitRule(GrammarFileName, "caseBlock"); }
		return retval;

	}
	// $ANTLR end "caseBlock"

	partial void EnterRule_caseClause();
	partial void LeaveRule_caseClause();
	// $ANTLR start "caseClause"
	// JavaScript.g:225:1: caseClause : 'case' ( LT )* expression ( LT )* ':' ( LT )* ( statementList )? -> ^( 'case' expression ( statementList )? ) ;
	[GrammarRule("caseClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> caseClause()
	{
		EnterRule_caseClause();
		EnterRule("caseClause", 35);
		TraceIn("caseClause", 35);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int caseClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal206 = default(IToken);
		IToken LT207 = default(IToken);
		IToken LT209 = default(IToken);
		IToken char_literal210 = default(IToken);
		IToken LT211 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression208 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> statementList212 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal206_tree = default(CommonTree);
		CommonTree LT207_tree = default(CommonTree);
		CommonTree LT209_tree = default(CommonTree);
		CommonTree char_literal210_tree = default(CommonTree);
		CommonTree LT211_tree = default(CommonTree);
		RewriteRuleITokenStream stream_83=new RewriteRuleITokenStream(adaptor,"token 83");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		RewriteRuleSubtreeStream stream_statementList=new RewriteRuleSubtreeStream(adaptor,"rule statementList");
		try { DebugEnterRule(GrammarFileName, "caseClause");
		DebugLocation(225, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 35)) { return retval; }

			// JavaScript.g:226:2: ( 'case' ( LT )* expression ( LT )* ':' ( LT )* ( statementList )? -> ^( 'case' expression ( statementList )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:226:4: 'case' ( LT )* expression ( LT )* ':' ( LT )* ( statementList )?
			{
			DebugLocation(226, 4);
			string_literal206=(IToken)Match(input,83,Follow._83_in_caseClause1665); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_83.Add(string_literal206);

			DebugLocation(226, 11);
			// JavaScript.g:226:11: ( LT )*
			try { DebugEnterSubRule(103);
			while (true)
			{
				int alt103=2;
				try { DebugEnterDecision(103, false);
				int LA103_1 = input.LA(1);

				if ((LA103_1==LT))
				{
					alt103 = 1;
				}


				} finally { DebugExitDecision(103); }
				switch ( alt103 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:226:11: LT
					{
					DebugLocation(226, 11);
					LT207=(IToken)Match(input,LT,Follow._LT_in_caseClause1667); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT207);


					}
					break;

				default:
					goto loop103;
				}
			}

			loop103:
				;

			} finally { DebugExitSubRule(103); }

			DebugLocation(226, 15);
			PushFollow(Follow._expression_in_caseClause1670);
			expression208=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression208.Tree);
			DebugLocation(226, 26);
			// JavaScript.g:226:26: ( LT )*
			try { DebugEnterSubRule(104);
			while (true)
			{
				int alt104=2;
				try { DebugEnterDecision(104, false);
				int LA104_1 = input.LA(1);

				if ((LA104_1==LT))
				{
					alt104 = 1;
				}


				} finally { DebugExitDecision(104); }
				switch ( alt104 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:226:26: LT
					{
					DebugLocation(226, 26);
					LT209=(IToken)Match(input,LT,Follow._LT_in_caseClause1672); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT209);


					}
					break;

				default:
					goto loop104;
				}
			}

			loop104:
				;

			} finally { DebugExitSubRule(104); }

			DebugLocation(226, 30);
			char_literal210=(IToken)Match(input,62,Follow._62_in_caseClause1675); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal210);

			DebugLocation(226, 34);
			// JavaScript.g:226:34: ( LT )*
			try { DebugEnterSubRule(105);
			while (true)
			{
				int alt105=2;
				try { DebugEnterDecision(105, false);
				int LA105_1 = input.LA(1);

				if ((LA105_1==LT))
				{
					int LA105_2 = input.LA(2);

					if ((EvaluatePredicate(synpred119_JavaScript_fragment)))
					{
						alt105 = 1;
					}


				}


				} finally { DebugExitDecision(105); }
				switch ( alt105 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:226:34: LT
					{
					DebugLocation(226, 34);
					LT211=(IToken)Match(input,LT,Follow._LT_in_caseClause1677); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT211);


					}
					break;

				default:
					goto loop105;
				}
			}

			loop105:
				;

			} finally { DebugExitSubRule(105); }

			DebugLocation(226, 38);
			// JavaScript.g:226:38: ( statementList )?
			int alt106=2;
			try { DebugEnterSubRule(106);
			try { DebugEnterDecision(106, false);
			int LA106_1 = input.LA(1);

			if ((LA106_1==Identifier||LA106_1==NumericLiteral||LA106_1==StringLiteral||LA106_1==40||LA106_1==48||(LA106_1>=52 && LA106_1<=53)||(LA106_1>=56 && LA106_1<=57)||LA106_1==63||LA106_1==78||LA106_1==82||LA106_1==85||(LA106_1>=87 && LA106_1<=88)||LA106_1==90||(LA106_1>=92 && LA106_1<=94)||(LA106_1>=97 && LA106_1<=110)||LA106_1==115))
			{
				alt106 = 1;
			}
			} finally { DebugExitDecision(106); }
			switch (alt106)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:226:38: statementList
				{
				DebugLocation(226, 38);
				PushFollow(Follow._statementList_in_caseClause1680);
				statementList212=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statementList.Add(statementList212.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(106); }



			{
			// AST REWRITE
			// elements: 83, expression, statementList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 226:53: -> ^( 'case' expression ( statementList )? )
			{
				DebugLocation(226, 56);
				// JavaScript.g:226:56: ^( 'case' expression ( statementList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(226, 58);
				root_1 = (CommonTree)adaptor.BecomeRoot(new CaseClause(stream_83.NextToken()), root_1);

				DebugLocation(226, 82);
				adaptor.AddChild(root_1, stream_expression.NextTree());
				DebugLocation(226, 93);
				// JavaScript.g:226:93: ( statementList )?
				if (stream_statementList.HasNext)
				{
					DebugLocation(226, 93);
					adaptor.AddChild(root_1, stream_statementList.NextTree());

				}
				stream_statementList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("caseClause", 35);
			LeaveRule("caseClause", 35);
			LeaveRule_caseClause();
			if (state.backtracking > 0) { Memoize(input, 35, caseClause_StartIndex); }

		}
		DebugLocation(227, 1);
		} finally { DebugExitRule(GrammarFileName, "caseClause"); }
		return retval;

	}
	// $ANTLR end "caseClause"

	partial void EnterRule_defaultClause();
	partial void LeaveRule_defaultClause();
	// $ANTLR start "defaultClause"
	// JavaScript.g:229:1: defaultClause : 'default' ( LT )* ':' ( LT )* ( statementList )? -> ^( 'default' ( statementList )? ) ;
	[GrammarRule("defaultClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> defaultClause()
	{
		EnterRule_defaultClause();
		EnterRule("defaultClause", 36);
		TraceIn("defaultClause", 36);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int defaultClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal213 = default(IToken);
		IToken LT214 = default(IToken);
		IToken char_literal215 = default(IToken);
		IToken LT216 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementList217 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal213_tree = default(CommonTree);
		CommonTree LT214_tree = default(CommonTree);
		CommonTree char_literal215_tree = default(CommonTree);
		CommonTree LT216_tree = default(CommonTree);
		RewriteRuleITokenStream stream_86=new RewriteRuleITokenStream(adaptor,"token 86");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_statementList=new RewriteRuleSubtreeStream(adaptor,"rule statementList");
		try { DebugEnterRule(GrammarFileName, "defaultClause");
		DebugLocation(229, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 36)) { return retval; }

			// JavaScript.g:230:2: ( 'default' ( LT )* ':' ( LT )* ( statementList )? -> ^( 'default' ( statementList )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:230:4: 'default' ( LT )* ':' ( LT )* ( statementList )?
			{
			DebugLocation(230, 4);
			string_literal213=(IToken)Match(input,86,Follow._86_in_defaultClause1709); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_86.Add(string_literal213);

			DebugLocation(230, 14);
			// JavaScript.g:230:14: ( LT )*
			try { DebugEnterSubRule(107);
			while (true)
			{
				int alt107=2;
				try { DebugEnterDecision(107, false);
				int LA107_1 = input.LA(1);

				if ((LA107_1==LT))
				{
					alt107 = 1;
				}


				} finally { DebugExitDecision(107); }
				switch ( alt107 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:230:14: LT
					{
					DebugLocation(230, 14);
					LT214=(IToken)Match(input,LT,Follow._LT_in_defaultClause1711); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT214);


					}
					break;

				default:
					goto loop107;
				}
			}

			loop107:
				;

			} finally { DebugExitSubRule(107); }

			DebugLocation(230, 18);
			char_literal215=(IToken)Match(input,62,Follow._62_in_defaultClause1714); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal215);

			DebugLocation(230, 22);
			// JavaScript.g:230:22: ( LT )*
			try { DebugEnterSubRule(108);
			while (true)
			{
				int alt108=2;
				try { DebugEnterDecision(108, false);
				int LA108_1 = input.LA(1);

				if ((LA108_1==LT))
				{
					int LA108_2 = input.LA(2);

					if ((EvaluatePredicate(synpred122_JavaScript_fragment)))
					{
						alt108 = 1;
					}


				}


				} finally { DebugExitDecision(108); }
				switch ( alt108 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:230:22: LT
					{
					DebugLocation(230, 22);
					LT216=(IToken)Match(input,LT,Follow._LT_in_defaultClause1716); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT216);


					}
					break;

				default:
					goto loop108;
				}
			}

			loop108:
				;

			} finally { DebugExitSubRule(108); }

			DebugLocation(230, 26);
			// JavaScript.g:230:26: ( statementList )?
			int alt109=2;
			try { DebugEnterSubRule(109);
			try { DebugEnterDecision(109, false);
			int LA109_1 = input.LA(1);

			if ((LA109_1==Identifier||LA109_1==NumericLiteral||LA109_1==StringLiteral||LA109_1==40||LA109_1==48||(LA109_1>=52 && LA109_1<=53)||(LA109_1>=56 && LA109_1<=57)||LA109_1==63||LA109_1==78||LA109_1==82||LA109_1==85||(LA109_1>=87 && LA109_1<=88)||LA109_1==90||(LA109_1>=92 && LA109_1<=94)||(LA109_1>=97 && LA109_1<=110)||LA109_1==115))
			{
				alt109 = 1;
			}
			} finally { DebugExitDecision(109); }
			switch (alt109)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:230:26: statementList
				{
				DebugLocation(230, 26);
				PushFollow(Follow._statementList_in_defaultClause1719);
				statementList217=statementList();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_statementList.Add(statementList217.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(109); }



			{
			// AST REWRITE
			// elements: 86, statementList
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 230:41: -> ^( 'default' ( statementList )? )
			{
				DebugLocation(230, 44);
				// JavaScript.g:230:44: ^( 'default' ( statementList )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(230, 46);
				root_1 = (CommonTree)adaptor.BecomeRoot(new DefaultCaseClause(stream_86.NextToken()), root_1);

				DebugLocation(230, 80);
				// JavaScript.g:230:80: ( statementList )?
				if (stream_statementList.HasNext)
				{
					DebugLocation(230, 80);
					adaptor.AddChild(root_1, stream_statementList.NextTree());

				}
				stream_statementList.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("defaultClause", 36);
			LeaveRule("defaultClause", 36);
			LeaveRule_defaultClause();
			if (state.backtracking > 0) { Memoize(input, 36, defaultClause_StartIndex); }

		}
		DebugLocation(231, 1);
		} finally { DebugExitRule(GrammarFileName, "defaultClause"); }
		return retval;

	}
	// $ANTLR end "defaultClause"

	partial void EnterRule_throwStatement();
	partial void LeaveRule_throwStatement();
	// $ANTLR start "throwStatement"
	// JavaScript.g:233:1: throwStatement : 'throw' expression ( LT | ';' ) -> ^( 'throw' expression ) ;
	[GrammarRule("throwStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> throwStatement()
	{
		EnterRule_throwStatement();
		EnterRule("throwStatement", 37);
		TraceIn("throwStatement", 37);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int throwStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal218 = default(IToken);
		IToken LT220 = default(IToken);
		IToken char_literal221 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression219 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal218_tree = default(CommonTree);
		CommonTree LT220_tree = default(CommonTree);
		CommonTree char_literal221_tree = default(CommonTree);
		RewriteRuleITokenStream stream_102=new RewriteRuleITokenStream(adaptor,"token 102");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_63=new RewriteRuleITokenStream(adaptor,"token 63");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "throwStatement");
		DebugLocation(233, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 37)) { return retval; }

			// JavaScript.g:234:2: ( 'throw' expression ( LT | ';' ) -> ^( 'throw' expression ) )
			DebugEnterAlt(1);
			// JavaScript.g:234:4: 'throw' expression ( LT | ';' )
			{
			DebugLocation(234, 4);
			string_literal218=(IToken)Match(input,102,Follow._102_in_throwStatement1746); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_102.Add(string_literal218);

			DebugLocation(234, 12);
			PushFollow(Follow._expression_in_throwStatement1748);
			expression219=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression219.Tree);
			DebugLocation(234, 23);
			// JavaScript.g:234:23: ( LT | ';' )
			int alt110=2;
			try { DebugEnterSubRule(110);
			try { DebugEnterDecision(110, false);
			int LA110_1 = input.LA(1);

			if ((LA110_1==LT))
			{
				alt110 = 1;
			}
			else if ((LA110_1==63))
			{
				alt110 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 110, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(110); }
			switch (alt110)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:234:24: LT
				{
				DebugLocation(234, 24);
				LT220=(IToken)Match(input,LT,Follow._LT_in_throwStatement1751); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LT.Add(LT220);


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:234:29: ';'
				{
				DebugLocation(234, 29);
				char_literal221=(IToken)Match(input,63,Follow._63_in_throwStatement1755); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_63.Add(char_literal221);


				}
				break;

			}
			} finally { DebugExitSubRule(110); }



			{
			// AST REWRITE
			// elements: 102, expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 234:34: -> ^( 'throw' expression )
			{
				DebugLocation(234, 37);
				// JavaScript.g:234:37: ^( 'throw' expression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(234, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ThrowStatement(stream_102.NextToken()), root_1);

				DebugLocation(234, 68);
				adaptor.AddChild(root_1, stream_expression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("throwStatement", 37);
			LeaveRule("throwStatement", 37);
			LeaveRule_throwStatement();
			if (state.backtracking > 0) { Memoize(input, 37, throwStatement_StartIndex); }

		}
		DebugLocation(235, 1);
		} finally { DebugExitRule(GrammarFileName, "throwStatement"); }
		return retval;

	}
	// $ANTLR end "throwStatement"

	partial void EnterRule_tryStatement();
	partial void LeaveRule_tryStatement();
	// $ANTLR start "tryStatement"
	// JavaScript.g:237:1: tryStatement : 'try' ( LT )* statementBlock ( LT )* ( finallyClause | catchClause ( ( LT )* finallyClause )? ) -> ^( 'try' statementBlock ( catchClause )? ( finallyClause )? ) ;
	[GrammarRule("tryStatement")]
	private AstParserRuleReturnScope<CommonTree, IToken> tryStatement()
	{
		EnterRule_tryStatement();
		EnterRule("tryStatement", 38);
		TraceIn("tryStatement", 38);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int tryStatement_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal222 = default(IToken);
		IToken LT223 = default(IToken);
		IToken LT225 = default(IToken);
		IToken LT228 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementBlock224 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> finallyClause226 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> catchClause227 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> finallyClause229 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal222_tree = default(CommonTree);
		CommonTree LT223_tree = default(CommonTree);
		CommonTree LT225_tree = default(CommonTree);
		CommonTree LT228_tree = default(CommonTree);
		RewriteRuleITokenStream stream_104=new RewriteRuleITokenStream(adaptor,"token 104");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_statementBlock=new RewriteRuleSubtreeStream(adaptor,"rule statementBlock");
		RewriteRuleSubtreeStream stream_finallyClause=new RewriteRuleSubtreeStream(adaptor,"rule finallyClause");
		RewriteRuleSubtreeStream stream_catchClause=new RewriteRuleSubtreeStream(adaptor,"rule catchClause");
		try { DebugEnterRule(GrammarFileName, "tryStatement");
		DebugLocation(237, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 38)) { return retval; }

			// JavaScript.g:238:2: ( 'try' ( LT )* statementBlock ( LT )* ( finallyClause | catchClause ( ( LT )* finallyClause )? ) -> ^( 'try' statementBlock ( catchClause )? ( finallyClause )? ) )
			DebugEnterAlt(1);
			// JavaScript.g:238:4: 'try' ( LT )* statementBlock ( LT )* ( finallyClause | catchClause ( ( LT )* finallyClause )? )
			{
			DebugLocation(238, 4);
			string_literal222=(IToken)Match(input,104,Follow._104_in_tryStatement1780); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_104.Add(string_literal222);

			DebugLocation(238, 10);
			// JavaScript.g:238:10: ( LT )*
			try { DebugEnterSubRule(111);
			while (true)
			{
				int alt111=2;
				try { DebugEnterDecision(111, false);
				int LA111_1 = input.LA(1);

				if ((LA111_1==LT))
				{
					alt111 = 1;
				}


				} finally { DebugExitDecision(111); }
				switch ( alt111 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:238:10: LT
					{
					DebugLocation(238, 10);
					LT223=(IToken)Match(input,LT,Follow._LT_in_tryStatement1782); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT223);


					}
					break;

				default:
					goto loop111;
				}
			}

			loop111:
				;

			} finally { DebugExitSubRule(111); }

			DebugLocation(238, 14);
			PushFollow(Follow._statementBlock_in_tryStatement1785);
			statementBlock224=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statementBlock.Add(statementBlock224.Tree);
			DebugLocation(238, 29);
			// JavaScript.g:238:29: ( LT )*
			try { DebugEnterSubRule(112);
			while (true)
			{
				int alt112=2;
				try { DebugEnterDecision(112, false);
				int LA112_1 = input.LA(1);

				if ((LA112_1==LT))
				{
					alt112 = 1;
				}


				} finally { DebugExitDecision(112); }
				switch ( alt112 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:238:29: LT
					{
					DebugLocation(238, 29);
					LT225=(IToken)Match(input,LT,Follow._LT_in_tryStatement1787); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT225);


					}
					break;

				default:
					goto loop112;
				}
			}

			loop112:
				;

			} finally { DebugExitSubRule(112); }

			DebugLocation(238, 33);
			// JavaScript.g:238:33: ( finallyClause | catchClause ( ( LT )* finallyClause )? )
			int alt115=2;
			try { DebugEnterSubRule(115);
			try { DebugEnterDecision(115, false);
			int LA115_1 = input.LA(1);

			if ((LA115_1==91))
			{
				alt115 = 1;
			}
			else if ((LA115_1==84))
			{
				alt115 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 115, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(115); }
			switch (alt115)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:238:34: finallyClause
				{
				DebugLocation(238, 34);
				PushFollow(Follow._finallyClause_in_tryStatement1791);
				finallyClause226=finallyClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_finallyClause.Add(finallyClause226.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:238:50: catchClause ( ( LT )* finallyClause )?
				{
				DebugLocation(238, 50);
				PushFollow(Follow._catchClause_in_tryStatement1795);
				catchClause227=catchClause();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_catchClause.Add(catchClause227.Tree);
				DebugLocation(238, 62);
				// JavaScript.g:238:62: ( ( LT )* finallyClause )?
				int alt114=2;
				try { DebugEnterSubRule(114);
				try { DebugEnterDecision(114, false);
				try
				{
					alt114 = dfa114.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(114); }
				switch (alt114)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:238:63: ( LT )* finallyClause
					{
					DebugLocation(238, 63);
					// JavaScript.g:238:63: ( LT )*
					try { DebugEnterSubRule(113);
					while (true)
					{
						int alt113=2;
						try { DebugEnterDecision(113, false);
						int LA113_1 = input.LA(1);

						if ((LA113_1==LT))
						{
							alt113 = 1;
						}


						} finally { DebugExitDecision(113); }
						switch ( alt113 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:238:63: LT
							{
							DebugLocation(238, 63);
							LT228=(IToken)Match(input,LT,Follow._LT_in_tryStatement1798); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT228);


							}
							break;

						default:
							goto loop113;
						}
					}

					loop113:
						;

					} finally { DebugExitSubRule(113); }

					DebugLocation(238, 67);
					PushFollow(Follow._finallyClause_in_tryStatement1801);
					finallyClause229=finallyClause();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_finallyClause.Add(finallyClause229.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(114); }


				}
				break;

			}
			} finally { DebugExitSubRule(115); }



			{
			// AST REWRITE
			// elements: 104, statementBlock, catchClause, finallyClause
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 239:3: -> ^( 'try' statementBlock ( catchClause )? ( finallyClause )? )
			{
				DebugLocation(239, 6);
				// JavaScript.g:239:6: ^( 'try' statementBlock ( catchClause )? ( finallyClause )? )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(239, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new TryStatement(stream_104.NextToken()), root_1);

				DebugLocation(239, 33);
				adaptor.AddChild(root_1, stream_statementBlock.NextTree());
				DebugLocation(239, 48);
				// JavaScript.g:239:48: ( catchClause )?
				if (stream_catchClause.HasNext)
				{
					DebugLocation(239, 48);
					adaptor.AddChild(root_1, stream_catchClause.NextTree());

				}
				stream_catchClause.Reset();
				DebugLocation(239, 61);
				// JavaScript.g:239:61: ( finallyClause )?
				if (stream_finallyClause.HasNext)
				{
					DebugLocation(239, 61);
					adaptor.AddChild(root_1, stream_finallyClause.NextTree());

				}
				stream_finallyClause.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("tryStatement", 38);
			LeaveRule("tryStatement", 38);
			LeaveRule_tryStatement();
			if (state.backtracking > 0) { Memoize(input, 38, tryStatement_StartIndex); }

		}
		DebugLocation(240, 1);
		} finally { DebugExitRule(GrammarFileName, "tryStatement"); }
		return retval;

	}
	// $ANTLR end "tryStatement"

	partial void EnterRule_catchClause();
	partial void LeaveRule_catchClause();
	// $ANTLR start "catchClause"
	// JavaScript.g:242:1: catchClause : 'catch' ( LT )* '(' ( LT )* Identifier ( LT )* ')' ( LT )* statementBlock -> ^( 'catch' Identifier statementBlock ) ;
	[GrammarRule("catchClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> catchClause()
	{
		EnterRule_catchClause();
		EnterRule("catchClause", 39);
		TraceIn("catchClause", 39);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int catchClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal230 = default(IToken);
		IToken LT231 = default(IToken);
		IToken char_literal232 = default(IToken);
		IToken LT233 = default(IToken);
		IToken Identifier234 = default(IToken);
		IToken LT235 = default(IToken);
		IToken char_literal236 = default(IToken);
		IToken LT237 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementBlock238 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal230_tree = default(CommonTree);
		CommonTree LT231_tree = default(CommonTree);
		CommonTree char_literal232_tree = default(CommonTree);
		CommonTree LT233_tree = default(CommonTree);
		CommonTree Identifier234_tree = default(CommonTree);
		CommonTree LT235_tree = default(CommonTree);
		CommonTree char_literal236_tree = default(CommonTree);
		CommonTree LT237_tree = default(CommonTree);
		RewriteRuleITokenStream stream_84=new RewriteRuleITokenStream(adaptor,"token 84");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_statementBlock=new RewriteRuleSubtreeStream(adaptor,"rule statementBlock");
		try { DebugEnterRule(GrammarFileName, "catchClause");
		DebugLocation(242, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 39)) { return retval; }

			// JavaScript.g:243:2: ( 'catch' ( LT )* '(' ( LT )* Identifier ( LT )* ')' ( LT )* statementBlock -> ^( 'catch' Identifier statementBlock ) )
			DebugEnterAlt(1);
			// JavaScript.g:243:4: 'catch' ( LT )* '(' ( LT )* Identifier ( LT )* ')' ( LT )* statementBlock
			{
			DebugLocation(243, 4);
			string_literal230=(IToken)Match(input,84,Follow._84_in_catchClause1843); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_84.Add(string_literal230);

			DebugLocation(243, 12);
			// JavaScript.g:243:12: ( LT )*
			try { DebugEnterSubRule(116);
			while (true)
			{
				int alt116=2;
				try { DebugEnterDecision(116, false);
				int LA116_1 = input.LA(1);

				if ((LA116_1==LT))
				{
					alt116 = 1;
				}


				} finally { DebugExitDecision(116); }
				switch ( alt116 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:12: LT
					{
					DebugLocation(243, 12);
					LT231=(IToken)Match(input,LT,Follow._LT_in_catchClause1845); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT231);


					}
					break;

				default:
					goto loop116;
				}
			}

			loop116:
				;

			} finally { DebugExitSubRule(116); }

			DebugLocation(243, 16);
			char_literal232=(IToken)Match(input,48,Follow._48_in_catchClause1848); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal232);

			DebugLocation(243, 20);
			// JavaScript.g:243:20: ( LT )*
			try { DebugEnterSubRule(117);
			while (true)
			{
				int alt117=2;
				try { DebugEnterDecision(117, false);
				int LA117_1 = input.LA(1);

				if ((LA117_1==LT))
				{
					alt117 = 1;
				}


				} finally { DebugExitDecision(117); }
				switch ( alt117 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:20: LT
					{
					DebugLocation(243, 20);
					LT233=(IToken)Match(input,LT,Follow._LT_in_catchClause1850); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT233);


					}
					break;

				default:
					goto loop117;
				}
			}

			loop117:
				;

			} finally { DebugExitSubRule(117); }

			DebugLocation(243, 24);
			Identifier234=(IToken)Match(input,Identifier,Follow._Identifier_in_catchClause1853); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier234);

			DebugLocation(243, 35);
			// JavaScript.g:243:35: ( LT )*
			try { DebugEnterSubRule(118);
			while (true)
			{
				int alt118=2;
				try { DebugEnterDecision(118, false);
				int LA118_1 = input.LA(1);

				if ((LA118_1==LT))
				{
					alt118 = 1;
				}


				} finally { DebugExitDecision(118); }
				switch ( alt118 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:35: LT
					{
					DebugLocation(243, 35);
					LT235=(IToken)Match(input,LT,Follow._LT_in_catchClause1855); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT235);


					}
					break;

				default:
					goto loop118;
				}
			}

			loop118:
				;

			} finally { DebugExitSubRule(118); }

			DebugLocation(243, 39);
			char_literal236=(IToken)Match(input,49,Follow._49_in_catchClause1858); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal236);

			DebugLocation(243, 43);
			// JavaScript.g:243:43: ( LT )*
			try { DebugEnterSubRule(119);
			while (true)
			{
				int alt119=2;
				try { DebugEnterDecision(119, false);
				int LA119_1 = input.LA(1);

				if ((LA119_1==LT))
				{
					alt119 = 1;
				}


				} finally { DebugExitDecision(119); }
				switch ( alt119 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:243:43: LT
					{
					DebugLocation(243, 43);
					LT237=(IToken)Match(input,LT,Follow._LT_in_catchClause1860); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT237);


					}
					break;

				default:
					goto loop119;
				}
			}

			loop119:
				;

			} finally { DebugExitSubRule(119); }

			DebugLocation(243, 47);
			PushFollow(Follow._statementBlock_in_catchClause1863);
			statementBlock238=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statementBlock.Add(statementBlock238.Tree);


			{
			// AST REWRITE
			// elements: 84, Identifier, statementBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 244:3: -> ^( 'catch' Identifier statementBlock )
			{
				DebugLocation(244, 6);
				// JavaScript.g:244:6: ^( 'catch' Identifier statementBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(244, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new CatchClause(stream_84.NextToken()), root_1);

				DebugLocation(244, 34);
				adaptor.AddChild(root_1, new Identifier(stream_Identifier.NextToken()));
				DebugLocation(244, 62);
				adaptor.AddChild(root_1, stream_statementBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("catchClause", 39);
			LeaveRule("catchClause", 39);
			LeaveRule_catchClause();
			if (state.backtracking > 0) { Memoize(input, 39, catchClause_StartIndex); }

		}
		DebugLocation(245, 1);
		} finally { DebugExitRule(GrammarFileName, "catchClause"); }
		return retval;

	}
	// $ANTLR end "catchClause"

	partial void EnterRule_finallyClause();
	partial void LeaveRule_finallyClause();
	// $ANTLR start "finallyClause"
	// JavaScript.g:247:1: finallyClause : 'finally' ( LT )* statementBlock -> ^( 'finally' statementBlock ) ;
	[GrammarRule("finallyClause")]
	private AstParserRuleReturnScope<CommonTree, IToken> finallyClause()
	{
		EnterRule_finallyClause();
		EnterRule("finallyClause", 40);
		TraceIn("finallyClause", 40);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int finallyClause_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal239 = default(IToken);
		IToken LT240 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> statementBlock241 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal239_tree = default(CommonTree);
		CommonTree LT240_tree = default(CommonTree);
		RewriteRuleITokenStream stream_91=new RewriteRuleITokenStream(adaptor,"token 91");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_statementBlock=new RewriteRuleSubtreeStream(adaptor,"rule statementBlock");
		try { DebugEnterRule(GrammarFileName, "finallyClause");
		DebugLocation(247, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 40)) { return retval; }

			// JavaScript.g:248:2: ( 'finally' ( LT )* statementBlock -> ^( 'finally' statementBlock ) )
			DebugEnterAlt(1);
			// JavaScript.g:248:4: 'finally' ( LT )* statementBlock
			{
			DebugLocation(248, 4);
			string_literal239=(IToken)Match(input,91,Follow._91_in_finallyClause1897); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_91.Add(string_literal239);

			DebugLocation(248, 14);
			// JavaScript.g:248:14: ( LT )*
			try { DebugEnterSubRule(120);
			while (true)
			{
				int alt120=2;
				try { DebugEnterDecision(120, false);
				int LA120_1 = input.LA(1);

				if ((LA120_1==LT))
				{
					alt120 = 1;
				}


				} finally { DebugExitDecision(120); }
				switch ( alt120 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:248:14: LT
					{
					DebugLocation(248, 14);
					LT240=(IToken)Match(input,LT,Follow._LT_in_finallyClause1899); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT240);


					}
					break;

				default:
					goto loop120;
				}
			}

			loop120:
				;

			} finally { DebugExitSubRule(120); }

			DebugLocation(248, 18);
			PushFollow(Follow._statementBlock_in_finallyClause1902);
			statementBlock241=statementBlock();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_statementBlock.Add(statementBlock241.Tree);


			{
			// AST REWRITE
			// elements: 91, statementBlock
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 248:33: -> ^( 'finally' statementBlock )
			{
				DebugLocation(248, 36);
				// JavaScript.g:248:36: ^( 'finally' statementBlock )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(248, 38);
				root_1 = (CommonTree)adaptor.BecomeRoot(new FinallyClause(stream_91.NextToken()), root_1);

				DebugLocation(248, 68);
				adaptor.AddChild(root_1, stream_statementBlock.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("finallyClause", 40);
			LeaveRule("finallyClause", 40);
			LeaveRule_finallyClause();
			if (state.backtracking > 0) { Memoize(input, 40, finallyClause_StartIndex); }

		}
		DebugLocation(249, 1);
		} finally { DebugExitRule(GrammarFileName, "finallyClause"); }
		return retval;

	}
	// $ANTLR end "finallyClause"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();
	// $ANTLR start "expression"
	// JavaScript.g:252:1: expression : assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* -> ( assignmentExpression )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<CommonTree, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 41);
		TraceIn("expression", 41);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT243 = default(IToken);
		IToken char_literal244 = default(IToken);
		IToken LT245 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression242 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression246 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT243_tree = default(CommonTree);
		CommonTree char_literal244_tree = default(CommonTree);
		CommonTree LT245_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(252, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 41)) { return retval; }

			// JavaScript.g:253:2: ( assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* -> ( assignmentExpression )* )
			DebugEnterAlt(1);
			// JavaScript.g:253:4: assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )*
			{
			DebugLocation(253, 4);
			PushFollow(Follow._assignmentExpression_in_expression1927);
			assignmentExpression242=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression242.Tree);
			DebugLocation(253, 25);
			// JavaScript.g:253:25: ( ( LT )* ',' ( LT )* assignmentExpression )*
			try { DebugEnterSubRule(123);
			while (true)
			{
				int alt123=2;
				try { DebugEnterDecision(123, false);
				try
				{
					alt123 = dfa123.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(123); }
				switch ( alt123 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:253:26: ( LT )* ',' ( LT )* assignmentExpression
					{
					DebugLocation(253, 26);
					// JavaScript.g:253:26: ( LT )*
					try { DebugEnterSubRule(121);
					while (true)
					{
						int alt121=2;
						try { DebugEnterDecision(121, false);
						int LA121_1 = input.LA(1);

						if ((LA121_1==LT))
						{
							alt121 = 1;
						}


						} finally { DebugExitDecision(121); }
						switch ( alt121 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:253:26: LT
							{
							DebugLocation(253, 26);
							LT243=(IToken)Match(input,LT,Follow._LT_in_expression1930); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT243);


							}
							break;

						default:
							goto loop121;
						}
					}

					loop121:
						;

					} finally { DebugExitSubRule(121); }

					DebugLocation(253, 30);
					char_literal244=(IToken)Match(input,55,Follow._55_in_expression1933); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal244);

					DebugLocation(253, 34);
					// JavaScript.g:253:34: ( LT )*
					try { DebugEnterSubRule(122);
					while (true)
					{
						int alt122=2;
						try { DebugEnterDecision(122, false);
						int LA122_1 = input.LA(1);

						if ((LA122_1==LT))
						{
							alt122 = 1;
						}


						} finally { DebugExitDecision(122); }
						switch ( alt122 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:253:34: LT
							{
							DebugLocation(253, 34);
							LT245=(IToken)Match(input,LT,Follow._LT_in_expression1935); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT245);


							}
							break;

						default:
							goto loop122;
						}
					}

					loop122:
						;

					} finally { DebugExitSubRule(122); }

					DebugLocation(253, 38);
					PushFollow(Follow._assignmentExpression_in_expression1938);
					assignmentExpression246=assignmentExpression();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression246.Tree);

					}
					break;

				default:
					goto loop123;
				}
			}

			loop123:
				;

			} finally { DebugExitSubRule(123); }



			{
			// AST REWRITE
			// elements: assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 253:61: -> ( assignmentExpression )*
			{
				DebugLocation(253, 64);
				// JavaScript.g:253:64: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(253, 64);
					adaptor.AddChild(root_0, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 41);
			LeaveRule("expression", 41);
			LeaveRule_expression();
			if (state.backtracking > 0) { Memoize(input, 41, expression_StartIndex); }

		}
		DebugLocation(254, 1);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_expressionNoIn();
	partial void LeaveRule_expressionNoIn();
	// $ANTLR start "expressionNoIn"
	// JavaScript.g:256:1: expressionNoIn : assignmentExpressionNoIn ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )* -> ( assignmentExpressionNoIn )* ;
	[GrammarRule("expressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> expressionNoIn()
	{
		EnterRule_expressionNoIn();
		EnterRule("expressionNoIn", 42);
		TraceIn("expressionNoIn", 42);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int expressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT248 = default(IToken);
		IToken char_literal249 = default(IToken);
		IToken LT250 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn247 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn251 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT248_tree = default(CommonTree);
		CommonTree char_literal249_tree = default(CommonTree);
		CommonTree LT250_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "expressionNoIn");
		DebugLocation(256, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 42)) { return retval; }

			// JavaScript.g:257:2: ( assignmentExpressionNoIn ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )* -> ( assignmentExpressionNoIn )* )
			DebugEnterAlt(1);
			// JavaScript.g:257:4: assignmentExpressionNoIn ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )*
			{
			DebugLocation(257, 4);
			PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn1957);
			assignmentExpressionNoIn247=assignmentExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(assignmentExpressionNoIn247.Tree);
			DebugLocation(257, 29);
			// JavaScript.g:257:29: ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )*
			try { DebugEnterSubRule(126);
			while (true)
			{
				int alt126=2;
				try { DebugEnterDecision(126, false);
				try
				{
					alt126 = dfa126.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(126); }
				switch ( alt126 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:257:30: ( LT )* ',' ( LT )* assignmentExpressionNoIn
					{
					DebugLocation(257, 30);
					// JavaScript.g:257:30: ( LT )*
					try { DebugEnterSubRule(124);
					while (true)
					{
						int alt124=2;
						try { DebugEnterDecision(124, false);
						int LA124_1 = input.LA(1);

						if ((LA124_1==LT))
						{
							alt124 = 1;
						}


						} finally { DebugExitDecision(124); }
						switch ( alt124 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:257:30: LT
							{
							DebugLocation(257, 30);
							LT248=(IToken)Match(input,LT,Follow._LT_in_expressionNoIn1960); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT248);


							}
							break;

						default:
							goto loop124;
						}
					}

					loop124:
						;

					} finally { DebugExitSubRule(124); }

					DebugLocation(257, 34);
					char_literal249=(IToken)Match(input,55,Follow._55_in_expressionNoIn1963); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal249);

					DebugLocation(257, 38);
					// JavaScript.g:257:38: ( LT )*
					try { DebugEnterSubRule(125);
					while (true)
					{
						int alt125=2;
						try { DebugEnterDecision(125, false);
						int LA125_1 = input.LA(1);

						if ((LA125_1==LT))
						{
							alt125 = 1;
						}


						} finally { DebugExitDecision(125); }
						switch ( alt125 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:257:38: LT
							{
							DebugLocation(257, 38);
							LT250=(IToken)Match(input,LT,Follow._LT_in_expressionNoIn1965); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT250);


							}
							break;

						default:
							goto loop125;
						}
					}

					loop125:
						;

					} finally { DebugExitSubRule(125); }

					DebugLocation(257, 42);
					PushFollow(Follow._assignmentExpressionNoIn_in_expressionNoIn1968);
					assignmentExpressionNoIn251=assignmentExpressionNoIn();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(assignmentExpressionNoIn251.Tree);

					}
					break;

				default:
					goto loop126;
				}
			}

			loop126:
				;

			} finally { DebugExitSubRule(126); }



			{
			// AST REWRITE
			// elements: assignmentExpressionNoIn
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 257:69: -> ( assignmentExpressionNoIn )*
			{
				DebugLocation(257, 72);
				// JavaScript.g:257:72: ( assignmentExpressionNoIn )*
				while ( stream_assignmentExpressionNoIn.HasNext )
				{
					DebugLocation(257, 72);
					adaptor.AddChild(root_0, stream_assignmentExpressionNoIn.NextTree());

				}
				stream_assignmentExpressionNoIn.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expressionNoIn", 42);
			LeaveRule("expressionNoIn", 42);
			LeaveRule_expressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 42, expressionNoIn_StartIndex); }

		}
		DebugLocation(258, 1);
		} finally { DebugExitRule(GrammarFileName, "expressionNoIn"); }
		return retval;

	}
	// $ANTLR end "expressionNoIn"

	partial void EnterRule_assignmentExpression();
	partial void LeaveRule_assignmentExpression();
	// $ANTLR start "assignmentExpression"
	// JavaScript.g:260:1: assignmentExpression : ( conditionalExpression -> conditionalExpression |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpression -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->);
	[GrammarRule("assignmentExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression()
	{
		EnterRule_assignmentExpression();
		EnterRule("assignmentExpression", 43);
		TraceIn("assignmentExpression", 43);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT253 = default(IToken);
		IToken LT254 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> op = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> rh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionalExpression252 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT253_tree = default(CommonTree);
		CommonTree LT254_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_conditionalExpression=new RewriteRuleSubtreeStream(adaptor,"rule conditionalExpression");
		RewriteRuleSubtreeStream stream_leftHandSideExpression=new RewriteRuleSubtreeStream(adaptor,"rule leftHandSideExpression");
		RewriteRuleSubtreeStream stream_assignmentOperator=new RewriteRuleSubtreeStream(adaptor,"rule assignmentOperator");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "assignmentExpression");
		DebugLocation(260, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 43)) { return retval; }

			// JavaScript.g:261:2: ( conditionalExpression -> conditionalExpression |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpression -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->)
			int alt129=2;
			try { DebugEnterDecision(129, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 98:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 103:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 90:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case StringLiteral:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 78:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 110:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 48:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 93:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				int LA129_2 = input.LA(2);

				if ((EvaluatePredicate(synpred141_JavaScript_fragment)))
				{
					alt129 = 1;
				}
				else if ((true))
				{
					alt129 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 40:
			case 52:
			case 53:
			case 56:
			case 57:
			case 87:
			case 105:
			case 107:
			case 115:
				{
				alt129 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 129, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(129); }
			switch (alt129)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:261:4: conditionalExpression
				{
				DebugLocation(261, 4);
				PushFollow(Follow._conditionalExpression_in_assignmentExpression1987);
				conditionalExpression252=conditionalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionalExpression.Add(conditionalExpression252.Tree);


				{
				// AST REWRITE
				// elements: conditionalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 261:26: -> conditionalExpression
				{
					DebugLocation(261, 29);
					adaptor.AddChild(root_0, stream_conditionalExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:262:4: lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpression
				{
				DebugLocation(262, 6);
				PushFollow(Follow._leftHandSideExpression_in_assignmentExpression1998);
				lh=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_leftHandSideExpression.Add(lh.Tree);
				DebugLocation(262, 30);
				// JavaScript.g:262:30: ( LT )*
				try { DebugEnterSubRule(127);
				while (true)
				{
					int alt127=2;
					try { DebugEnterDecision(127, false);
					int LA127_1 = input.LA(1);

					if ((LA127_1==LT))
					{
						alt127 = 1;
					}


					} finally { DebugExitDecision(127); }
					switch ( alt127 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:262:30: LT
						{
						DebugLocation(262, 30);
						LT253=(IToken)Match(input,LT,Follow._LT_in_assignmentExpression2000); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT253);


						}
						break;

					default:
						goto loop127;
					}
				}

				loop127:
					;

				} finally { DebugExitSubRule(127); }

				DebugLocation(262, 36);
				PushFollow(Follow._assignmentOperator_in_assignmentExpression2005);
				op=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentOperator.Add(op.Tree);
				DebugLocation(262, 56);
				// JavaScript.g:262:56: ( LT )*
				try { DebugEnterSubRule(128);
				while (true)
				{
					int alt128=2;
					try { DebugEnterDecision(128, false);
					int LA128_1 = input.LA(1);

					if ((LA128_1==LT))
					{
						alt128 = 1;
					}


					} finally { DebugExitDecision(128); }
					switch ( alt128 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:262:56: LT
						{
						DebugLocation(262, 56);
						LT254=(IToken)Match(input,LT,Follow._LT_in_assignmentExpression2007); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT254);


						}
						break;

					default:
						goto loop128;
					}
				}

				loop128:
					;

				} finally { DebugExitSubRule(128); }

				DebugLocation(262, 62);
				PushFollow(Follow._assignmentExpression_in_assignmentExpression2012);
				rh=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(rh.Tree);


				{
				// AST REWRITE
				// elements: 68, lh, rh, 51, lh, rh, 61, lh, rh, 44, lh, rh, 54, lh, rh, 58, lh, rh, 66, lh, rh, 74, lh, rh, 76, lh, rh, 47, lh, rh, 81, lh, rh, 112, lh, rh
				// token labels: 
				// rule labels: lh, rh, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_lh=new RewriteRuleSubtreeStream(adaptor,"rule lh",lh!=null?lh.Tree:null);
				RewriteRuleSubtreeStream stream_rh=new RewriteRuleSubtreeStream(adaptor,"rule rh",rh!=null?rh.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 263:9: -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh)
				if (op.Tree.Text == "="    )
				{
					DebugLocation(263, 39);
					// JavaScript.g:263:39: ^( '=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(263, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AssignExpression(68), root_1);

					DebugLocation(263, 69);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(263, 73);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 264:9: -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh)
				if (op.Tree.Text == "*="   )
				{
					DebugLocation(264, 39);
					// JavaScript.g:264:39: ^( '*=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(264, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new MultiplyAndAssignExpression(51), root_1);

					DebugLocation(264, 81);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(264, 85);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 265:3: -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh)
				if (op.Tree.Text == "/="   )
				{
					DebugLocation(265, 33);
					// JavaScript.g:265:33: ^( '/=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(265, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DivideAndAssignExpression(61), root_1);

					DebugLocation(265, 73);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(265, 77);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 266:3: -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh)
				if (op.Tree.Text == "%="  )
				{
					DebugLocation(266, 33);
					// JavaScript.g:266:33: ^( '%=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(266, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ModulusAndAssignExpression(44), root_1);

					DebugLocation(266, 74);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(266, 78);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 267:3: -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh)
				if (op.Tree.Text == "+="   )
				{
					DebugLocation(267, 33);
					// JavaScript.g:267:33: ^( '+=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(267, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AddAndAssignExpression(54), root_1);

					DebugLocation(267, 70);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(267, 74);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 268:3: -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh)
				if (op.Tree.Text == "-="   )
				{
					DebugLocation(268, 33);
					// JavaScript.g:268:33: ^( '-=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(268, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new SubtractAndAssignExpression(58), root_1);

					DebugLocation(268, 75);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(268, 79);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 269:3: -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh)
				if (op.Tree.Text == "<<="  )
				{
					DebugLocation(269, 33);
					// JavaScript.g:269:33: ^( '<<=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(269, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftLeftAndAssignExpression(66), root_1);

					DebugLocation(269, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(269, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 270:3: -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh)
				if (op.Tree.Text == ">>="  )
				{
					DebugLocation(270, 33);
					// JavaScript.g:270:33: ^( '>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(270, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftRightAndAssignExpression(74), root_1);

					DebugLocation(270, 78);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(270, 82);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 271:3: -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh)
				if (op.Tree.Text == ">>>=" )
				{
					DebugLocation(271, 33);
					// JavaScript.g:271:33: ^( '>>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(271, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new RotateRightAndAssignExpression(76), root_1);

					DebugLocation(271, 80);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(271, 84);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 272:3: -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh)
				if (op.Tree.Text == "&="   )
				{
					DebugLocation(272, 33);
					// JavaScript.g:272:33: ^( '&=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(272, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndAndAssignExpression(47), root_1);

					DebugLocation(272, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(272, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 273:3: -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh)
				if (op.Tree.Text == "^="   )
				{
					DebugLocation(273, 33);
					// JavaScript.g:273:33: ^( '^=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(273, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorAndAssignExpression(81), root_1);

					DebugLocation(273, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(273, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 274:3: -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh)
				if (op.Tree.Text == "|="   )
				{
					DebugLocation(274, 33);
					// JavaScript.g:274:33: ^( '|=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(274, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrAndAssignExpression(112), root_1);

					DebugLocation(274, 76);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(274, 80);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 275:9: ->
				{
					DebugLocation(276, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpression", 43);
			LeaveRule("assignmentExpression", 43);
			LeaveRule_assignmentExpression();
			if (state.backtracking > 0) { Memoize(input, 43, assignmentExpression_StartIndex); }

		}
		DebugLocation(276, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpression"); }
		return retval;

	}
	// $ANTLR end "assignmentExpression"

	partial void EnterRule_assignmentExpressionNoIn();
	partial void LeaveRule_assignmentExpressionNoIn();
	// $ANTLR start "assignmentExpressionNoIn"
	// JavaScript.g:278:1: assignmentExpressionNoIn : ( conditionalExpressionNoIn -> conditionalExpressionNoIn |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpressionNoIn -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->);
	[GrammarRule("assignmentExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentExpressionNoIn()
	{
		EnterRule_assignmentExpressionNoIn();
		EnterRule("assignmentExpressionNoIn", 44);
		TraceIn("assignmentExpressionNoIn", 44);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT256 = default(IToken);
		IToken LT257 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> lh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> op = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> rh = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> conditionalExpressionNoIn255 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT256_tree = default(CommonTree);
		CommonTree LT257_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_conditionalExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule conditionalExpressionNoIn");
		RewriteRuleSubtreeStream stream_leftHandSideExpression=new RewriteRuleSubtreeStream(adaptor,"rule leftHandSideExpression");
		RewriteRuleSubtreeStream stream_assignmentOperator=new RewriteRuleSubtreeStream(adaptor,"rule assignmentOperator");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "assignmentExpressionNoIn");
		DebugLocation(278, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 44)) { return retval; }

			// JavaScript.g:279:2: ( conditionalExpressionNoIn -> conditionalExpressionNoIn |lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpressionNoIn -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh) -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh) -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh) -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh) -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh) -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh) -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh) -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh) -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh) -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh) -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh) -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh) ->)
			int alt132=2;
			try { DebugEnterDecision(132, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 98:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 103:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 90:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case StringLiteral:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 78:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 110:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 48:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 93:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				int LA132_2 = input.LA(2);

				if ((EvaluatePredicate(synpred144_JavaScript_fragment)))
				{
					alt132 = 1;
				}
				else if ((true))
				{
					alt132 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 40:
			case 52:
			case 53:
			case 56:
			case 57:
			case 87:
			case 105:
			case 107:
			case 115:
				{
				alt132 = 1;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 132, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(132); }
			switch (alt132)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:279:4: conditionalExpressionNoIn
				{
				DebugLocation(279, 4);
				PushFollow(Follow._conditionalExpressionNoIn_in_assignmentExpressionNoIn2299);
				conditionalExpressionNoIn255=conditionalExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_conditionalExpressionNoIn.Add(conditionalExpressionNoIn255.Tree);


				{
				// AST REWRITE
				// elements: conditionalExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 279:30: -> conditionalExpressionNoIn
				{
					DebugLocation(279, 33);
					adaptor.AddChild(root_0, stream_conditionalExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:280:4: lh= leftHandSideExpression ( LT )* op= assignmentOperator ( LT )* rh= assignmentExpressionNoIn
				{
				DebugLocation(280, 6);
				PushFollow(Follow._leftHandSideExpression_in_assignmentExpressionNoIn2310);
				lh=leftHandSideExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_leftHandSideExpression.Add(lh.Tree);
				DebugLocation(280, 30);
				// JavaScript.g:280:30: ( LT )*
				try { DebugEnterSubRule(130);
				while (true)
				{
					int alt130=2;
					try { DebugEnterDecision(130, false);
					int LA130_1 = input.LA(1);

					if ((LA130_1==LT))
					{
						alt130 = 1;
					}


					} finally { DebugExitDecision(130); }
					switch ( alt130 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:280:30: LT
						{
						DebugLocation(280, 30);
						LT256=(IToken)Match(input,LT,Follow._LT_in_assignmentExpressionNoIn2312); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT256);


						}
						break;

					default:
						goto loop130;
					}
				}

				loop130:
					;

				} finally { DebugExitSubRule(130); }

				DebugLocation(280, 36);
				PushFollow(Follow._assignmentOperator_in_assignmentExpressionNoIn2317);
				op=assignmentOperator();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentOperator.Add(op.Tree);
				DebugLocation(280, 56);
				// JavaScript.g:280:56: ( LT )*
				try { DebugEnterSubRule(131);
				while (true)
				{
					int alt131=2;
					try { DebugEnterDecision(131, false);
					int LA131_1 = input.LA(1);

					if ((LA131_1==LT))
					{
						alt131 = 1;
					}


					} finally { DebugExitDecision(131); }
					switch ( alt131 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:280:56: LT
						{
						DebugLocation(280, 56);
						LT257=(IToken)Match(input,LT,Follow._LT_in_assignmentExpressionNoIn2319); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT257);


						}
						break;

					default:
						goto loop131;
					}
				}

				loop131:
					;

				} finally { DebugExitSubRule(131); }

				DebugLocation(280, 62);
				PushFollow(Follow._assignmentExpressionNoIn_in_assignmentExpressionNoIn2324);
				rh=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(rh.Tree);


				{
				// AST REWRITE
				// elements: 68, lh, rh, 51, lh, rh, 61, lh, rh, 44, lh, rh, 54, lh, rh, 58, lh, rh, 66, lh, rh, 74, lh, rh, 76, lh, rh, 47, lh, rh, 81, lh, rh, 112, lh, rh
				// token labels: 
				// rule labels: lh, rh, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_lh=new RewriteRuleSubtreeStream(adaptor,"rule lh",lh!=null?lh.Tree:null);
				RewriteRuleSubtreeStream stream_rh=new RewriteRuleSubtreeStream(adaptor,"rule rh",rh!=null?rh.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 281:9: -> {op.Tree.Text == \"=\" }? ^( '=' $lh $rh)
				if (op.Tree.Text == "="    )
				{
					DebugLocation(281, 39);
					// JavaScript.g:281:39: ^( '=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(281, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AssignExpression(68), root_1);

					DebugLocation(281, 69);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(281, 73);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 282:9: -> {op.Tree.Text == \"*=\" }? ^( '*=' $lh $rh)
				if (op.Tree.Text == "*="   )
				{
					DebugLocation(282, 39);
					// JavaScript.g:282:39: ^( '*=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(282, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new MultiplyAndAssignExpression(51), root_1);

					DebugLocation(282, 81);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(282, 85);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 283:3: -> {op.Tree.Text == \"/=\" }? ^( '/=' $lh $rh)
				if (op.Tree.Text == "/="   )
				{
					DebugLocation(283, 33);
					// JavaScript.g:283:33: ^( '/=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(283, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DivideAndAssignExpression(61), root_1);

					DebugLocation(283, 73);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(283, 77);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 284:3: -> {op.Tree.Text == \"\\%=\" }? ^( '%=' $lh $rh)
				if (op.Tree.Text == "%="  )
				{
					DebugLocation(284, 33);
					// JavaScript.g:284:33: ^( '%=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(284, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ModulusAndAssignExpression(44), root_1);

					DebugLocation(284, 74);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(284, 78);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 285:3: -> {op.Tree.Text == \"+=\" }? ^( '+=' $lh $rh)
				if (op.Tree.Text == "+="   )
				{
					DebugLocation(285, 33);
					// JavaScript.g:285:33: ^( '+=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(285, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new AddAndAssignExpression(54), root_1);

					DebugLocation(285, 70);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(285, 74);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 286:3: -> {op.Tree.Text == \"-=\" }? ^( '-=' $lh $rh)
				if (op.Tree.Text == "-="   )
				{
					DebugLocation(286, 33);
					// JavaScript.g:286:33: ^( '-=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(286, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new SubtractAndAssignExpression(58), root_1);

					DebugLocation(286, 75);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(286, 79);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 287:3: -> {op.Tree.Text == \"<<=\" }? ^( '<<=' $lh $rh)
				if (op.Tree.Text == "<<="  )
				{
					DebugLocation(287, 33);
					// JavaScript.g:287:33: ^( '<<=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(287, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftLeftAndAssignExpression(66), root_1);

					DebugLocation(287, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(287, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 288:3: -> {op.Tree.Text == \">>=\" }? ^( '>>=' $lh $rh)
				if (op.Tree.Text == ">>="  )
				{
					DebugLocation(288, 33);
					// JavaScript.g:288:33: ^( '>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(288, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftRightAndAssignExpression(74), root_1);

					DebugLocation(288, 78);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(288, 82);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 289:3: -> {op.Tree.Text == \">>>=\" }? ^( '>>>=' $lh $rh)
				if (op.Tree.Text == ">>>=" )
				{
					DebugLocation(289, 33);
					// JavaScript.g:289:33: ^( '>>>=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(289, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new RotateRightAndAssignExpression(76), root_1);

					DebugLocation(289, 80);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(289, 84);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 290:3: -> {op.Tree.Text == \"&=\" }? ^( '&=' $lh $rh)
				if (op.Tree.Text == "&="   )
				{
					DebugLocation(290, 33);
					// JavaScript.g:290:33: ^( '&=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(290, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndAndAssignExpression(47), root_1);

					DebugLocation(290, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(290, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 291:3: -> {op.Tree.Text == \"^=\" }? ^( '^=' $lh $rh)
				if (op.Tree.Text == "^="   )
				{
					DebugLocation(291, 33);
					// JavaScript.g:291:33: ^( '^=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(291, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorAndAssignExpression(81), root_1);

					DebugLocation(291, 77);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(291, 81);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 292:3: -> {op.Tree.Text == \"|=\" }? ^( '|=' $lh $rh)
				if (op.Tree.Text == "|="   )
				{
					DebugLocation(292, 33);
					// JavaScript.g:292:33: ^( '|=' $lh $rh)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(292, 35);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrAndAssignExpression(112), root_1);

					DebugLocation(292, 76);
					adaptor.AddChild(root_1, stream_lh.NextTree());
					DebugLocation(292, 80);
					adaptor.AddChild(root_1, stream_rh.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 293:9: ->
				{
					DebugLocation(294, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentExpressionNoIn", 44);
			LeaveRule("assignmentExpressionNoIn", 44);
			LeaveRule_assignmentExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 44, assignmentExpressionNoIn_StartIndex); }

		}
		DebugLocation(294, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "assignmentExpressionNoIn"

	partial void EnterRule_assignmentOperator();
	partial void LeaveRule_assignmentOperator();
	// $ANTLR start "assignmentOperator"
	// JavaScript.g:296:1: assignmentOperator : ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' );
	[GrammarRule("assignmentOperator")]
	private AstParserRuleReturnScope<CommonTree, IToken> assignmentOperator()
	{
		EnterRule_assignmentOperator();
		EnterRule("assignmentOperator", 45);
		TraceIn("assignmentOperator", 45);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int assignmentOperator_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken set258 = default(IToken);

		CommonTree set258_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "assignmentOperator");
		DebugLocation(296, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 45)) { return retval; }

			// JavaScript.g:297:2: ( '=' | '*=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=' )
			DebugEnterAlt(1);
			// JavaScript.g:
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(297, 2);

			set258=(IToken)input.LT(1);
			if (input.LA(1)==44||input.LA(1)==47||input.LA(1)==51||input.LA(1)==54||input.LA(1)==58||input.LA(1)==61||input.LA(1)==66||input.LA(1)==68||input.LA(1)==74||input.LA(1)==76||input.LA(1)==81||input.LA(1)==112)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set258));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentOperator", 45);
			LeaveRule("assignmentOperator", 45);
			LeaveRule_assignmentOperator();
			if (state.backtracking > 0) { Memoize(input, 45, assignmentOperator_StartIndex); }

		}
		DebugLocation(298, 1);
		} finally { DebugExitRule(GrammarFileName, "assignmentOperator"); }
		return retval;

	}
	// $ANTLR end "assignmentOperator"

	partial void EnterRule_leftHandSideExpression();
	partial void LeaveRule_leftHandSideExpression();
	// $ANTLR start "leftHandSideExpression"
	// JavaScript.g:300:1: leftHandSideExpression : ( callExpression | newExpression );
	[GrammarRule("leftHandSideExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> leftHandSideExpression()
	{
		EnterRule_leftHandSideExpression();
		EnterRule("leftHandSideExpression", 46);
		TraceIn("leftHandSideExpression", 46);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int leftHandSideExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		AstParserRuleReturnScope<CommonTree, IToken> callExpression259 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> newExpression260 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		try { DebugEnterRule(GrammarFileName, "leftHandSideExpression");
		DebugLocation(300, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 46)) { return retval; }

			// JavaScript.g:301:2: ( callExpression | newExpression )
			int alt133=2;
			try { DebugEnterDecision(133, false);
			switch (input.LA(1))
			{
			case 101:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 1, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case Identifier:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 2, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 98:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 3, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 103:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 4, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 90:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 5, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case StringLiteral:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 6, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case NumericLiteral:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 7, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 78:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 8, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 110:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 9, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 48:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 10, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 93:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 11, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case 97:
				{
				int LA133_2 = input.LA(2);

				if ((EvaluatePredicate(synpred158_JavaScript_fragment)))
				{
					alt133 = 1;
				}
				else if ((true))
				{
					alt133 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 133, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(133); }
			switch (alt133)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:301:4: callExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(301, 4);
				PushFollow(Follow._callExpression_in_leftHandSideExpression2665);
				callExpression259=callExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, callExpression259.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:302:4: newExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(302, 4);
				PushFollow(Follow._newExpression_in_leftHandSideExpression2670);
				newExpression260=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, newExpression260.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("leftHandSideExpression", 46);
			LeaveRule("leftHandSideExpression", 46);
			LeaveRule_leftHandSideExpression();
			if (state.backtracking > 0) { Memoize(input, 46, leftHandSideExpression_StartIndex); }

		}
		DebugLocation(303, 1);
		} finally { DebugExitRule(GrammarFileName, "leftHandSideExpression"); }
		return retval;

	}
	// $ANTLR end "leftHandSideExpression"

	partial void EnterRule_newExpression();
	partial void LeaveRule_newExpression();
	// $ANTLR start "newExpression"
	// JavaScript.g:305:1: newExpression : ( memberExpression | 'new' ( LT )* newExpression -> ^( 'new' newExpression ) );
	[GrammarRule("newExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> newExpression()
	{
		EnterRule_newExpression();
		EnterRule("newExpression", 47);
		TraceIn("newExpression", 47);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int newExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal262 = default(IToken);
		IToken LT263 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> memberExpression261 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> newExpression264 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal262_tree = default(CommonTree);
		CommonTree LT263_tree = default(CommonTree);
		RewriteRuleITokenStream stream_97=new RewriteRuleITokenStream(adaptor,"token 97");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_newExpression=new RewriteRuleSubtreeStream(adaptor,"rule newExpression");
		try { DebugEnterRule(GrammarFileName, "newExpression");
		DebugLocation(305, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 47)) { return retval; }

			// JavaScript.g:306:2: ( memberExpression | 'new' ( LT )* newExpression -> ^( 'new' newExpression ) )
			int alt135=2;
			try { DebugEnterDecision(135, false);
			int LA135_1 = input.LA(1);

			if ((LA135_1==Identifier||LA135_1==NumericLiteral||LA135_1==StringLiteral||LA135_1==48||LA135_1==78||LA135_1==90||LA135_1==93||LA135_1==98||LA135_1==101||LA135_1==103||LA135_1==110))
			{
				alt135 = 1;
			}
			else if ((LA135_1==97))
			{
				int LA135_2 = input.LA(2);

				if ((EvaluatePredicate(synpred159_JavaScript_fragment)))
				{
					alt135 = 1;
				}
				else if ((true))
				{
					alt135 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 135, 12, input, 2);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 135, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(135); }
			switch (alt135)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:306:4: memberExpression
				{
				root_0 = (CommonTree)adaptor.Nil();

				DebugLocation(306, 4);
				PushFollow(Follow._memberExpression_in_newExpression2682);
				memberExpression261=memberExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, memberExpression261.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:307:4: 'new' ( LT )* newExpression
				{
				DebugLocation(307, 4);
				string_literal262=(IToken)Match(input,97,Follow._97_in_newExpression2687); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_97.Add(string_literal262);

				DebugLocation(307, 10);
				// JavaScript.g:307:10: ( LT )*
				try { DebugEnterSubRule(134);
				while (true)
				{
					int alt134=2;
					try { DebugEnterDecision(134, false);
					int LA134_1 = input.LA(1);

					if ((LA134_1==LT))
					{
						alt134 = 1;
					}


					} finally { DebugExitDecision(134); }
					switch ( alt134 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:307:10: LT
						{
						DebugLocation(307, 10);
						LT263=(IToken)Match(input,LT,Follow._LT_in_newExpression2689); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT263);


						}
						break;

					default:
						goto loop134;
					}
				}

				loop134:
					;

				} finally { DebugExitSubRule(134); }

				DebugLocation(307, 14);
				PushFollow(Follow._newExpression_in_newExpression2692);
				newExpression264=newExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_newExpression.Add(newExpression264.Tree);


				{
				// AST REWRITE
				// elements: 97, newExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 307:28: -> ^( 'new' newExpression )
				{
					DebugLocation(307, 31);
					// JavaScript.g:307:31: ^( 'new' newExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(307, 33);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NewExpression(stream_97.NextToken()), root_1);

					DebugLocation(307, 59);
					adaptor.AddChild(root_1, stream_newExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("newExpression", 47);
			LeaveRule("newExpression", 47);
			LeaveRule_newExpression();
			if (state.backtracking > 0) { Memoize(input, 47, newExpression_StartIndex); }

		}
		DebugLocation(308, 1);
		} finally { DebugExitRule(GrammarFileName, "newExpression"); }
		return retval;

	}
	// $ANTLR end "newExpression"

	partial void EnterRule_memberExpression();
	partial void LeaveRule_memberExpression();
	// $ANTLR start "memberExpression"
	// JavaScript.g:310:1: memberExpression : ( nonMemberExpression -> nonMemberExpression ) ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )* ;
	[GrammarRule("memberExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> memberExpression()
	{
		EnterRule_memberExpression();
		EnterRule("memberExpression", 48);
		TraceIn("memberExpression", 48);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int memberExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT266 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> nonMemberExpression265 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> indexSuffix267 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propertyReferenceSuffix268 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT266_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_nonMemberExpression=new RewriteRuleSubtreeStream(adaptor,"rule nonMemberExpression");
		RewriteRuleSubtreeStream stream_indexSuffix=new RewriteRuleSubtreeStream(adaptor,"rule indexSuffix");
		RewriteRuleSubtreeStream stream_propertyReferenceSuffix=new RewriteRuleSubtreeStream(adaptor,"rule propertyReferenceSuffix");
		try { DebugEnterRule(GrammarFileName, "memberExpression");
		DebugLocation(310, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 48)) { return retval; }

			// JavaScript.g:311:5: ( ( nonMemberExpression -> nonMemberExpression ) ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )* )
			DebugEnterAlt(1);
			// JavaScript.g:312:9: ( nonMemberExpression -> nonMemberExpression ) ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )*
			{
			DebugLocation(312, 9);
			// JavaScript.g:312:9: ( nonMemberExpression -> nonMemberExpression )
			DebugEnterAlt(1);
			// JavaScript.g:312:10: nonMemberExpression
			{
			DebugLocation(312, 10);
			PushFollow(Follow._nonMemberExpression_in_memberExpression2729);
			nonMemberExpression265=nonMemberExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_nonMemberExpression.Add(nonMemberExpression265.Tree);


			{
			// AST REWRITE
			// elements: nonMemberExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 312:30: -> nonMemberExpression
			{
				DebugLocation(312, 33);
				adaptor.AddChild(root_0, stream_nonMemberExpression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(313, 9);
			// JavaScript.g:313:9: ( ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) ) )*
			try { DebugEnterSubRule(138);
			while (true)
			{
				int alt138=2;
				try { DebugEnterDecision(138, false);
				int LA138_1 = input.LA(1);

				if ((LA138_1==LT))
				{
					int LA138_2 = input.LA(2);

					if ((EvaluatePredicate(synpred163_JavaScript_fragment)))
					{
						alt138 = 1;
					}


				}
				else if ((LA138_1==59||LA138_1==78))
				{
					alt138 = 1;
				}


				} finally { DebugExitDecision(138); }
				switch ( alt138 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:314:13: ( LT )* ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) )
					{
					DebugLocation(314, 13);
					// JavaScript.g:314:13: ( LT )*
					try { DebugEnterSubRule(136);
					while (true)
					{
						int alt136=2;
						try { DebugEnterDecision(136, false);
						int LA136_1 = input.LA(1);

						if ((LA136_1==LT))
						{
							alt136 = 1;
						}


						} finally { DebugExitDecision(136); }
						switch ( alt136 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:314:13: LT
							{
							DebugLocation(314, 13);
							LT266=(IToken)Match(input,LT,Follow._LT_in_memberExpression2758); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT266);


							}
							break;

						default:
							goto loop136;
						}
					}

					loop136:
						;

					} finally { DebugExitSubRule(136); }

					DebugLocation(315, 13);
					// JavaScript.g:315:13: ( indexSuffix -> ^( INDEXEXPR $memberExpression indexSuffix ) | propertyReferenceSuffix -> ^( PROPEXPR $memberExpression propertyReferenceSuffix ) )
					int alt137=2;
					try { DebugEnterSubRule(137);
					try { DebugEnterDecision(137, false);
					int LA137_1 = input.LA(1);

					if ((LA137_1==78))
					{
						alt137 = 1;
					}
					else if ((LA137_1==59))
					{
						alt137 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 137, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					} finally { DebugExitDecision(137); }
					switch (alt137)
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:316:17: indexSuffix
						{
						DebugLocation(316, 17);
						PushFollow(Follow._indexSuffix_in_memberExpression2792);
						indexSuffix267=indexSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_indexSuffix.Add(indexSuffix267.Tree);


						{
						// AST REWRITE
						// elements: memberExpression, indexSuffix
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 316:57: -> ^( INDEXEXPR $memberExpression indexSuffix )
						{
							DebugLocation(316, 60);
							// JavaScript.g:316:60: ^( INDEXEXPR $memberExpression indexSuffix )
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(316, 62);
							root_1 = (CommonTree)adaptor.BecomeRoot(new IndexExpression(INDEXEXPR), root_1);

							DebugLocation(316, 95);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(316, 112);
							adaptor.AddChild(root_1, stream_indexSuffix.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// JavaScript.g:317:19: propertyReferenceSuffix
						{
						DebugLocation(317, 19);
						PushFollow(Follow._propertyReferenceSuffix_in_memberExpression2856);
						propertyReferenceSuffix268=propertyReferenceSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_propertyReferenceSuffix.Add(propertyReferenceSuffix268.Tree);


						{
						// AST REWRITE
						// elements: memberExpression, propertyReferenceSuffix
						// token labels: 
						// rule labels: retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 317:57: -> ^( PROPEXPR $memberExpression propertyReferenceSuffix )
						{
							DebugLocation(317, 60);
							// JavaScript.g:317:60: ^( PROPEXPR $memberExpression propertyReferenceSuffix )
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(317, 62);
							root_1 = (CommonTree)adaptor.BecomeRoot(new PropertyExpression(PROPEXPR), root_1);

							DebugLocation(317, 97);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(317, 114);
							adaptor.AddChild(root_1, stream_propertyReferenceSuffix.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					}
					} finally { DebugExitSubRule(137); }


					}
					break;

				default:
					goto loop138;
				}
			}

			loop138:
				;

			} finally { DebugExitSubRule(138); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("memberExpression", 48);
			LeaveRule("memberExpression", 48);
			LeaveRule_memberExpression();
			if (state.backtracking > 0) { Memoize(input, 48, memberExpression_StartIndex); }

		}
		DebugLocation(320, 4);
		} finally { DebugExitRule(GrammarFileName, "memberExpression"); }
		return retval;

	}
	// $ANTLR end "memberExpression"

	partial void EnterRule_nonMemberExpression();
	partial void LeaveRule_nonMemberExpression();
	// $ANTLR start "nonMemberExpression"
	// JavaScript.g:322:1: nonMemberExpression : ( primaryExpression -> primaryExpression | functionExpression -> functionExpression | 'new' ( LT )* memberExpression ( LT )* arguments -> ^( 'new' memberExpression arguments ) );
	[GrammarRule("nonMemberExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> nonMemberExpression()
	{
		EnterRule_nonMemberExpression();
		EnterRule("nonMemberExpression", 49);
		TraceIn("nonMemberExpression", 49);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int nonMemberExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal271 = default(IToken);
		IToken LT272 = default(IToken);
		IToken LT274 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> primaryExpression269 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> functionExpression270 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> memberExpression273 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arguments275 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal271_tree = default(CommonTree);
		CommonTree LT272_tree = default(CommonTree);
		CommonTree LT274_tree = default(CommonTree);
		RewriteRuleITokenStream stream_97=new RewriteRuleITokenStream(adaptor,"token 97");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_primaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryExpression");
		RewriteRuleSubtreeStream stream_functionExpression=new RewriteRuleSubtreeStream(adaptor,"rule functionExpression");
		RewriteRuleSubtreeStream stream_memberExpression=new RewriteRuleSubtreeStream(adaptor,"rule memberExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "nonMemberExpression");
		DebugLocation(322, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 49)) { return retval; }

			// JavaScript.g:323:5: ( primaryExpression -> primaryExpression | functionExpression -> functionExpression | 'new' ( LT )* memberExpression ( LT )* arguments -> ^( 'new' memberExpression arguments ) )
			int alt141=3;
			try { DebugEnterDecision(141, false);
			switch (input.LA(1))
			{
			case Identifier:
			case NumericLiteral:
			case StringLiteral:
			case 48:
			case 78:
			case 90:
			case 98:
			case 101:
			case 103:
			case 110:
				{
				alt141 = 1;
				}
				break;
			case 93:
				{
				alt141 = 2;
				}
				break;
			case 97:
				{
				alt141 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 141, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(141); }
			switch (alt141)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:323:7: primaryExpression
				{
				DebugLocation(323, 7);
				PushFollow(Follow._primaryExpression_in_nonMemberExpression2928);
				primaryExpression269=primaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_primaryExpression.Add(primaryExpression269.Tree);


				{
				// AST REWRITE
				// elements: primaryExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 323:49: -> primaryExpression
				{
					DebugLocation(323, 52);
					adaptor.AddChild(root_0, stream_primaryExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:324:4: functionExpression
				{
				DebugLocation(324, 4);
				PushFollow(Follow._functionExpression_in_nonMemberExpression2961);
				functionExpression270=functionExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_functionExpression.Add(functionExpression270.Tree);


				{
				// AST REWRITE
				// elements: functionExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 324:46: -> functionExpression
				{
					DebugLocation(324, 49);
					adaptor.AddChild(root_0, stream_functionExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:325:4: 'new' ( LT )* memberExpression ( LT )* arguments
				{
				DebugLocation(325, 4);
				string_literal271=(IToken)Match(input,97,Follow._97_in_nonMemberExpression2993); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_97.Add(string_literal271);

				DebugLocation(325, 10);
				// JavaScript.g:325:10: ( LT )*
				try { DebugEnterSubRule(139);
				while (true)
				{
					int alt139=2;
					try { DebugEnterDecision(139, false);
					int LA139_1 = input.LA(1);

					if ((LA139_1==LT))
					{
						alt139 = 1;
					}


					} finally { DebugExitDecision(139); }
					switch ( alt139 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:325:10: LT
						{
						DebugLocation(325, 10);
						LT272=(IToken)Match(input,LT,Follow._LT_in_nonMemberExpression2995); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT272);


						}
						break;

					default:
						goto loop139;
					}
				}

				loop139:
					;

				} finally { DebugExitSubRule(139); }

				DebugLocation(325, 14);
				PushFollow(Follow._memberExpression_in_nonMemberExpression2998);
				memberExpression273=memberExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_memberExpression.Add(memberExpression273.Tree);
				DebugLocation(325, 32);
				// JavaScript.g:325:32: ( LT )*
				try { DebugEnterSubRule(140);
				while (true)
				{
					int alt140=2;
					try { DebugEnterDecision(140, false);
					int LA140_1 = input.LA(1);

					if ((LA140_1==LT))
					{
						alt140 = 1;
					}


					} finally { DebugExitDecision(140); }
					switch ( alt140 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:325:32: LT
						{
						DebugLocation(325, 32);
						LT274=(IToken)Match(input,LT,Follow._LT_in_nonMemberExpression3001); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT274);


						}
						break;

					default:
						goto loop140;
					}
				}

				loop140:
					;

				} finally { DebugExitSubRule(140); }

				DebugLocation(325, 36);
				PushFollow(Follow._arguments_in_nonMemberExpression3004);
				arguments275=arguments();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arguments.Add(arguments275.Tree);


				{
				// AST REWRITE
				// elements: 97, memberExpression, arguments
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 325:46: -> ^( 'new' memberExpression arguments )
				{
					DebugLocation(325, 49);
					// JavaScript.g:325:49: ^( 'new' memberExpression arguments )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(325, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NewExpression(stream_97.NextToken()), root_1);

					DebugLocation(325, 77);
					adaptor.AddChild(root_1, stream_memberExpression.NextTree());
					DebugLocation(325, 94);
					adaptor.AddChild(root_1, stream_arguments.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("nonMemberExpression", 49);
			LeaveRule("nonMemberExpression", 49);
			LeaveRule_nonMemberExpression();
			if (state.backtracking > 0) { Memoize(input, 49, nonMemberExpression_StartIndex); }

		}
		DebugLocation(326, 4);
		} finally { DebugExitRule(GrammarFileName, "nonMemberExpression"); }
		return retval;

	}
	// $ANTLR end "nonMemberExpression"

	partial void EnterRule_callExpression();
	partial void LeaveRule_callExpression();
	// $ANTLR start "callExpression"
	// JavaScript.g:328:1: callExpression : (pce= primaryCallExpression -> $pce) ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )* ;
	[GrammarRule("callExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> callExpression()
	{
		EnterRule_callExpression();
		EnterRule("callExpression", 50);
		TraceIn("callExpression", 50);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int callExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT276 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> pce = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> args = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> idx = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> prop = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT276_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_primaryCallExpression=new RewriteRuleSubtreeStream(adaptor,"rule primaryCallExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		RewriteRuleSubtreeStream stream_indexSuffix=new RewriteRuleSubtreeStream(adaptor,"rule indexSuffix");
		RewriteRuleSubtreeStream stream_propertyReferenceSuffix=new RewriteRuleSubtreeStream(adaptor,"rule propertyReferenceSuffix");
		try { DebugEnterRule(GrammarFileName, "callExpression");
		DebugLocation(328, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 50)) { return retval; }

			// JavaScript.g:329:2: ( (pce= primaryCallExpression -> $pce) ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )* )
			DebugEnterAlt(1);
			// JavaScript.g:330:9: (pce= primaryCallExpression -> $pce) ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )*
			{
			DebugLocation(330, 9);
			// JavaScript.g:330:9: (pce= primaryCallExpression -> $pce)
			DebugEnterAlt(1);
			// JavaScript.g:330:10: pce= primaryCallExpression
			{
			DebugLocation(330, 13);
			PushFollow(Follow._primaryCallExpression_in_callExpression3045);
			pce=primaryCallExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_primaryCallExpression.Add(pce.Tree);


			{
			// AST REWRITE
			// elements: pce
			// token labels: 
			// rule labels: pce, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_pce=new RewriteRuleSubtreeStream(adaptor,"rule pce",pce!=null?pce.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 330:36: -> $pce
			{
				DebugLocation(330, 40);
				adaptor.AddChild(root_0, stream_pce.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			DebugLocation(331, 9);
			// JavaScript.g:331:9: ( ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) ) )*
			try { DebugEnterSubRule(144);
			while (true)
			{
				int alt144=2;
				try { DebugEnterDecision(144, false);
				int LA144_1 = input.LA(1);

				if ((LA144_1==LT))
				{
					int LA144_2 = input.LA(2);

					if ((EvaluatePredicate(synpred171_JavaScript_fragment)))
					{
						alt144 = 1;
					}


				}
				else if ((LA144_1==48||LA144_1==59||LA144_1==78))
				{
					alt144 = 1;
				}


				} finally { DebugExitDecision(144); }
				switch ( alt144 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:332:13: ( LT )* (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) )
					{
					DebugLocation(332, 13);
					// JavaScript.g:332:13: ( LT )*
					try { DebugEnterSubRule(142);
					while (true)
					{
						int alt142=2;
						try { DebugEnterDecision(142, false);
						int LA142_1 = input.LA(1);

						if ((LA142_1==LT))
						{
							alt142 = 1;
						}


						} finally { DebugExitDecision(142); }
						switch ( alt142 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:332:13: LT
							{
							DebugLocation(332, 13);
							LT276=(IToken)Match(input,LT,Follow._LT_in_callExpression3075); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT276);


							}
							break;

						default:
							goto loop142;
						}
					}

					loop142:
						;

					} finally { DebugExitSubRule(142); }

					DebugLocation(333, 13);
					// JavaScript.g:333:13: (args= arguments -> ^( CALLEXPR $callExpression $args) |idx= indexSuffix -> ^( INDEXEXPR $callExpression $idx) |prop= propertyReferenceSuffix -> ^( PROPEXPR $callExpression $prop) )
					int alt143=3;
					try { DebugEnterSubRule(143);
					try { DebugEnterDecision(143, false);
					switch (input.LA(1))
					{
					case 48:
						{
						alt143 = 1;
						}
						break;
					case 78:
						{
						alt143 = 2;
						}
						break;
					case 59:
						{
						alt143 = 3;
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 143, 0, input, 1);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(143); }
					switch (alt143)
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:334:17: args= arguments
						{
						DebugLocation(334, 21);
						PushFollow(Follow._arguments_in_callExpression3111);
						args=arguments();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_arguments.Add(args.Tree);


						{
						// AST REWRITE
						// elements: callExpression, args
						// token labels: 
						// rule labels: args, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_args=new RewriteRuleSubtreeStream(adaptor,"rule args",args!=null?args.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 334:49: -> ^( CALLEXPR $callExpression $args)
						{
							DebugLocation(334, 52);
							// JavaScript.g:334:52: ^( CALLEXPR $callExpression $args)
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(334, 54);
							root_1 = (CommonTree)adaptor.BecomeRoot(new CallExpression(CALLEXPR), root_1);

							DebugLocation(334, 85);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(334, 101);
							adaptor.AddChild(root_1, stream_args.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// JavaScript.g:335:16: idx= indexSuffix
						{
						DebugLocation(335, 19);
						PushFollow(Follow._indexSuffix_in_callExpression3164);
						idx=indexSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_indexSuffix.Add(idx.Tree);


						{
						// AST REWRITE
						// elements: callExpression, idx
						// token labels: 
						// rule labels: idx, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_idx=new RewriteRuleSubtreeStream(adaptor,"rule idx",idx!=null?idx.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 335:46: -> ^( INDEXEXPR $callExpression $idx)
						{
							DebugLocation(335, 49);
							// JavaScript.g:335:49: ^( INDEXEXPR $callExpression $idx)
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(335, 51);
							root_1 = (CommonTree)adaptor.BecomeRoot(new IndexExpression(INDEXEXPR), root_1);

							DebugLocation(335, 84);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(335, 100);
							adaptor.AddChild(root_1, stream_idx.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// JavaScript.g:336:16: prop= propertyReferenceSuffix
						{
						DebugLocation(336, 20);
						PushFollow(Follow._propertyReferenceSuffix_in_callExpression3214);
						prop=propertyReferenceSuffix();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_propertyReferenceSuffix.Add(prop.Tree);


						{
						// AST REWRITE
						// elements: callExpression, prop
						// token labels: 
						// rule labels: prop, retval
						// token list labels: 
						// rule list labels: 
						// wildcard labels: 
						if (state.backtracking == 0) {
						retval.Tree = root_0;
						RewriteRuleSubtreeStream stream_prop=new RewriteRuleSubtreeStream(adaptor,"rule prop",prop!=null?prop.Tree:null);
						RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

						root_0 = (CommonTree)adaptor.Nil();
						// 336:46: -> ^( PROPEXPR $callExpression $prop)
						{
							DebugLocation(336, 49);
							// JavaScript.g:336:49: ^( PROPEXPR $callExpression $prop)
							{
							CommonTree root_1 = (CommonTree)adaptor.Nil();
							DebugLocation(336, 51);
							root_1 = (CommonTree)adaptor.BecomeRoot(new PropertyExpression(PROPEXPR), root_1);

							DebugLocation(336, 86);
							adaptor.AddChild(root_1, stream_retval.NextTree());
							DebugLocation(336, 102);
							adaptor.AddChild(root_1, stream_prop.NextTree());

							adaptor.AddChild(root_0, root_1);
							}

						}

						retval.Tree = root_0;
						}
						}

						}
						break;

					}
					} finally { DebugExitSubRule(143); }


					}
					break;

				default:
					goto loop144;
				}
			}

			loop144:
				;

			} finally { DebugExitSubRule(144); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("callExpression", 50);
			LeaveRule("callExpression", 50);
			LeaveRule_callExpression();
			if (state.backtracking > 0) { Memoize(input, 50, callExpression_StartIndex); }

		}
		DebugLocation(339, 4);
		} finally { DebugExitRule(GrammarFileName, "callExpression"); }
		return retval;

	}
	// $ANTLR end "callExpression"

	partial void EnterRule_primaryCallExpression();
	partial void LeaveRule_primaryCallExpression();
	// $ANTLR start "primaryCallExpression"
	// JavaScript.g:341:1: primaryCallExpression : me= memberExpression ( LT )* a= arguments -> ^( CALLEXPR $me $a) ;
	[GrammarRule("primaryCallExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> primaryCallExpression()
	{
		EnterRule_primaryCallExpression();
		EnterRule("primaryCallExpression", 51);
		TraceIn("primaryCallExpression", 51);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primaryCallExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT277 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> me = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> a = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT277_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleSubtreeStream stream_memberExpression=new RewriteRuleSubtreeStream(adaptor,"rule memberExpression");
		RewriteRuleSubtreeStream stream_arguments=new RewriteRuleSubtreeStream(adaptor,"rule arguments");
		try { DebugEnterRule(GrammarFileName, "primaryCallExpression");
		DebugLocation(341, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 51)) { return retval; }

			// JavaScript.g:342:5: (me= memberExpression ( LT )* a= arguments -> ^( CALLEXPR $me $a) )
			DebugEnterAlt(1);
			// JavaScript.g:342:7: me= memberExpression ( LT )* a= arguments
			{
			DebugLocation(342, 9);
			PushFollow(Follow._memberExpression_in_primaryCallExpression3276);
			me=memberExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_memberExpression.Add(me.Tree);
			DebugLocation(342, 27);
			// JavaScript.g:342:27: ( LT )*
			try { DebugEnterSubRule(145);
			while (true)
			{
				int alt145=2;
				try { DebugEnterDecision(145, false);
				int LA145_1 = input.LA(1);

				if ((LA145_1==LT))
				{
					alt145 = 1;
				}


				} finally { DebugExitDecision(145); }
				switch ( alt145 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:342:27: LT
					{
					DebugLocation(342, 27);
					LT277=(IToken)Match(input,LT,Follow._LT_in_primaryCallExpression3278); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT277);


					}
					break;

				default:
					goto loop145;
				}
			}

			loop145:
				;

			} finally { DebugExitSubRule(145); }

			DebugLocation(342, 32);
			PushFollow(Follow._arguments_in_primaryCallExpression3283);
			a=arguments();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_arguments.Add(a.Tree);


			{
			// AST REWRITE
			// elements: me, a
			// token labels: 
			// rule labels: me, a, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_me=new RewriteRuleSubtreeStream(adaptor,"rule me",me!=null?me.Tree:null);
			RewriteRuleSubtreeStream stream_a=new RewriteRuleSubtreeStream(adaptor,"rule a",a!=null?a.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 342:43: -> ^( CALLEXPR $me $a)
			{
				DebugLocation(342, 46);
				// JavaScript.g:342:46: ^( CALLEXPR $me $a)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(342, 48);
				root_1 = (CommonTree)adaptor.BecomeRoot(new CallExpression(CALLEXPR), root_1);

				DebugLocation(342, 79);
				adaptor.AddChild(root_1, stream_me.NextTree());
				DebugLocation(342, 83);
				adaptor.AddChild(root_1, stream_a.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryCallExpression", 51);
			LeaveRule("primaryCallExpression", 51);
			LeaveRule_primaryCallExpression();
			if (state.backtracking > 0) { Memoize(input, 51, primaryCallExpression_StartIndex); }

		}
		DebugLocation(343, 4);
		} finally { DebugExitRule(GrammarFileName, "primaryCallExpression"); }
		return retval;

	}
	// $ANTLR end "primaryCallExpression"

	partial void EnterRule_arguments();
	partial void LeaveRule_arguments();
	// $ANTLR start "arguments"
	// JavaScript.g:345:1: arguments : '(' ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )? ( LT )* ')' -> ^( '(' ( assignmentExpression )* ) ;
	[GrammarRule("arguments")]
	private AstParserRuleReturnScope<CommonTree, IToken> arguments()
	{
		EnterRule_arguments();
		EnterRule("arguments", 52);
		TraceIn("arguments", 52);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arguments_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal278 = default(IToken);
		IToken LT279 = default(IToken);
		IToken LT281 = default(IToken);
		IToken char_literal282 = default(IToken);
		IToken LT283 = default(IToken);
		IToken LT285 = default(IToken);
		IToken char_literal286 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression280 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression284 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal278_tree = default(CommonTree);
		CommonTree LT279_tree = default(CommonTree);
		CommonTree LT281_tree = default(CommonTree);
		CommonTree char_literal282_tree = default(CommonTree);
		CommonTree LT283_tree = default(CommonTree);
		CommonTree LT285_tree = default(CommonTree);
		CommonTree char_literal286_tree = default(CommonTree);
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arguments");
		DebugLocation(345, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 52)) { return retval; }

			// JavaScript.g:346:2: ( '(' ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )? ( LT )* ')' -> ^( '(' ( assignmentExpression )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:346:4: '(' ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )? ( LT )* ')'
			{
			DebugLocation(346, 4);
			char_literal278=(IToken)Match(input,48,Follow._48_in_arguments3315); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_48.Add(char_literal278);

			DebugLocation(346, 8);
			// JavaScript.g:346:8: ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )?
			int alt150=2;
			try { DebugEnterSubRule(150);
			try { DebugEnterDecision(150, false);
			try
			{
				alt150 = dfa150.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(150); }
			switch (alt150)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:346:9: ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )*
				{
				DebugLocation(346, 9);
				// JavaScript.g:346:9: ( LT )*
				try { DebugEnterSubRule(146);
				while (true)
				{
					int alt146=2;
					try { DebugEnterDecision(146, false);
					int LA146_1 = input.LA(1);

					if ((LA146_1==LT))
					{
						alt146 = 1;
					}


					} finally { DebugExitDecision(146); }
					switch ( alt146 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:346:9: LT
						{
						DebugLocation(346, 9);
						LT279=(IToken)Match(input,LT,Follow._LT_in_arguments3318); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT279);


						}
						break;

					default:
						goto loop146;
					}
				}

				loop146:
					;

				} finally { DebugExitSubRule(146); }

				DebugLocation(346, 13);
				PushFollow(Follow._assignmentExpression_in_arguments3321);
				assignmentExpression280=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression280.Tree);
				DebugLocation(346, 34);
				// JavaScript.g:346:34: ( ( LT )* ',' ( LT )* assignmentExpression )*
				try { DebugEnterSubRule(149);
				while (true)
				{
					int alt149=2;
					try { DebugEnterDecision(149, false);
					try
					{
						alt149 = dfa149.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(149); }
					switch ( alt149 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:346:35: ( LT )* ',' ( LT )* assignmentExpression
						{
						DebugLocation(346, 35);
						// JavaScript.g:346:35: ( LT )*
						try { DebugEnterSubRule(147);
						while (true)
						{
							int alt147=2;
							try { DebugEnterDecision(147, false);
							int LA147_1 = input.LA(1);

							if ((LA147_1==LT))
							{
								alt147 = 1;
							}


							} finally { DebugExitDecision(147); }
							switch ( alt147 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:346:35: LT
								{
								DebugLocation(346, 35);
								LT281=(IToken)Match(input,LT,Follow._LT_in_arguments3324); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT281);


								}
								break;

							default:
								goto loop147;
							}
						}

						loop147:
							;

						} finally { DebugExitSubRule(147); }

						DebugLocation(346, 39);
						char_literal282=(IToken)Match(input,55,Follow._55_in_arguments3327); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal282);

						DebugLocation(346, 43);
						// JavaScript.g:346:43: ( LT )*
						try { DebugEnterSubRule(148);
						while (true)
						{
							int alt148=2;
							try { DebugEnterDecision(148, false);
							int LA148_1 = input.LA(1);

							if ((LA148_1==LT))
							{
								alt148 = 1;
							}


							} finally { DebugExitDecision(148); }
							switch ( alt148 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:346:43: LT
								{
								DebugLocation(346, 43);
								LT283=(IToken)Match(input,LT,Follow._LT_in_arguments3329); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT283);


								}
								break;

							default:
								goto loop148;
							}
						}

						loop148:
							;

						} finally { DebugExitSubRule(148); }

						DebugLocation(346, 47);
						PushFollow(Follow._assignmentExpression_in_arguments3332);
						assignmentExpression284=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression284.Tree);

						}
						break;

					default:
						goto loop149;
					}
				}

				loop149:
					;

				} finally { DebugExitSubRule(149); }


				}
				break;

			}
			} finally { DebugExitSubRule(150); }

			DebugLocation(346, 72);
			// JavaScript.g:346:72: ( LT )*
			try { DebugEnterSubRule(151);
			while (true)
			{
				int alt151=2;
				try { DebugEnterDecision(151, false);
				int LA151_1 = input.LA(1);

				if ((LA151_1==LT))
				{
					alt151 = 1;
				}


				} finally { DebugExitDecision(151); }
				switch ( alt151 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:346:72: LT
					{
					DebugLocation(346, 72);
					LT285=(IToken)Match(input,LT,Follow._LT_in_arguments3338); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT285);


					}
					break;

				default:
					goto loop151;
				}
			}

			loop151:
				;

			} finally { DebugExitSubRule(151); }

			DebugLocation(346, 76);
			char_literal286=(IToken)Match(input,49,Follow._49_in_arguments3341); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_49.Add(char_literal286);



			{
			// AST REWRITE
			// elements: 48, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 347:3: -> ^( '(' ( assignmentExpression )* )
			{
				DebugLocation(347, 6);
				// JavaScript.g:347:6: ^( '(' ( assignmentExpression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(347, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ArgumentList(stream_48.NextToken()), root_1);

				DebugLocation(347, 31);
				// JavaScript.g:347:31: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(347, 31);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arguments", 52);
			LeaveRule("arguments", 52);
			LeaveRule_arguments();
			if (state.backtracking > 0) { Memoize(input, 52, arguments_StartIndex); }

		}
		DebugLocation(348, 1);
		} finally { DebugExitRule(GrammarFileName, "arguments"); }
		return retval;

	}
	// $ANTLR end "arguments"

	partial void EnterRule_indexSuffix();
	partial void LeaveRule_indexSuffix();
	// $ANTLR start "indexSuffix"
	// JavaScript.g:350:1: indexSuffix : '[' ( LT )* expression ( LT )* ']' -> expression ;
	[GrammarRule("indexSuffix")]
	private AstParserRuleReturnScope<CommonTree, IToken> indexSuffix()
	{
		EnterRule_indexSuffix();
		EnterRule("indexSuffix", 53);
		TraceIn("indexSuffix", 53);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int indexSuffix_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal287 = default(IToken);
		IToken LT288 = default(IToken);
		IToken LT290 = default(IToken);
		IToken char_literal291 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> expression289 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal287_tree = default(CommonTree);
		CommonTree LT288_tree = default(CommonTree);
		CommonTree LT290_tree = default(CommonTree);
		CommonTree char_literal291_tree = default(CommonTree);
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "indexSuffix");
		DebugLocation(350, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 53)) { return retval; }

			// JavaScript.g:351:2: ( '[' ( LT )* expression ( LT )* ']' -> expression )
			DebugEnterAlt(1);
			// JavaScript.g:351:4: '[' ( LT )* expression ( LT )* ']'
			{
			DebugLocation(351, 4);
			char_literal287=(IToken)Match(input,78,Follow._78_in_indexSuffix3369); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_78.Add(char_literal287);

			DebugLocation(351, 8);
			// JavaScript.g:351:8: ( LT )*
			try { DebugEnterSubRule(152);
			while (true)
			{
				int alt152=2;
				try { DebugEnterDecision(152, false);
				int LA152_1 = input.LA(1);

				if ((LA152_1==LT))
				{
					alt152 = 1;
				}


				} finally { DebugExitDecision(152); }
				switch ( alt152 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:351:8: LT
					{
					DebugLocation(351, 8);
					LT288=(IToken)Match(input,LT,Follow._LT_in_indexSuffix3371); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT288);


					}
					break;

				default:
					goto loop152;
				}
			}

			loop152:
				;

			} finally { DebugExitSubRule(152); }

			DebugLocation(351, 12);
			PushFollow(Follow._expression_in_indexSuffix3374);
			expression289=expression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expression.Add(expression289.Tree);
			DebugLocation(351, 23);
			// JavaScript.g:351:23: ( LT )*
			try { DebugEnterSubRule(153);
			while (true)
			{
				int alt153=2;
				try { DebugEnterDecision(153, false);
				int LA153_1 = input.LA(1);

				if ((LA153_1==LT))
				{
					alt153 = 1;
				}


				} finally { DebugExitDecision(153); }
				switch ( alt153 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:351:23: LT
					{
					DebugLocation(351, 23);
					LT290=(IToken)Match(input,LT,Follow._LT_in_indexSuffix3376); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT290);


					}
					break;

				default:
					goto loop153;
				}
			}

			loop153:
				;

			} finally { DebugExitSubRule(153); }

			DebugLocation(351, 27);
			char_literal291=(IToken)Match(input,79,Follow._79_in_indexSuffix3379); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_79.Add(char_literal291);



			{
			// AST REWRITE
			// elements: expression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 351:31: -> expression
			{
				DebugLocation(351, 34);
				adaptor.AddChild(root_0, stream_expression.NextTree());

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("indexSuffix", 53);
			LeaveRule("indexSuffix", 53);
			LeaveRule_indexSuffix();
			if (state.backtracking > 0) { Memoize(input, 53, indexSuffix_StartIndex); }

		}
		DebugLocation(352, 1);
		} finally { DebugExitRule(GrammarFileName, "indexSuffix"); }
		return retval;

	}
	// $ANTLR end "indexSuffix"

	partial void EnterRule_propertyReferenceSuffix();
	partial void LeaveRule_propertyReferenceSuffix();
	// $ANTLR start "propertyReferenceSuffix"
	// JavaScript.g:354:1: propertyReferenceSuffix : '.' ( LT )* Identifier -> Identifier ;
	[GrammarRule("propertyReferenceSuffix")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyReferenceSuffix()
	{
		EnterRule_propertyReferenceSuffix();
		EnterRule("propertyReferenceSuffix", 54);
		TraceIn("propertyReferenceSuffix", 54);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyReferenceSuffix_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal292 = default(IToken);
		IToken LT293 = default(IToken);
		IToken Identifier294 = default(IToken);

		CommonTree char_literal292_tree = default(CommonTree);
		CommonTree LT293_tree = default(CommonTree);
		CommonTree Identifier294_tree = default(CommonTree);
		RewriteRuleITokenStream stream_59=new RewriteRuleITokenStream(adaptor,"token 59");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		try { DebugEnterRule(GrammarFileName, "propertyReferenceSuffix");
		DebugLocation(354, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 54)) { return retval; }

			// JavaScript.g:355:2: ( '.' ( LT )* Identifier -> Identifier )
			DebugEnterAlt(1);
			// JavaScript.g:355:4: '.' ( LT )* Identifier
			{
			DebugLocation(355, 4);
			char_literal292=(IToken)Match(input,59,Follow._59_in_propertyReferenceSuffix3396); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_59.Add(char_literal292);

			DebugLocation(355, 8);
			// JavaScript.g:355:8: ( LT )*
			try { DebugEnterSubRule(154);
			while (true)
			{
				int alt154=2;
				try { DebugEnterDecision(154, false);
				int LA154_1 = input.LA(1);

				if ((LA154_1==LT))
				{
					alt154 = 1;
				}


				} finally { DebugExitDecision(154); }
				switch ( alt154 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:355:8: LT
					{
					DebugLocation(355, 8);
					LT293=(IToken)Match(input,LT,Follow._LT_in_propertyReferenceSuffix3398); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT293);


					}
					break;

				default:
					goto loop154;
				}
			}

			loop154:
				;

			} finally { DebugExitSubRule(154); }

			DebugLocation(355, 12);
			Identifier294=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyReferenceSuffix3401); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_Identifier.Add(Identifier294);



			{
			// AST REWRITE
			// elements: Identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 355:23: -> Identifier
			{
				DebugLocation(355, 26);
				adaptor.AddChild(root_0, new Identifier(stream_Identifier.NextToken()));

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyReferenceSuffix", 54);
			LeaveRule("propertyReferenceSuffix", 54);
			LeaveRule_propertyReferenceSuffix();
			if (state.backtracking > 0) { Memoize(input, 54, propertyReferenceSuffix_StartIndex); }

		}
		DebugLocation(356, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyReferenceSuffix"); }
		return retval;

	}
	// $ANTLR end "propertyReferenceSuffix"

	partial void EnterRule_conditionalExpression();
	partial void LeaveRule_conditionalExpression();
	// $ANTLR start "conditionalExpression"
	// JavaScript.g:358:1: conditionalExpression : logicalORExpression ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression ) ;
	[GrammarRule("conditionalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditionalExpression()
	{
		EnterRule_conditionalExpression();
		EnterRule("conditionalExpression", 55);
		TraceIn("conditionalExpression", 55);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditionalExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT296 = default(IToken);
		IToken char_literal297 = default(IToken);
		IToken LT298 = default(IToken);
		IToken LT299 = default(IToken);
		IToken char_literal300 = default(IToken);
		IToken LT301 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> iftrue = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> iffalse = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpression295 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT296_tree = default(CommonTree);
		CommonTree char_literal297_tree = default(CommonTree);
		CommonTree LT298_tree = default(CommonTree);
		CommonTree LT299_tree = default(CommonTree);
		CommonTree char_literal300_tree = default(CommonTree);
		CommonTree LT301_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_logicalORExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpression");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "conditionalExpression");
		DebugLocation(358, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 55)) { return retval; }

			// JavaScript.g:359:2: ( logicalORExpression ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:360:3: logicalORExpression ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression )
			{
			DebugLocation(360, 3);
			PushFollow(Follow._logicalORExpression_in_conditionalExpression3423);
			logicalORExpression295=logicalORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalORExpression.Add(logicalORExpression295.Tree);
			DebugLocation(361, 3);
			// JavaScript.g:361:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression )
			int alt159=2;
			try { DebugEnterSubRule(159);
			try { DebugEnterDecision(159, false);
			try
			{
				alt159 = dfa159.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(159); }
			switch (alt159)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:362:4: ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression
				{
				DebugLocation(362, 4);
				// JavaScript.g:362:4: ( LT )*
				try { DebugEnterSubRule(155);
				while (true)
				{
					int alt155=2;
					try { DebugEnterDecision(155, false);
					int LA155_1 = input.LA(1);

					if ((LA155_1==LT))
					{
						alt155 = 1;
					}


					} finally { DebugExitDecision(155); }
					switch ( alt155 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:4: LT
						{
						DebugLocation(362, 4);
						LT296=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3433); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT296);


						}
						break;

					default:
						goto loop155;
					}
				}

				loop155:
					;

				} finally { DebugExitSubRule(155); }

				DebugLocation(362, 8);
				char_literal297=(IToken)Match(input,77,Follow._77_in_conditionalExpression3436); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_77.Add(char_literal297);

				DebugLocation(362, 12);
				// JavaScript.g:362:12: ( LT )*
				try { DebugEnterSubRule(156);
				while (true)
				{
					int alt156=2;
					try { DebugEnterDecision(156, false);
					int LA156_1 = input.LA(1);

					if ((LA156_1==LT))
					{
						alt156 = 1;
					}


					} finally { DebugExitDecision(156); }
					switch ( alt156 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:12: LT
						{
						DebugLocation(362, 12);
						LT298=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3438); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT298);


						}
						break;

					default:
						goto loop156;
					}
				}

				loop156:
					;

				} finally { DebugExitSubRule(156); }

				DebugLocation(362, 22);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression3443);
				iftrue=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(iftrue.Tree);
				DebugLocation(362, 44);
				// JavaScript.g:362:44: ( LT )*
				try { DebugEnterSubRule(157);
				while (true)
				{
					int alt157=2;
					try { DebugEnterDecision(157, false);
					int LA157_1 = input.LA(1);

					if ((LA157_1==LT))
					{
						alt157 = 1;
					}


					} finally { DebugExitDecision(157); }
					switch ( alt157 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:44: LT
						{
						DebugLocation(362, 44);
						LT299=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3445); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT299);


						}
						break;

					default:
						goto loop157;
					}
				}

				loop157:
					;

				} finally { DebugExitSubRule(157); }

				DebugLocation(362, 48);
				char_literal300=(IToken)Match(input,62,Follow._62_in_conditionalExpression3448); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal300);

				DebugLocation(362, 52);
				// JavaScript.g:362:52: ( LT )*
				try { DebugEnterSubRule(158);
				while (true)
				{
					int alt158=2;
					try { DebugEnterDecision(158, false);
					int LA158_1 = input.LA(1);

					if ((LA158_1==LT))
					{
						alt158 = 1;
					}


					} finally { DebugExitDecision(158); }
					switch ( alt158 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:362:52: LT
						{
						DebugLocation(362, 52);
						LT301=(IToken)Match(input,LT,Follow._LT_in_conditionalExpression3450); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT301);


						}
						break;

					default:
						goto loop158;
					}
				}

				loop158:
					;

				} finally { DebugExitSubRule(158); }

				DebugLocation(362, 63);
				PushFollow(Follow._assignmentExpression_in_conditionalExpression3455);
				iffalse=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(iffalse.Tree);


				{
				// AST REWRITE
				// elements: 77, logicalORExpression, iftrue, iffalse
				// token labels: 
				// rule labels: iftrue, iffalse, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_iftrue=new RewriteRuleSubtreeStream(adaptor,"rule iftrue",iftrue!=null?iftrue.Tree:null);
				RewriteRuleSubtreeStream stream_iffalse=new RewriteRuleSubtreeStream(adaptor,"rule iffalse",iffalse!=null?iffalse.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 363:5: -> ^( '?' logicalORExpression $iftrue $iffalse)
				{
					DebugLocation(363, 8);
					// JavaScript.g:363:8: ^( '?' logicalORExpression $iftrue $iffalse)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(363, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ConditionalExpression(stream_77.NextToken()), root_1);

					DebugLocation(363, 42);
					adaptor.AddChild(root_1, stream_logicalORExpression.NextTree());
					DebugLocation(363, 63);
					adaptor.AddChild(root_1, stream_iftrue.NextTree());
					DebugLocation(363, 71);
					adaptor.AddChild(root_1, stream_iffalse.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:364:6: 
				{

				{
				// AST REWRITE
				// elements: logicalORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 364:6: -> logicalORExpression
				{
					DebugLocation(364, 9);
					adaptor.AddChild(root_0, stream_logicalORExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(159); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpression", 55);
			LeaveRule("conditionalExpression", 55);
			LeaveRule_conditionalExpression();
			if (state.backtracking > 0) { Memoize(input, 55, conditionalExpression_StartIndex); }

		}
		DebugLocation(366, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpression"); }
		return retval;

	}
	// $ANTLR end "conditionalExpression"

	partial void EnterRule_conditionalExpressionNoIn();
	partial void LeaveRule_conditionalExpressionNoIn();
	// $ANTLR start "conditionalExpressionNoIn"
	// JavaScript.g:368:1: conditionalExpressionNoIn : logicalORExpressionNoIn ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn ) ;
	[GrammarRule("conditionalExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> conditionalExpressionNoIn()
	{
		EnterRule_conditionalExpressionNoIn();
		EnterRule("conditionalExpressionNoIn", 56);
		TraceIn("conditionalExpressionNoIn", 56);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int conditionalExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT303 = default(IToken);
		IToken char_literal304 = default(IToken);
		IToken LT305 = default(IToken);
		IToken LT306 = default(IToken);
		IToken char_literal307 = default(IToken);
		IToken LT308 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> iftrue = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> iffalse = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpressionNoIn302 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT303_tree = default(CommonTree);
		CommonTree char_literal304_tree = default(CommonTree);
		CommonTree LT305_tree = default(CommonTree);
		CommonTree LT306_tree = default(CommonTree);
		CommonTree char_literal307_tree = default(CommonTree);
		CommonTree LT308_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_77=new RewriteRuleITokenStream(adaptor,"token 77");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_logicalORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpressionNoIn");
		RewriteRuleSubtreeStream stream_assignmentExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "conditionalExpressionNoIn");
		DebugLocation(368, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 56)) { return retval; }

			// JavaScript.g:369:2: ( logicalORExpressionNoIn ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:370:3: logicalORExpressionNoIn ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn )
			{
			DebugLocation(370, 3);
			PushFollow(Follow._logicalORExpressionNoIn_in_conditionalExpressionNoIn3505);
			logicalORExpressionNoIn302=logicalORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalORExpressionNoIn.Add(logicalORExpressionNoIn302.Tree);
			DebugLocation(371, 3);
			// JavaScript.g:371:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn )
			int alt164=2;
			try { DebugEnterSubRule(164);
			try { DebugEnterDecision(164, false);
			try
			{
				alt164 = dfa164.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(164); }
			switch (alt164)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:372:4: ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn
				{
				DebugLocation(372, 4);
				// JavaScript.g:372:4: ( LT )*
				try { DebugEnterSubRule(160);
				while (true)
				{
					int alt160=2;
					try { DebugEnterDecision(160, false);
					int LA160_1 = input.LA(1);

					if ((LA160_1==LT))
					{
						alt160 = 1;
					}


					} finally { DebugExitDecision(160); }
					switch ( alt160 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:4: LT
						{
						DebugLocation(372, 4);
						LT303=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3515); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT303);


						}
						break;

					default:
						goto loop160;
					}
				}

				loop160:
					;

				} finally { DebugExitSubRule(160); }

				DebugLocation(372, 8);
				char_literal304=(IToken)Match(input,77,Follow._77_in_conditionalExpressionNoIn3518); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_77.Add(char_literal304);

				DebugLocation(372, 12);
				// JavaScript.g:372:12: ( LT )*
				try { DebugEnterSubRule(161);
				while (true)
				{
					int alt161=2;
					try { DebugEnterDecision(161, false);
					int LA161_1 = input.LA(1);

					if ((LA161_1==LT))
					{
						alt161 = 1;
					}


					} finally { DebugExitDecision(161); }
					switch ( alt161 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:12: LT
						{
						DebugLocation(372, 12);
						LT305=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3520); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT305);


						}
						break;

					default:
						goto loop161;
					}
				}

				loop161:
					;

				} finally { DebugExitSubRule(161); }

				DebugLocation(372, 22);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn3525);
				iftrue=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(iftrue.Tree);
				DebugLocation(372, 48);
				// JavaScript.g:372:48: ( LT )*
				try { DebugEnterSubRule(162);
				while (true)
				{
					int alt162=2;
					try { DebugEnterDecision(162, false);
					int LA162_1 = input.LA(1);

					if ((LA162_1==LT))
					{
						alt162 = 1;
					}


					} finally { DebugExitDecision(162); }
					switch ( alt162 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:48: LT
						{
						DebugLocation(372, 48);
						LT306=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3527); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT306);


						}
						break;

					default:
						goto loop162;
					}
				}

				loop162:
					;

				} finally { DebugExitSubRule(162); }

				DebugLocation(372, 52);
				char_literal307=(IToken)Match(input,62,Follow._62_in_conditionalExpressionNoIn3530); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_62.Add(char_literal307);

				DebugLocation(372, 56);
				// JavaScript.g:372:56: ( LT )*
				try { DebugEnterSubRule(163);
				while (true)
				{
					int alt163=2;
					try { DebugEnterDecision(163, false);
					int LA163_1 = input.LA(1);

					if ((LA163_1==LT))
					{
						alt163 = 1;
					}


					} finally { DebugExitDecision(163); }
					switch ( alt163 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:372:56: LT
						{
						DebugLocation(372, 56);
						LT308=(IToken)Match(input,LT,Follow._LT_in_conditionalExpressionNoIn3532); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT308);


						}
						break;

					default:
						goto loop163;
					}
				}

				loop163:
					;

				} finally { DebugExitSubRule(163); }

				DebugLocation(372, 67);
				PushFollow(Follow._assignmentExpressionNoIn_in_conditionalExpressionNoIn3537);
				iffalse=assignmentExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpressionNoIn.Add(iffalse.Tree);


				{
				// AST REWRITE
				// elements: 77, logicalORExpressionNoIn, iftrue, iffalse
				// token labels: 
				// rule labels: iftrue, iffalse, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_iftrue=new RewriteRuleSubtreeStream(adaptor,"rule iftrue",iftrue!=null?iftrue.Tree:null);
				RewriteRuleSubtreeStream stream_iffalse=new RewriteRuleSubtreeStream(adaptor,"rule iffalse",iffalse!=null?iffalse.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 373:5: -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse)
				{
					DebugLocation(373, 8);
					// JavaScript.g:373:8: ^( '?' logicalORExpressionNoIn $iftrue $iffalse)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(373, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ConditionalExpression(stream_77.NextToken()), root_1);

					DebugLocation(373, 43);
					adaptor.AddChild(root_1, stream_logicalORExpressionNoIn.NextTree());
					DebugLocation(373, 68);
					adaptor.AddChild(root_1, stream_iftrue.NextTree());
					DebugLocation(373, 76);
					adaptor.AddChild(root_1, stream_iffalse.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:374:6: 
				{

				{
				// AST REWRITE
				// elements: logicalORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 374:6: -> logicalORExpressionNoIn
				{
					DebugLocation(374, 9);
					adaptor.AddChild(root_0, stream_logicalORExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(164); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalExpressionNoIn", 56);
			LeaveRule("conditionalExpressionNoIn", 56);
			LeaveRule_conditionalExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 56, conditionalExpressionNoIn_StartIndex); }

		}
		DebugLocation(376, 1);
		} finally { DebugExitRule(GrammarFileName, "conditionalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "conditionalExpressionNoIn"

	partial void EnterRule_logicalORExpression();
	partial void LeaveRule_logicalORExpression();
	// $ANTLR start "logicalORExpression"
	// JavaScript.g:378:1: logicalORExpression : logicalANDExpression ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression ) ;
	[GrammarRule("logicalORExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalORExpression()
	{
		EnterRule_logicalORExpression();
		EnterRule("logicalORExpression", 57);
		TraceIn("logicalORExpression", 57);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalORExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT310 = default(IToken);
		IToken string_literal311 = default(IToken);
		IToken LT312 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpression309 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpression313 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT310_tree = default(CommonTree);
		CommonTree string_literal311_tree = default(CommonTree);
		CommonTree LT312_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_113=new RewriteRuleITokenStream(adaptor,"token 113");
		RewriteRuleSubtreeStream stream_logicalANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpression");
		RewriteRuleSubtreeStream stream_logicalORExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpression");
		try { DebugEnterRule(GrammarFileName, "logicalORExpression");
		DebugLocation(378, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 57)) { return retval; }

			// JavaScript.g:379:2: ( logicalANDExpression ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:380:3: logicalANDExpression ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression )
			{
			DebugLocation(380, 3);
			PushFollow(Follow._logicalANDExpression_in_logicalORExpression3588);
			logicalANDExpression309=logicalANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalANDExpression.Add(logicalANDExpression309.Tree);
			DebugLocation(381, 3);
			// JavaScript.g:381:3: ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression )
			int alt167=2;
			try { DebugEnterSubRule(167);
			try { DebugEnterDecision(167, false);
			try
			{
				alt167 = dfa167.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(167); }
			switch (alt167)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:382:4: ( ( LT )* '||' ( LT )* logicalORExpression )
				{
				DebugLocation(382, 4);
				// JavaScript.g:382:4: ( ( LT )* '||' ( LT )* logicalORExpression )
				DebugEnterAlt(1);
				// JavaScript.g:382:5: ( LT )* '||' ( LT )* logicalORExpression
				{
				DebugLocation(382, 5);
				// JavaScript.g:382:5: ( LT )*
				try { DebugEnterSubRule(165);
				while (true)
				{
					int alt165=2;
					try { DebugEnterDecision(165, false);
					int LA165_1 = input.LA(1);

					if ((LA165_1==LT))
					{
						alt165 = 1;
					}


					} finally { DebugExitDecision(165); }
					switch ( alt165 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:382:5: LT
						{
						DebugLocation(382, 5);
						LT310=(IToken)Match(input,LT,Follow._LT_in_logicalORExpression3599); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT310);


						}
						break;

					default:
						goto loop165;
					}
				}

				loop165:
					;

				} finally { DebugExitSubRule(165); }

				DebugLocation(382, 9);
				string_literal311=(IToken)Match(input,113,Follow._113_in_logicalORExpression3602); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_113.Add(string_literal311);

				DebugLocation(382, 14);
				// JavaScript.g:382:14: ( LT )*
				try { DebugEnterSubRule(166);
				while (true)
				{
					int alt166=2;
					try { DebugEnterDecision(166, false);
					int LA166_1 = input.LA(1);

					if ((LA166_1==LT))
					{
						alt166 = 1;
					}


					} finally { DebugExitDecision(166); }
					switch ( alt166 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:382:14: LT
						{
						DebugLocation(382, 14);
						LT312=(IToken)Match(input,LT,Follow._LT_in_logicalORExpression3604); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT312);


						}
						break;

					default:
						goto loop166;
					}
				}

				loop166:
					;

				} finally { DebugExitSubRule(166); }

				DebugLocation(382, 18);
				PushFollow(Follow._logicalORExpression_in_logicalORExpression3607);
				logicalORExpression313=logicalORExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalORExpression.Add(logicalORExpression313.Tree);

				}



				{
				// AST REWRITE
				// elements: 113, logicalANDExpression, logicalORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 383:5: -> ^( '||' logicalANDExpression logicalORExpression )
				{
					DebugLocation(383, 8);
					// JavaScript.g:383:8: ^( '||' logicalANDExpression logicalORExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(383, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalOrExpression(stream_113.NextToken()), root_1);

					DebugLocation(383, 41);
					adaptor.AddChild(root_1, stream_logicalANDExpression.NextTree());
					DebugLocation(383, 62);
					adaptor.AddChild(root_1, stream_logicalORExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:384:6: 
				{

				{
				// AST REWRITE
				// elements: logicalANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 384:6: -> logicalANDExpression
				{
					DebugLocation(384, 9);
					adaptor.AddChild(root_0, stream_logicalANDExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(167); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpression", 57);
			LeaveRule("logicalORExpression", 57);
			LeaveRule_logicalORExpression();
			if (state.backtracking > 0) { Memoize(input, 57, logicalORExpression_StartIndex); }

		}
		DebugLocation(386, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpression"); }
		return retval;

	}
	// $ANTLR end "logicalORExpression"

	partial void EnterRule_logicalORExpressionNoIn();
	partial void LeaveRule_logicalORExpressionNoIn();
	// $ANTLR start "logicalORExpressionNoIn"
	// JavaScript.g:388:1: logicalORExpressionNoIn : logicalANDExpressionNoIn ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn ) ;
	[GrammarRule("logicalORExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalORExpressionNoIn()
	{
		EnterRule_logicalORExpressionNoIn();
		EnterRule("logicalORExpressionNoIn", 58);
		TraceIn("logicalORExpressionNoIn", 58);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalORExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT315 = default(IToken);
		IToken string_literal316 = default(IToken);
		IToken LT317 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpressionNoIn314 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalORExpressionNoIn318 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT315_tree = default(CommonTree);
		CommonTree string_literal316_tree = default(CommonTree);
		CommonTree LT317_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_113=new RewriteRuleITokenStream(adaptor,"token 113");
		RewriteRuleSubtreeStream stream_logicalANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpressionNoIn");
		RewriteRuleSubtreeStream stream_logicalORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalORExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "logicalORExpressionNoIn");
		DebugLocation(388, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 58)) { return retval; }

			// JavaScript.g:389:2: ( logicalANDExpressionNoIn ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:390:3: logicalANDExpressionNoIn ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn )
			{
			DebugLocation(390, 3);
			PushFollow(Follow._logicalANDExpressionNoIn_in_logicalORExpressionNoIn3655);
			logicalANDExpressionNoIn314=logicalANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_logicalANDExpressionNoIn.Add(logicalANDExpressionNoIn314.Tree);
			DebugLocation(391, 3);
			// JavaScript.g:391:3: ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn )
			int alt170=2;
			try { DebugEnterSubRule(170);
			try { DebugEnterDecision(170, false);
			try
			{
				alt170 = dfa170.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(170); }
			switch (alt170)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:392:4: ( ( LT )* '||' ( LT )* logicalORExpressionNoIn )
				{
				DebugLocation(392, 4);
				// JavaScript.g:392:4: ( ( LT )* '||' ( LT )* logicalORExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:392:5: ( LT )* '||' ( LT )* logicalORExpressionNoIn
				{
				DebugLocation(392, 5);
				// JavaScript.g:392:5: ( LT )*
				try { DebugEnterSubRule(168);
				while (true)
				{
					int alt168=2;
					try { DebugEnterDecision(168, false);
					int LA168_1 = input.LA(1);

					if ((LA168_1==LT))
					{
						alt168 = 1;
					}


					} finally { DebugExitDecision(168); }
					switch ( alt168 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:392:5: LT
						{
						DebugLocation(392, 5);
						LT315=(IToken)Match(input,LT,Follow._LT_in_logicalORExpressionNoIn3665); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT315);


						}
						break;

					default:
						goto loop168;
					}
				}

				loop168:
					;

				} finally { DebugExitSubRule(168); }

				DebugLocation(392, 9);
				string_literal316=(IToken)Match(input,113,Follow._113_in_logicalORExpressionNoIn3668); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_113.Add(string_literal316);

				DebugLocation(392, 14);
				// JavaScript.g:392:14: ( LT )*
				try { DebugEnterSubRule(169);
				while (true)
				{
					int alt169=2;
					try { DebugEnterDecision(169, false);
					int LA169_1 = input.LA(1);

					if ((LA169_1==LT))
					{
						alt169 = 1;
					}


					} finally { DebugExitDecision(169); }
					switch ( alt169 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:392:14: LT
						{
						DebugLocation(392, 14);
						LT317=(IToken)Match(input,LT,Follow._LT_in_logicalORExpressionNoIn3670); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT317);


						}
						break;

					default:
						goto loop169;
					}
				}

				loop169:
					;

				} finally { DebugExitSubRule(169); }

				DebugLocation(392, 18);
				PushFollow(Follow._logicalORExpressionNoIn_in_logicalORExpressionNoIn3673);
				logicalORExpressionNoIn318=logicalORExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalORExpressionNoIn.Add(logicalORExpressionNoIn318.Tree);

				}



				{
				// AST REWRITE
				// elements: 113, logicalANDExpressionNoIn, logicalORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 393:5: -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn )
				{
					DebugLocation(393, 8);
					// JavaScript.g:393:8: ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(393, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalOrExpression(stream_113.NextToken()), root_1);

					DebugLocation(393, 41);
					adaptor.AddChild(root_1, stream_logicalANDExpressionNoIn.NextTree());
					DebugLocation(393, 66);
					adaptor.AddChild(root_1, stream_logicalORExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:394:6: 
				{

				{
				// AST REWRITE
				// elements: logicalANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 394:6: -> logicalANDExpressionNoIn
				{
					DebugLocation(394, 9);
					adaptor.AddChild(root_0, stream_logicalANDExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(170); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalORExpressionNoIn", 58);
			LeaveRule("logicalORExpressionNoIn", 58);
			LeaveRule_logicalORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 58, logicalORExpressionNoIn_StartIndex); }

		}
		DebugLocation(396, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalORExpressionNoIn"

	partial void EnterRule_logicalANDExpression();
	partial void LeaveRule_logicalANDExpression();
	// $ANTLR start "logicalANDExpression"
	// JavaScript.g:398:1: logicalANDExpression : bitwiseORExpression ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression ) ;
	[GrammarRule("logicalANDExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpression()
	{
		EnterRule_logicalANDExpression();
		EnterRule("logicalANDExpression", 59);
		TraceIn("logicalANDExpression", 59);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalANDExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT320 = default(IToken);
		IToken string_literal321 = default(IToken);
		IToken LT322 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpression319 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpression323 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT320_tree = default(CommonTree);
		CommonTree string_literal321_tree = default(CommonTree);
		CommonTree LT322_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_bitwiseORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpression");
		RewriteRuleSubtreeStream stream_logicalANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpression");
		try { DebugEnterRule(GrammarFileName, "logicalANDExpression");
		DebugLocation(398, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 59)) { return retval; }

			// JavaScript.g:399:2: ( bitwiseORExpression ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:400:3: bitwiseORExpression ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression )
			{
			DebugLocation(400, 3);
			PushFollow(Follow._bitwiseORExpression_in_logicalANDExpression3721);
			bitwiseORExpression319=bitwiseORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseORExpression.Add(bitwiseORExpression319.Tree);
			DebugLocation(401, 3);
			// JavaScript.g:401:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression )
			int alt173=2;
			try { DebugEnterSubRule(173);
			try { DebugEnterDecision(173, false);
			try
			{
				alt173 = dfa173.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(173); }
			switch (alt173)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:402:4: ( ( LT )* '&&' ( LT )* logicalANDExpression )
				{
				DebugLocation(402, 4);
				// JavaScript.g:402:4: ( ( LT )* '&&' ( LT )* logicalANDExpression )
				DebugEnterAlt(1);
				// JavaScript.g:402:5: ( LT )* '&&' ( LT )* logicalANDExpression
				{
				DebugLocation(402, 5);
				// JavaScript.g:402:5: ( LT )*
				try { DebugEnterSubRule(171);
				while (true)
				{
					int alt171=2;
					try { DebugEnterDecision(171, false);
					int LA171_1 = input.LA(1);

					if ((LA171_1==LT))
					{
						alt171 = 1;
					}


					} finally { DebugExitDecision(171); }
					switch ( alt171 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:402:5: LT
						{
						DebugLocation(402, 5);
						LT320=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpression3732); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT320);


						}
						break;

					default:
						goto loop171;
					}
				}

				loop171:
					;

				} finally { DebugExitSubRule(171); }

				DebugLocation(402, 9);
				string_literal321=(IToken)Match(input,45,Follow._45_in_logicalANDExpression3735); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_45.Add(string_literal321);

				DebugLocation(402, 14);
				// JavaScript.g:402:14: ( LT )*
				try { DebugEnterSubRule(172);
				while (true)
				{
					int alt172=2;
					try { DebugEnterDecision(172, false);
					int LA172_1 = input.LA(1);

					if ((LA172_1==LT))
					{
						alt172 = 1;
					}


					} finally { DebugExitDecision(172); }
					switch ( alt172 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:402:14: LT
						{
						DebugLocation(402, 14);
						LT322=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpression3737); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT322);


						}
						break;

					default:
						goto loop172;
					}
				}

				loop172:
					;

				} finally { DebugExitSubRule(172); }

				DebugLocation(402, 18);
				PushFollow(Follow._logicalANDExpression_in_logicalANDExpression3740);
				logicalANDExpression323=logicalANDExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalANDExpression.Add(logicalANDExpression323.Tree);

				}



				{
				// AST REWRITE
				// elements: 45, bitwiseORExpression, logicalANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 403:5: -> ^( '&&' bitwiseORExpression logicalANDExpression )
				{
					DebugLocation(403, 8);
					// JavaScript.g:403:8: ^( '&&' bitwiseORExpression logicalANDExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(403, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalAndExpression(stream_45.NextToken()), root_1);

					DebugLocation(403, 42);
					adaptor.AddChild(root_1, stream_bitwiseORExpression.NextTree());
					DebugLocation(403, 62);
					adaptor.AddChild(root_1, stream_logicalANDExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:404:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 404:6: -> bitwiseORExpression
				{
					DebugLocation(404, 9);
					adaptor.AddChild(root_0, stream_bitwiseORExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(173); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpression", 59);
			LeaveRule("logicalANDExpression", 59);
			LeaveRule_logicalANDExpression();
			if (state.backtracking > 0) { Memoize(input, 59, logicalANDExpression_StartIndex); }

		}
		DebugLocation(406, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpression"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpression"

	partial void EnterRule_logicalANDExpressionNoIn();
	partial void LeaveRule_logicalANDExpressionNoIn();
	// $ANTLR start "logicalANDExpressionNoIn"
	// JavaScript.g:408:1: logicalANDExpressionNoIn : bitwiseORExpressionNoIn ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn ) ;
	[GrammarRule("logicalANDExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpressionNoIn()
	{
		EnterRule_logicalANDExpressionNoIn();
		EnterRule("logicalANDExpressionNoIn", 60);
		TraceIn("logicalANDExpressionNoIn", 60);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int logicalANDExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT325 = default(IToken);
		IToken string_literal326 = default(IToken);
		IToken LT327 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpressionNoIn324 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> logicalANDExpressionNoIn328 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT325_tree = default(CommonTree);
		CommonTree string_literal326_tree = default(CommonTree);
		CommonTree LT327_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_45=new RewriteRuleITokenStream(adaptor,"token 45");
		RewriteRuleSubtreeStream stream_bitwiseORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpressionNoIn");
		RewriteRuleSubtreeStream stream_logicalANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule logicalANDExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "logicalANDExpressionNoIn");
		DebugLocation(408, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 60)) { return retval; }

			// JavaScript.g:409:2: ( bitwiseORExpressionNoIn ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:410:3: bitwiseORExpressionNoIn ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn )
			{
			DebugLocation(410, 3);
			PushFollow(Follow._bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn3788);
			bitwiseORExpressionNoIn324=bitwiseORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseORExpressionNoIn.Add(bitwiseORExpressionNoIn324.Tree);
			DebugLocation(411, 3);
			// JavaScript.g:411:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn )
			int alt176=2;
			try { DebugEnterSubRule(176);
			try { DebugEnterDecision(176, false);
			try
			{
				alt176 = dfa176.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(176); }
			switch (alt176)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:412:4: ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn )
				{
				DebugLocation(412, 4);
				// JavaScript.g:412:4: ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:412:5: ( LT )* '&&' ( LT )* logicalANDExpressionNoIn
				{
				DebugLocation(412, 5);
				// JavaScript.g:412:5: ( LT )*
				try { DebugEnterSubRule(174);
				while (true)
				{
					int alt174=2;
					try { DebugEnterDecision(174, false);
					int LA174_1 = input.LA(1);

					if ((LA174_1==LT))
					{
						alt174 = 1;
					}


					} finally { DebugExitDecision(174); }
					switch ( alt174 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:412:5: LT
						{
						DebugLocation(412, 5);
						LT325=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpressionNoIn3798); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT325);


						}
						break;

					default:
						goto loop174;
					}
				}

				loop174:
					;

				} finally { DebugExitSubRule(174); }

				DebugLocation(412, 9);
				string_literal326=(IToken)Match(input,45,Follow._45_in_logicalANDExpressionNoIn3801); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_45.Add(string_literal326);

				DebugLocation(412, 14);
				// JavaScript.g:412:14: ( LT )*
				try { DebugEnterSubRule(175);
				while (true)
				{
					int alt175=2;
					try { DebugEnterDecision(175, false);
					int LA175_1 = input.LA(1);

					if ((LA175_1==LT))
					{
						alt175 = 1;
					}


					} finally { DebugExitDecision(175); }
					switch ( alt175 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:412:14: LT
						{
						DebugLocation(412, 14);
						LT327=(IToken)Match(input,LT,Follow._LT_in_logicalANDExpressionNoIn3803); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT327);


						}
						break;

					default:
						goto loop175;
					}
				}

				loop175:
					;

				} finally { DebugExitSubRule(175); }

				DebugLocation(412, 18);
				PushFollow(Follow._logicalANDExpressionNoIn_in_logicalANDExpressionNoIn3806);
				logicalANDExpressionNoIn328=logicalANDExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_logicalANDExpressionNoIn.Add(logicalANDExpressionNoIn328.Tree);

				}



				{
				// AST REWRITE
				// elements: 45, bitwiseORExpressionNoIn, logicalANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 413:5: -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn )
				{
					DebugLocation(413, 8);
					// JavaScript.g:413:8: ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(413, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LogicalAndExpression(stream_45.NextToken()), root_1);

					DebugLocation(413, 42);
					adaptor.AddChild(root_1, stream_bitwiseORExpressionNoIn.NextTree());
					DebugLocation(413, 66);
					adaptor.AddChild(root_1, stream_logicalANDExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:414:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 414:6: -> bitwiseORExpressionNoIn
				{
					DebugLocation(414, 9);
					adaptor.AddChild(root_0, stream_bitwiseORExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(176); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logicalANDExpressionNoIn", 60);
			LeaveRule("logicalANDExpressionNoIn", 60);
			LeaveRule_logicalANDExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 60, logicalANDExpressionNoIn_StartIndex); }

		}
		DebugLocation(416, 1);
		} finally { DebugExitRule(GrammarFileName, "logicalANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "logicalANDExpressionNoIn"

	partial void EnterRule_bitwiseORExpression();
	partial void LeaveRule_bitwiseORExpression();
	// $ANTLR start "bitwiseORExpression"
	// JavaScript.g:418:1: bitwiseORExpression : bitwiseXORExpression ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression ) ;
	[GrammarRule("bitwiseORExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpression()
	{
		EnterRule_bitwiseORExpression();
		EnterRule("bitwiseORExpression", 61);
		TraceIn("bitwiseORExpression", 61);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseORExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT330 = default(IToken);
		IToken char_literal331 = default(IToken);
		IToken LT332 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpression329 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpression333 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT330_tree = default(CommonTree);
		CommonTree char_literal331_tree = default(CommonTree);
		CommonTree LT332_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_111=new RewriteRuleITokenStream(adaptor,"token 111");
		RewriteRuleSubtreeStream stream_bitwiseXORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpression");
		RewriteRuleSubtreeStream stream_bitwiseORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpression");
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpression");
		DebugLocation(418, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 61)) { return retval; }

			// JavaScript.g:419:2: ( bitwiseXORExpression ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:420:3: bitwiseXORExpression ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression )
			{
			DebugLocation(420, 3);
			PushFollow(Follow._bitwiseXORExpression_in_bitwiseORExpression3854);
			bitwiseXORExpression329=bitwiseXORExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseXORExpression.Add(bitwiseXORExpression329.Tree);
			DebugLocation(421, 3);
			// JavaScript.g:421:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression )
			int alt179=2;
			try { DebugEnterSubRule(179);
			try { DebugEnterDecision(179, false);
			try
			{
				alt179 = dfa179.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(179); }
			switch (alt179)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:422:4: ( ( LT )* '|' ( LT )* bitwiseORExpression )
				{
				DebugLocation(422, 4);
				// JavaScript.g:422:4: ( ( LT )* '|' ( LT )* bitwiseORExpression )
				DebugEnterAlt(1);
				// JavaScript.g:422:5: ( LT )* '|' ( LT )* bitwiseORExpression
				{
				DebugLocation(422, 5);
				// JavaScript.g:422:5: ( LT )*
				try { DebugEnterSubRule(177);
				while (true)
				{
					int alt177=2;
					try { DebugEnterDecision(177, false);
					int LA177_1 = input.LA(1);

					if ((LA177_1==LT))
					{
						alt177 = 1;
					}


					} finally { DebugExitDecision(177); }
					switch ( alt177 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:422:5: LT
						{
						DebugLocation(422, 5);
						LT330=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpression3864); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT330);


						}
						break;

					default:
						goto loop177;
					}
				}

				loop177:
					;

				} finally { DebugExitSubRule(177); }

				DebugLocation(422, 9);
				char_literal331=(IToken)Match(input,111,Follow._111_in_bitwiseORExpression3867); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_111.Add(char_literal331);

				DebugLocation(422, 13);
				// JavaScript.g:422:13: ( LT )*
				try { DebugEnterSubRule(178);
				while (true)
				{
					int alt178=2;
					try { DebugEnterDecision(178, false);
					int LA178_1 = input.LA(1);

					if ((LA178_1==LT))
					{
						alt178 = 1;
					}


					} finally { DebugExitDecision(178); }
					switch ( alt178 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:422:13: LT
						{
						DebugLocation(422, 13);
						LT332=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpression3869); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT332);


						}
						break;

					default:
						goto loop178;
					}
				}

				loop178:
					;

				} finally { DebugExitSubRule(178); }

				DebugLocation(422, 17);
				PushFollow(Follow._bitwiseORExpression_in_bitwiseORExpression3872);
				bitwiseORExpression333=bitwiseORExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseORExpression.Add(bitwiseORExpression333.Tree);

				}



				{
				// AST REWRITE
				// elements: 111, bitwiseXORExpression, bitwiseORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 423:5: -> ^( '|' bitwiseXORExpression bitwiseORExpression )
				{
					DebugLocation(423, 8);
					// JavaScript.g:423:8: ^( '|' bitwiseXORExpression bitwiseORExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(423, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrExpression(stream_111.NextToken()), root_1);

					DebugLocation(423, 40);
					adaptor.AddChild(root_1, stream_bitwiseXORExpression.NextTree());
					DebugLocation(423, 61);
					adaptor.AddChild(root_1, stream_bitwiseORExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:424:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseXORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 424:6: -> bitwiseXORExpression
				{
					DebugLocation(424, 9);
					adaptor.AddChild(root_0, stream_bitwiseXORExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(179); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpression", 61);
			LeaveRule("bitwiseORExpression", 61);
			LeaveRule_bitwiseORExpression();
			if (state.backtracking > 0) { Memoize(input, 61, bitwiseORExpression_StartIndex); }

		}
		DebugLocation(426, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpression"

	partial void EnterRule_bitwiseORExpressionNoIn();
	partial void LeaveRule_bitwiseORExpressionNoIn();
	// $ANTLR start "bitwiseORExpressionNoIn"
	// JavaScript.g:428:1: bitwiseORExpressionNoIn : bitwiseXORExpressionNoIn ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn ) ;
	[GrammarRule("bitwiseORExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpressionNoIn()
	{
		EnterRule_bitwiseORExpressionNoIn();
		EnterRule("bitwiseORExpressionNoIn", 62);
		TraceIn("bitwiseORExpressionNoIn", 62);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseORExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT335 = default(IToken);
		IToken char_literal336 = default(IToken);
		IToken LT337 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpressionNoIn334 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseORExpressionNoIn338 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT335_tree = default(CommonTree);
		CommonTree char_literal336_tree = default(CommonTree);
		CommonTree LT337_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_111=new RewriteRuleITokenStream(adaptor,"token 111");
		RewriteRuleSubtreeStream stream_bitwiseXORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpressionNoIn");
		RewriteRuleSubtreeStream stream_bitwiseORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseORExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "bitwiseORExpressionNoIn");
		DebugLocation(428, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 62)) { return retval; }

			// JavaScript.g:429:2: ( bitwiseXORExpressionNoIn ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:430:3: bitwiseXORExpressionNoIn ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn )
			{
			DebugLocation(430, 3);
			PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3920);
			bitwiseXORExpressionNoIn334=bitwiseXORExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseXORExpressionNoIn.Add(bitwiseXORExpressionNoIn334.Tree);
			DebugLocation(431, 3);
			// JavaScript.g:431:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn )
			int alt182=2;
			try { DebugEnterSubRule(182);
			try { DebugEnterDecision(182, false);
			try
			{
				alt182 = dfa182.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(182); }
			switch (alt182)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:432:4: ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn )
				{
				DebugLocation(432, 4);
				// JavaScript.g:432:4: ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:432:5: ( LT )* '|' ( LT )* bitwiseORExpressionNoIn
				{
				DebugLocation(432, 5);
				// JavaScript.g:432:5: ( LT )*
				try { DebugEnterSubRule(180);
				while (true)
				{
					int alt180=2;
					try { DebugEnterDecision(180, false);
					int LA180_1 = input.LA(1);

					if ((LA180_1==LT))
					{
						alt180 = 1;
					}


					} finally { DebugExitDecision(180); }
					switch ( alt180 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:432:5: LT
						{
						DebugLocation(432, 5);
						LT335=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpressionNoIn3930); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT335);


						}
						break;

					default:
						goto loop180;
					}
				}

				loop180:
					;

				} finally { DebugExitSubRule(180); }

				DebugLocation(432, 9);
				char_literal336=(IToken)Match(input,111,Follow._111_in_bitwiseORExpressionNoIn3933); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_111.Add(char_literal336);

				DebugLocation(432, 13);
				// JavaScript.g:432:13: ( LT )*
				try { DebugEnterSubRule(181);
				while (true)
				{
					int alt181=2;
					try { DebugEnterDecision(181, false);
					int LA181_1 = input.LA(1);

					if ((LA181_1==LT))
					{
						alt181 = 1;
					}


					} finally { DebugExitDecision(181); }
					switch ( alt181 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:432:13: LT
						{
						DebugLocation(432, 13);
						LT337=(IToken)Match(input,LT,Follow._LT_in_bitwiseORExpressionNoIn3935); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT337);


						}
						break;

					default:
						goto loop181;
					}
				}

				loop181:
					;

				} finally { DebugExitSubRule(181); }

				DebugLocation(432, 17);
				PushFollow(Follow._bitwiseORExpressionNoIn_in_bitwiseORExpressionNoIn3938);
				bitwiseORExpressionNoIn338=bitwiseORExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseORExpressionNoIn.Add(bitwiseORExpressionNoIn338.Tree);

				}



				{
				// AST REWRITE
				// elements: 111, bitwiseXORExpressionNoIn, bitwiseORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 433:5: -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn )
				{
					DebugLocation(433, 8);
					// JavaScript.g:433:8: ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(433, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseOrExpression(stream_111.NextToken()), root_1);

					DebugLocation(433, 40);
					adaptor.AddChild(root_1, stream_bitwiseXORExpressionNoIn.NextTree());
					DebugLocation(433, 65);
					adaptor.AddChild(root_1, stream_bitwiseORExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:434:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseXORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 434:6: -> bitwiseXORExpressionNoIn
				{
					DebugLocation(434, 9);
					adaptor.AddChild(root_0, stream_bitwiseXORExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(182); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseORExpressionNoIn", 62);
			LeaveRule("bitwiseORExpressionNoIn", 62);
			LeaveRule_bitwiseORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 62, bitwiseORExpressionNoIn_StartIndex); }

		}
		DebugLocation(436, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseORExpressionNoIn"

	partial void EnterRule_bitwiseXORExpression();
	partial void LeaveRule_bitwiseXORExpression();
	// $ANTLR start "bitwiseXORExpression"
	// JavaScript.g:438:1: bitwiseXORExpression : bitwiseANDExpression ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression ) ;
	[GrammarRule("bitwiseXORExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpression()
	{
		EnterRule_bitwiseXORExpression();
		EnterRule("bitwiseXORExpression", 63);
		TraceIn("bitwiseXORExpression", 63);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseXORExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT340 = default(IToken);
		IToken char_literal341 = default(IToken);
		IToken LT342 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpression339 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpression343 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT340_tree = default(CommonTree);
		CommonTree char_literal341_tree = default(CommonTree);
		CommonTree LT342_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleSubtreeStream stream_bitwiseANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpression");
		RewriteRuleSubtreeStream stream_bitwiseXORExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpression");
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpression");
		DebugLocation(438, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 63)) { return retval; }

			// JavaScript.g:439:2: ( bitwiseANDExpression ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:440:3: bitwiseANDExpression ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression )
			{
			DebugLocation(440, 3);
			PushFollow(Follow._bitwiseANDExpression_in_bitwiseXORExpression3986);
			bitwiseANDExpression339=bitwiseANDExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseANDExpression.Add(bitwiseANDExpression339.Tree);
			DebugLocation(441, 3);
			// JavaScript.g:441:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression )
			int alt185=2;
			try { DebugEnterSubRule(185);
			try { DebugEnterDecision(185, false);
			try
			{
				alt185 = dfa185.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(185); }
			switch (alt185)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:442:4: ( ( LT )* '^' ( LT )* bitwiseXORExpression )
				{
				DebugLocation(442, 4);
				// JavaScript.g:442:4: ( ( LT )* '^' ( LT )* bitwiseXORExpression )
				DebugEnterAlt(1);
				// JavaScript.g:442:5: ( LT )* '^' ( LT )* bitwiseXORExpression
				{
				DebugLocation(442, 5);
				// JavaScript.g:442:5: ( LT )*
				try { DebugEnterSubRule(183);
				while (true)
				{
					int alt183=2;
					try { DebugEnterDecision(183, false);
					int LA183_1 = input.LA(1);

					if ((LA183_1==LT))
					{
						alt183 = 1;
					}


					} finally { DebugExitDecision(183); }
					switch ( alt183 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:442:5: LT
						{
						DebugLocation(442, 5);
						LT340=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpression3997); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT340);


						}
						break;

					default:
						goto loop183;
					}
				}

				loop183:
					;

				} finally { DebugExitSubRule(183); }

				DebugLocation(442, 9);
				char_literal341=(IToken)Match(input,80,Follow._80_in_bitwiseXORExpression4000); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_80.Add(char_literal341);

				DebugLocation(442, 13);
				// JavaScript.g:442:13: ( LT )*
				try { DebugEnterSubRule(184);
				while (true)
				{
					int alt184=2;
					try { DebugEnterDecision(184, false);
					int LA184_1 = input.LA(1);

					if ((LA184_1==LT))
					{
						alt184 = 1;
					}


					} finally { DebugExitDecision(184); }
					switch ( alt184 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:442:13: LT
						{
						DebugLocation(442, 13);
						LT342=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpression4002); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT342);


						}
						break;

					default:
						goto loop184;
					}
				}

				loop184:
					;

				} finally { DebugExitSubRule(184); }

				DebugLocation(442, 17);
				PushFollow(Follow._bitwiseXORExpression_in_bitwiseXORExpression4005);
				bitwiseXORExpression343=bitwiseXORExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseXORExpression.Add(bitwiseXORExpression343.Tree);

				}



				{
				// AST REWRITE
				// elements: 80, bitwiseANDExpression, bitwiseXORExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 443:5: -> ^( '^' bitwiseANDExpression bitwiseXORExpression )
				{
					DebugLocation(443, 8);
					// JavaScript.g:443:8: ^( '^' bitwiseANDExpression bitwiseXORExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(443, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorExpression(stream_80.NextToken()), root_1);

					DebugLocation(443, 41);
					adaptor.AddChild(root_1, stream_bitwiseANDExpression.NextTree());
					DebugLocation(443, 62);
					adaptor.AddChild(root_1, stream_bitwiseXORExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:444:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 444:6: -> bitwiseANDExpression
				{
					DebugLocation(444, 9);
					adaptor.AddChild(root_0, stream_bitwiseANDExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(185); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpression", 63);
			LeaveRule("bitwiseXORExpression", 63);
			LeaveRule_bitwiseXORExpression();
			if (state.backtracking > 0) { Memoize(input, 63, bitwiseXORExpression_StartIndex); }

		}
		DebugLocation(446, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpression"

	partial void EnterRule_bitwiseXORExpressionNoIn();
	partial void LeaveRule_bitwiseXORExpressionNoIn();
	// $ANTLR start "bitwiseXORExpressionNoIn"
	// JavaScript.g:448:1: bitwiseXORExpressionNoIn : bitwiseANDExpressionNoIn ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn ) ;
	[GrammarRule("bitwiseXORExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpressionNoIn()
	{
		EnterRule_bitwiseXORExpressionNoIn();
		EnterRule("bitwiseXORExpressionNoIn", 64);
		TraceIn("bitwiseXORExpressionNoIn", 64);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseXORExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT345 = default(IToken);
		IToken char_literal346 = default(IToken);
		IToken LT347 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpressionNoIn344 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseXORExpressionNoIn348 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT345_tree = default(CommonTree);
		CommonTree char_literal346_tree = default(CommonTree);
		CommonTree LT347_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_80=new RewriteRuleITokenStream(adaptor,"token 80");
		RewriteRuleSubtreeStream stream_bitwiseANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpressionNoIn");
		RewriteRuleSubtreeStream stream_bitwiseXORExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseXORExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "bitwiseXORExpressionNoIn");
		DebugLocation(448, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 64)) { return retval; }

			// JavaScript.g:449:2: ( bitwiseANDExpressionNoIn ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:450:3: bitwiseANDExpressionNoIn ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn )
			{
			DebugLocation(450, 3);
			PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4053);
			bitwiseANDExpressionNoIn344=bitwiseANDExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_bitwiseANDExpressionNoIn.Add(bitwiseANDExpressionNoIn344.Tree);
			DebugLocation(451, 3);
			// JavaScript.g:451:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn )
			int alt188=2;
			try { DebugEnterSubRule(188);
			try { DebugEnterDecision(188, false);
			try
			{
				alt188 = dfa188.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(188); }
			switch (alt188)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:452:4: ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn )
				{
				DebugLocation(452, 4);
				// JavaScript.g:452:4: ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:452:5: ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn
				{
				DebugLocation(452, 5);
				// JavaScript.g:452:5: ( LT )*
				try { DebugEnterSubRule(186);
				while (true)
				{
					int alt186=2;
					try { DebugEnterDecision(186, false);
					int LA186_1 = input.LA(1);

					if ((LA186_1==LT))
					{
						alt186 = 1;
					}


					} finally { DebugExitDecision(186); }
					switch ( alt186 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:452:5: LT
						{
						DebugLocation(452, 5);
						LT345=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpressionNoIn4063); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT345);


						}
						break;

					default:
						goto loop186;
					}
				}

				loop186:
					;

				} finally { DebugExitSubRule(186); }

				DebugLocation(452, 9);
				char_literal346=(IToken)Match(input,80,Follow._80_in_bitwiseXORExpressionNoIn4066); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_80.Add(char_literal346);

				DebugLocation(452, 13);
				// JavaScript.g:452:13: ( LT )*
				try { DebugEnterSubRule(187);
				while (true)
				{
					int alt187=2;
					try { DebugEnterDecision(187, false);
					int LA187_1 = input.LA(1);

					if ((LA187_1==LT))
					{
						alt187 = 1;
					}


					} finally { DebugExitDecision(187); }
					switch ( alt187 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:452:13: LT
						{
						DebugLocation(452, 13);
						LT347=(IToken)Match(input,LT,Follow._LT_in_bitwiseXORExpressionNoIn4068); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT347);


						}
						break;

					default:
						goto loop187;
					}
				}

				loop187:
					;

				} finally { DebugExitSubRule(187); }

				DebugLocation(452, 17);
				PushFollow(Follow._bitwiseXORExpressionNoIn_in_bitwiseXORExpressionNoIn4071);
				bitwiseXORExpressionNoIn348=bitwiseXORExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseXORExpressionNoIn.Add(bitwiseXORExpressionNoIn348.Tree);

				}



				{
				// AST REWRITE
				// elements: 80, bitwiseANDExpressionNoIn, bitwiseXORExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 453:5: -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn )
				{
					DebugLocation(453, 8);
					// JavaScript.g:453:8: ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(453, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseXorExpression(stream_80.NextToken()), root_1);

					DebugLocation(453, 41);
					adaptor.AddChild(root_1, stream_bitwiseANDExpressionNoIn.NextTree());
					DebugLocation(453, 66);
					adaptor.AddChild(root_1, stream_bitwiseXORExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:454:6: 
				{

				{
				// AST REWRITE
				// elements: bitwiseANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 454:6: -> bitwiseANDExpressionNoIn
				{
					DebugLocation(454, 9);
					adaptor.AddChild(root_0, stream_bitwiseANDExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(188); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseXORExpressionNoIn", 64);
			LeaveRule("bitwiseXORExpressionNoIn", 64);
			LeaveRule_bitwiseXORExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 64, bitwiseXORExpressionNoIn_StartIndex); }

		}
		DebugLocation(456, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseXORExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseXORExpressionNoIn"

	partial void EnterRule_bitwiseANDExpression();
	partial void LeaveRule_bitwiseANDExpression();
	// $ANTLR start "bitwiseANDExpression"
	// JavaScript.g:458:1: bitwiseANDExpression : equalityExpression ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression ) ;
	[GrammarRule("bitwiseANDExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpression()
	{
		EnterRule_bitwiseANDExpression();
		EnterRule("bitwiseANDExpression", 65);
		TraceIn("bitwiseANDExpression", 65);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseANDExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT350 = default(IToken);
		IToken char_literal351 = default(IToken);
		IToken LT352 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpression349 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpression353 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT350_tree = default(CommonTree);
		CommonTree char_literal351_tree = default(CommonTree);
		CommonTree LT352_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpression");
		RewriteRuleSubtreeStream stream_bitwiseANDExpression=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpression");
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpression");
		DebugLocation(458, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 65)) { return retval; }

			// JavaScript.g:459:2: ( equalityExpression ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:460:3: equalityExpression ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression )
			{
			DebugLocation(460, 3);
			PushFollow(Follow._equalityExpression_in_bitwiseANDExpression4119);
			equalityExpression349=equalityExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_equalityExpression.Add(equalityExpression349.Tree);
			DebugLocation(461, 3);
			// JavaScript.g:461:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression )
			int alt191=2;
			try { DebugEnterSubRule(191);
			try { DebugEnterDecision(191, false);
			try
			{
				alt191 = dfa191.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(191); }
			switch (alt191)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:462:4: ( ( LT )* '&' ( LT )* bitwiseANDExpression )
				{
				DebugLocation(462, 4);
				// JavaScript.g:462:4: ( ( LT )* '&' ( LT )* bitwiseANDExpression )
				DebugEnterAlt(1);
				// JavaScript.g:462:5: ( LT )* '&' ( LT )* bitwiseANDExpression
				{
				DebugLocation(462, 5);
				// JavaScript.g:462:5: ( LT )*
				try { DebugEnterSubRule(189);
				while (true)
				{
					int alt189=2;
					try { DebugEnterDecision(189, false);
					int LA189_1 = input.LA(1);

					if ((LA189_1==LT))
					{
						alt189 = 1;
					}


					} finally { DebugExitDecision(189); }
					switch ( alt189 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:462:5: LT
						{
						DebugLocation(462, 5);
						LT350=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpression4130); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT350);


						}
						break;

					default:
						goto loop189;
					}
				}

				loop189:
					;

				} finally { DebugExitSubRule(189); }

				DebugLocation(462, 9);
				char_literal351=(IToken)Match(input,46,Follow._46_in_bitwiseANDExpression4133); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_46.Add(char_literal351);

				DebugLocation(462, 13);
				// JavaScript.g:462:13: ( LT )*
				try { DebugEnterSubRule(190);
				while (true)
				{
					int alt190=2;
					try { DebugEnterDecision(190, false);
					int LA190_1 = input.LA(1);

					if ((LA190_1==LT))
					{
						alt190 = 1;
					}


					} finally { DebugExitDecision(190); }
					switch ( alt190 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:462:13: LT
						{
						DebugLocation(462, 13);
						LT352=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpression4135); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT352);


						}
						break;

					default:
						goto loop190;
					}
				}

				loop190:
					;

				} finally { DebugExitSubRule(190); }

				DebugLocation(462, 17);
				PushFollow(Follow._bitwiseANDExpression_in_bitwiseANDExpression4138);
				bitwiseANDExpression353=bitwiseANDExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseANDExpression.Add(bitwiseANDExpression353.Tree);

				}



				{
				// AST REWRITE
				// elements: 46, equalityExpression, bitwiseANDExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 463:5: -> ^( '&' equalityExpression bitwiseANDExpression )
				{
					DebugLocation(463, 8);
					// JavaScript.g:463:8: ^( '&' equalityExpression bitwiseANDExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(463, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndExpression(stream_46.NextToken()), root_1);

					DebugLocation(463, 41);
					adaptor.AddChild(root_1, stream_equalityExpression.NextTree());
					DebugLocation(463, 60);
					adaptor.AddChild(root_1, stream_bitwiseANDExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:464:6: 
				{

				{
				// AST REWRITE
				// elements: equalityExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 464:6: -> equalityExpression
				{
					DebugLocation(464, 9);
					adaptor.AddChild(root_0, stream_equalityExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(191); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpression", 65);
			LeaveRule("bitwiseANDExpression", 65);
			LeaveRule_bitwiseANDExpression();
			if (state.backtracking > 0) { Memoize(input, 65, bitwiseANDExpression_StartIndex); }

		}
		DebugLocation(466, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpression"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpression"

	partial void EnterRule_bitwiseANDExpressionNoIn();
	partial void LeaveRule_bitwiseANDExpressionNoIn();
	// $ANTLR start "bitwiseANDExpressionNoIn"
	// JavaScript.g:468:1: bitwiseANDExpressionNoIn : equalityExpressionNoIn ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn ) ;
	[GrammarRule("bitwiseANDExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpressionNoIn()
	{
		EnterRule_bitwiseANDExpressionNoIn();
		EnterRule("bitwiseANDExpressionNoIn", 66);
		TraceIn("bitwiseANDExpressionNoIn", 66);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int bitwiseANDExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT355 = default(IToken);
		IToken char_literal356 = default(IToken);
		IToken LT357 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpressionNoIn354 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> bitwiseANDExpressionNoIn358 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT355_tree = default(CommonTree);
		CommonTree char_literal356_tree = default(CommonTree);
		CommonTree LT357_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_46=new RewriteRuleITokenStream(adaptor,"token 46");
		RewriteRuleSubtreeStream stream_equalityExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpressionNoIn");
		RewriteRuleSubtreeStream stream_bitwiseANDExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule bitwiseANDExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "bitwiseANDExpressionNoIn");
		DebugLocation(468, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 66)) { return retval; }

			// JavaScript.g:469:2: ( equalityExpressionNoIn ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:470:3: equalityExpressionNoIn ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn )
			{
			DebugLocation(470, 3);
			PushFollow(Follow._equalityExpressionNoIn_in_bitwiseANDExpressionNoIn4186);
			equalityExpressionNoIn354=equalityExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_equalityExpressionNoIn.Add(equalityExpressionNoIn354.Tree);
			DebugLocation(471, 3);
			// JavaScript.g:471:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn )
			int alt194=2;
			try { DebugEnterSubRule(194);
			try { DebugEnterDecision(194, false);
			try
			{
				alt194 = dfa194.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(194); }
			switch (alt194)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:472:4: ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn )
				{
				DebugLocation(472, 4);
				// JavaScript.g:472:4: ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:472:5: ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn
				{
				DebugLocation(472, 5);
				// JavaScript.g:472:5: ( LT )*
				try { DebugEnterSubRule(192);
				while (true)
				{
					int alt192=2;
					try { DebugEnterDecision(192, false);
					int LA192_1 = input.LA(1);

					if ((LA192_1==LT))
					{
						alt192 = 1;
					}


					} finally { DebugExitDecision(192); }
					switch ( alt192 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:472:5: LT
						{
						DebugLocation(472, 5);
						LT355=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpressionNoIn4196); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT355);


						}
						break;

					default:
						goto loop192;
					}
				}

				loop192:
					;

				} finally { DebugExitSubRule(192); }

				DebugLocation(472, 9);
				char_literal356=(IToken)Match(input,46,Follow._46_in_bitwiseANDExpressionNoIn4199); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_46.Add(char_literal356);

				DebugLocation(472, 13);
				// JavaScript.g:472:13: ( LT )*
				try { DebugEnterSubRule(193);
				while (true)
				{
					int alt193=2;
					try { DebugEnterDecision(193, false);
					int LA193_1 = input.LA(1);

					if ((LA193_1==LT))
					{
						alt193 = 1;
					}


					} finally { DebugExitDecision(193); }
					switch ( alt193 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:472:13: LT
						{
						DebugLocation(472, 13);
						LT357=(IToken)Match(input,LT,Follow._LT_in_bitwiseANDExpressionNoIn4201); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT357);


						}
						break;

					default:
						goto loop193;
					}
				}

				loop193:
					;

				} finally { DebugExitSubRule(193); }

				DebugLocation(472, 17);
				PushFollow(Follow._bitwiseANDExpressionNoIn_in_bitwiseANDExpressionNoIn4204);
				bitwiseANDExpressionNoIn358=bitwiseANDExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_bitwiseANDExpressionNoIn.Add(bitwiseANDExpressionNoIn358.Tree);

				}



				{
				// AST REWRITE
				// elements: 46, equalityExpressionNoIn, bitwiseANDExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 473:5: -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn )
				{
					DebugLocation(473, 8);
					// JavaScript.g:473:8: ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(473, 10);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseAndExpression(stream_46.NextToken()), root_1);

					DebugLocation(473, 41);
					adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());
					DebugLocation(473, 64);
					adaptor.AddChild(root_1, stream_bitwiseANDExpressionNoIn.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:474:6: 
				{

				{
				// AST REWRITE
				// elements: equalityExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 474:6: -> equalityExpressionNoIn
				{
					DebugLocation(474, 9);
					adaptor.AddChild(root_0, stream_equalityExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(194); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("bitwiseANDExpressionNoIn", 66);
			LeaveRule("bitwiseANDExpressionNoIn", 66);
			LeaveRule_bitwiseANDExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 66, bitwiseANDExpressionNoIn_StartIndex); }

		}
		DebugLocation(476, 1);
		} finally { DebugExitRule(GrammarFileName, "bitwiseANDExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "bitwiseANDExpressionNoIn"

	partial void EnterRule_equalityExpression();
	partial void LeaveRule_equalityExpression();
	// $ANTLR start "equalityExpression"
	// JavaScript.g:478:1: equalityExpression : rel= relationalExpression ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression ) ;
	[GrammarRule("equalityExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityExpression()
	{
		EnterRule_equalityExpression();
		EnterRule("equalityExpression", 67);
		TraceIn("equalityExpression", 67);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int equalityExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT359 = default(IToken);
		IToken LT360 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> rel = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> eq = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT359_tree = default(CommonTree);
		CommonTree LT360_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_relationalExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpression");
		RewriteRuleSubtreeStream stream_equalityExpression=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpression");
		try { DebugEnterRule(GrammarFileName, "equalityExpression");
		DebugLocation(478, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 67)) { return retval; }

			// JavaScript.g:479:2: (rel= relationalExpression ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:480:3: rel= relationalExpression ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression )
			{
			DebugLocation(480, 6);
			PushFollow(Follow._relationalExpression_in_equalityExpression4253);
			rel=relationalExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalExpression.Add(rel.Tree);
			DebugLocation(481, 3);
			// JavaScript.g:481:3: ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression )
			int alt198=2;
			try { DebugEnterSubRule(198);
			try { DebugEnterDecision(198, false);
			try
			{
				alt198 = dfa198.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(198); }
			switch (alt198)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:482:4: ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression )
				{
				DebugLocation(482, 4);
				// JavaScript.g:482:4: ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression )
				DebugEnterAlt(1);
				// JavaScript.g:482:5: ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression
				{
				DebugLocation(482, 5);
				// JavaScript.g:482:5: ( LT )*
				try { DebugEnterSubRule(195);
				while (true)
				{
					int alt195=2;
					try { DebugEnterDecision(195, false);
					int LA195_1 = input.LA(1);

					if ((LA195_1==LT))
					{
						alt195 = 1;
					}


					} finally { DebugExitDecision(195); }
					switch ( alt195 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:482:5: LT
						{
						DebugLocation(482, 5);
						LT359=(IToken)Match(input,LT,Follow._LT_in_equalityExpression4264); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT359);


						}
						break;

					default:
						goto loop195;
					}
				}

				loop195:
					;

				} finally { DebugExitSubRule(195); }

				DebugLocation(482, 9);
				// JavaScript.g:482:9: (op= '==' |op= '!=' |op= '===' |op= '!==' )
				int alt196=4;
				try { DebugEnterSubRule(196);
				try { DebugEnterDecision(196, false);
				switch (input.LA(1))
				{
				case 69:
					{
					alt196 = 1;
					}
					break;
				case 41:
					{
					alt196 = 2;
					}
					break;
				case 70:
					{
					alt196 = 3;
					}
					break;
				case 42:
					{
					alt196 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 196, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(196); }
				switch (alt196)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:482:10: op= '=='
					{
					DebugLocation(482, 12);
					op=(IToken)Match(input,69,Follow._69_in_equalityExpression4270); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_69.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:482:20: op= '!='
					{
					DebugLocation(482, 22);
					op=(IToken)Match(input,41,Follow._41_in_equalityExpression4276); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_41.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:482:30: op= '==='
					{
					DebugLocation(482, 32);
					op=(IToken)Match(input,70,Follow._70_in_equalityExpression4282); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_70.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:482:41: op= '!=='
					{
					DebugLocation(482, 43);
					op=(IToken)Match(input,42,Follow._42_in_equalityExpression4288); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(196); }

				DebugLocation(482, 51);
				// JavaScript.g:482:51: ( LT )*
				try { DebugEnterSubRule(197);
				while (true)
				{
					int alt197=2;
					try { DebugEnterDecision(197, false);
					int LA197_1 = input.LA(1);

					if ((LA197_1==LT))
					{
						alt197 = 1;
					}


					} finally { DebugExitDecision(197); }
					switch ( alt197 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:482:51: LT
						{
						DebugLocation(482, 51);
						LT360=(IToken)Match(input,LT,Follow._LT_in_equalityExpression4291); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT360);


						}
						break;

					default:
						goto loop197;
					}
				}

				loop197:
					;

				} finally { DebugExitSubRule(197); }

				DebugLocation(482, 57);
				PushFollow(Follow._equalityExpression_in_equalityExpression4296);
				eq=equalityExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_equalityExpression.Add(eq.Tree);

				}



				{
				// AST REWRITE
				// elements: 69, rel, eq, 41, rel, eq, 70, rel, eq, 42, rel, eq
				// token labels: 
				// rule labels: rel, eq, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_rel=new RewriteRuleSubtreeStream(adaptor,"rule rel",rel!=null?rel.Tree:null);
				RewriteRuleSubtreeStream stream_eq=new RewriteRuleSubtreeStream(adaptor,"rule eq",eq!=null?eq.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 483:17: -> { op.Text == \"==\" }? ^( '==' $rel $eq)
				if ( op.Text == "=="  )
				{
					DebugLocation(483, 42);
					// JavaScript.g:483:42: ^( '==' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(483, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new EqualToExpression(stream_69.NextToken()), root_1);

					DebugLocation(483, 74);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(483, 79);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 484:17: -> { op.Text == \"!=\" }? ^( '!=' $rel $eq)
				if ( op.Text == "!="  )
				{
					DebugLocation(484, 42);
					// JavaScript.g:484:42: ^( '!=' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(484, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NotEqualToExpression(stream_41.NextToken()), root_1);

					DebugLocation(484, 77);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(484, 82);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 485:17: -> { op.Text == \"===\" }? ^( '===' $rel $eq)
				if ( op.Text == "===" )
				{
					DebugLocation(485, 42);
					// JavaScript.g:485:42: ^( '===' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(485, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new StrictlyEqualToExpression(stream_70.NextToken()), root_1);

					DebugLocation(485, 83);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(485, 88);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 486:17: -> { op.Text == \"!==\" }? ^( '!==' $rel $eq)
				if ( op.Text == "!==" )
				{
					DebugLocation(486, 42);
					// JavaScript.g:486:42: ^( '!==' $rel $eq)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(486, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NotStrictlyEqualToExpression(stream_42.NextToken()), root_1);

					DebugLocation(486, 86);
					adaptor.AddChild(root_1, stream_rel.NextTree());
					DebugLocation(486, 91);
					adaptor.AddChild(root_1, stream_eq.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 487:8: ->
				{
					DebugLocation(488, 13);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:488:17: 
				{

				{
				// AST REWRITE
				// elements: relationalExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 488:17: -> relationalExpression
				{
					DebugLocation(488, 20);
					adaptor.AddChild(root_0, stream_relationalExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(198); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpression", 67);
			LeaveRule("equalityExpression", 67);
			LeaveRule_equalityExpression();
			if (state.backtracking > 0) { Memoize(input, 67, equalityExpression_StartIndex); }

		}
		DebugLocation(490, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpression"); }
		return retval;

	}
	// $ANTLR end "equalityExpression"

	partial void EnterRule_equalityExpressionNoIn();
	partial void LeaveRule_equalityExpressionNoIn();
	// $ANTLR start "equalityExpressionNoIn"
	// JavaScript.g:492:1: equalityExpressionNoIn : relationalExpressionNoIn ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn ) ;
	[GrammarRule("equalityExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> equalityExpressionNoIn()
	{
		EnterRule_equalityExpressionNoIn();
		EnterRule("equalityExpressionNoIn", 68);
		TraceIn("equalityExpressionNoIn", 68);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int equalityExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT362 = default(IToken);
		IToken string_literal363 = default(IToken);
		IToken string_literal364 = default(IToken);
		IToken string_literal365 = default(IToken);
		IToken string_literal366 = default(IToken);
		IToken LT367 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpressionNoIn361 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> equalityExpressionNoIn368 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT362_tree = default(CommonTree);
		CommonTree string_literal363_tree = default(CommonTree);
		CommonTree string_literal364_tree = default(CommonTree);
		CommonTree string_literal365_tree = default(CommonTree);
		CommonTree string_literal366_tree = default(CommonTree);
		CommonTree LT367_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_69=new RewriteRuleITokenStream(adaptor,"token 69");
		RewriteRuleITokenStream stream_41=new RewriteRuleITokenStream(adaptor,"token 41");
		RewriteRuleITokenStream stream_70=new RewriteRuleITokenStream(adaptor,"token 70");
		RewriteRuleITokenStream stream_42=new RewriteRuleITokenStream(adaptor,"token 42");
		RewriteRuleSubtreeStream stream_relationalExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpressionNoIn");
		RewriteRuleSubtreeStream stream_equalityExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule equalityExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "equalityExpressionNoIn");
		DebugLocation(492, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 68)) { return retval; }

			// JavaScript.g:493:2: ( relationalExpressionNoIn ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn ) )
			DebugEnterAlt(1);
			// JavaScript.g:494:3: relationalExpressionNoIn ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn )
			{
			DebugLocation(494, 3);
			PushFollow(Follow._relationalExpressionNoIn_in_equalityExpressionNoIn4483);
			relationalExpressionNoIn361=relationalExpressionNoIn();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_relationalExpressionNoIn.Add(relationalExpressionNoIn361.Tree);
			DebugLocation(495, 3);
			// JavaScript.g:495:3: ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn )
			int alt202=2;
			try { DebugEnterSubRule(202);
			try { DebugEnterDecision(202, false);
			try
			{
				alt202 = dfa202.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(202); }
			switch (alt202)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:496:4: ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn )
				{
				DebugLocation(496, 4);
				// JavaScript.g:496:4: ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:497:5: ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn
				{
				DebugLocation(497, 5);
				// JavaScript.g:497:5: ( LT )*
				try { DebugEnterSubRule(199);
				while (true)
				{
					int alt199=2;
					try { DebugEnterDecision(199, false);
					int LA199_1 = input.LA(1);

					if ((LA199_1==LT))
					{
						alt199 = 1;
					}


					} finally { DebugExitDecision(199); }
					switch ( alt199 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:497:5: LT
						{
						DebugLocation(497, 5);
						LT362=(IToken)Match(input,LT,Follow._LT_in_equalityExpressionNoIn4498); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT362);


						}
						break;

					default:
						goto loop199;
					}
				}

				loop199:
					;

				} finally { DebugExitSubRule(199); }

				DebugLocation(498, 5);
				// JavaScript.g:498:5: ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) )
				int alt200=4;
				try { DebugEnterSubRule(200);
				try { DebugEnterDecision(200, false);
				switch (input.LA(1))
				{
				case 69:
					{
					alt200 = 1;
					}
					break;
				case 41:
					{
					alt200 = 2;
					}
					break;
				case 70:
					{
					alt200 = 3;
					}
					break;
				case 42:
					{
					alt200 = 4;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 200, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(200); }
				switch (alt200)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:499:6: '=='
					{
					DebugLocation(499, 6);
					string_literal363=(IToken)Match(input,69,Follow._69_in_equalityExpressionNoIn4513); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_69.Add(string_literal363);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 499:11: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(499, 14);
						// JavaScript.g:499:14: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(499, 16);
						root_1 = (CommonTree)adaptor.BecomeRoot(new EqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(499, 45);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(499, 70);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:500:8: '!='
					{
					DebugLocation(500, 8);
					string_literal364=(IToken)Match(input,41,Follow._41_in_equalityExpressionNoIn4537); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_41.Add(string_literal364);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 500:13: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(500, 16);
						// JavaScript.g:500:16: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(500, 18);
						root_1 = (CommonTree)adaptor.BecomeRoot(new NotEqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(500, 50);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(500, 75);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:501:8: '==='
					{
					DebugLocation(501, 8);
					string_literal365=(IToken)Match(input,70,Follow._70_in_equalityExpressionNoIn4561); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_70.Add(string_literal365);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 501:14: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(501, 17);
						// JavaScript.g:501:17: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(501, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot(new StrictlyEqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(501, 56);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(501, 81);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:502:8: '!=='
					{
					DebugLocation(502, 8);
					string_literal366=(IToken)Match(input,42,Follow._42_in_equalityExpressionNoIn4585); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_42.Add(string_literal366);



					{
					// AST REWRITE
					// elements: 69, relationalExpressionNoIn, equalityExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 502:14: -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
					{
						DebugLocation(502, 17);
						// JavaScript.g:502:17: ^( '==' relationalExpressionNoIn equalityExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(502, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot(new NotStrictlyEqualToExpression(stream_69.NextToken()), root_1);

						DebugLocation(502, 59);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());
						DebugLocation(502, 84);
						adaptor.AddChild(root_1, stream_equalityExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(200); }

				DebugLocation(503, 7);
				// JavaScript.g:503:7: ( LT )*
				try { DebugEnterSubRule(201);
				while (true)
				{
					int alt201=2;
					try { DebugEnterDecision(201, false);
					int LA201_1 = input.LA(1);

					if ((LA201_1==LT))
					{
						alt201 = 1;
					}


					} finally { DebugExitDecision(201); }
					switch ( alt201 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:503:7: LT
						{
						DebugLocation(503, 7);
						LT367=(IToken)Match(input,LT,Follow._LT_in_equalityExpressionNoIn4608); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT367);


						}
						break;

					default:
						goto loop201;
					}
				}

				loop201:
					;

				} finally { DebugExitSubRule(201); }

				DebugLocation(503, 11);
				PushFollow(Follow._equalityExpressionNoIn_in_equalityExpressionNoIn4611);
				equalityExpressionNoIn368=equalityExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_equalityExpressionNoIn.Add(equalityExpressionNoIn368.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:505:6: 
				{

				{
				// AST REWRITE
				// elements: relationalExpressionNoIn
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 505:6: -> relationalExpressionNoIn
				{
					DebugLocation(505, 9);
					adaptor.AddChild(root_0, stream_relationalExpressionNoIn.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(202); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("equalityExpressionNoIn", 68);
			LeaveRule("equalityExpressionNoIn", 68);
			LeaveRule_equalityExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 68, equalityExpressionNoIn_StartIndex); }

		}
		DebugLocation(507, 1);
		} finally { DebugExitRule(GrammarFileName, "equalityExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "equalityExpressionNoIn"

	partial void EnterRule_relationalExpression();
	partial void LeaveRule_relationalExpression();
	// $ANTLR start "relationalExpression"
	// JavaScript.g:509:1: relationalExpression : se= shiftExpression ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se) ;
	[GrammarRule("relationalExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalExpression()
	{
		EnterRule_relationalExpression();
		EnterRule("relationalExpression", 69);
		TraceIn("relationalExpression", 69);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relationalExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT369 = default(IToken);
		IToken LT370 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> se = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> rel = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT369_tree = default(CommonTree);
		CommonTree LT370_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_96=new RewriteRuleITokenStream(adaptor,"token 96");
		RewriteRuleITokenStream stream_95=new RewriteRuleITokenStream(adaptor,"token 95");
		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,"rule shiftExpression");
		RewriteRuleSubtreeStream stream_relationalExpression=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpression");
		try { DebugEnterRule(GrammarFileName, "relationalExpression");
		DebugLocation(509, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 69)) { return retval; }

			// JavaScript.g:510:2: (se= shiftExpression ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se) )
			DebugEnterAlt(1);
			// JavaScript.g:511:3: se= shiftExpression ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se)
			{
			DebugLocation(511, 5);
			PushFollow(Follow._shiftExpression_in_relationalExpression4646);
			se=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_shiftExpression.Add(se.Tree);
			DebugLocation(512, 3);
			// JavaScript.g:512:3: ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se)
			int alt206=2;
			try { DebugEnterSubRule(206);
			try { DebugEnterDecision(206, false);
			try
			{
				alt206 = dfa206.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(206); }
			switch (alt206)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:513:4: ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression )
				{
				DebugLocation(513, 4);
				// JavaScript.g:513:4: ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression )
				DebugEnterAlt(1);
				// JavaScript.g:513:5: ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression
				{
				DebugLocation(513, 5);
				// JavaScript.g:513:5: ( LT )*
				try { DebugEnterSubRule(203);
				while (true)
				{
					int alt203=2;
					try { DebugEnterDecision(203, false);
					int LA203_1 = input.LA(1);

					if ((LA203_1==LT))
					{
						alt203 = 1;
					}


					} finally { DebugExitDecision(203); }
					switch ( alt203 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:513:5: LT
						{
						DebugLocation(513, 5);
						LT369=(IToken)Match(input,LT,Follow._LT_in_relationalExpression4657); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT369);


						}
						break;

					default:
						goto loop203;
					}
				}

				loop203:
					;

				} finally { DebugExitSubRule(203); }

				DebugLocation(513, 9);
				// JavaScript.g:513:9: (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' )
				int alt204=6;
				try { DebugEnterSubRule(204);
				try { DebugEnterDecision(204, false);
				switch (input.LA(1))
				{
				case 64:
					{
					alt204 = 1;
					}
					break;
				case 71:
					{
					alt204 = 2;
					}
					break;
				case 67:
					{
					alt204 = 3;
					}
					break;
				case 72:
					{
					alt204 = 4;
					}
					break;
				case 96:
					{
					alt204 = 5;
					}
					break;
				case 95:
					{
					alt204 = 6;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 204, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(204); }
				switch (alt204)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:513:10: op= '<'
					{
					DebugLocation(513, 12);
					op=(IToken)Match(input,64,Follow._64_in_relationalExpression4663); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_64.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:513:19: op= '>'
					{
					DebugLocation(513, 21);
					op=(IToken)Match(input,71,Follow._71_in_relationalExpression4669); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:513:28: op= '<='
					{
					DebugLocation(513, 30);
					op=(IToken)Match(input,67,Follow._67_in_relationalExpression4675); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:513:38: op= '>='
					{
					DebugLocation(513, 40);
					op=(IToken)Match(input,72,Follow._72_in_relationalExpression4681); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(op);


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// JavaScript.g:513:48: op= 'instanceof'
					{
					DebugLocation(513, 50);
					op=(IToken)Match(input,96,Follow._96_in_relationalExpression4687); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_96.Add(op);


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// JavaScript.g:513:66: op= 'in'
					{
					DebugLocation(513, 68);
					op=(IToken)Match(input,95,Follow._95_in_relationalExpression4693); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_95.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(204); }

				DebugLocation(513, 75);
				// JavaScript.g:513:75: ( LT )*
				try { DebugEnterSubRule(205);
				while (true)
				{
					int alt205=2;
					try { DebugEnterDecision(205, false);
					int LA205_1 = input.LA(1);

					if ((LA205_1==LT))
					{
						alt205 = 1;
					}


					} finally { DebugExitDecision(205); }
					switch ( alt205 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:513:75: LT
						{
						DebugLocation(513, 75);
						LT370=(IToken)Match(input,LT,Follow._LT_in_relationalExpression4696); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT370);


						}
						break;

					default:
						goto loop205;
					}
				}

				loop205:
					;

				} finally { DebugExitSubRule(205); }

				DebugLocation(513, 82);
				PushFollow(Follow._relationalExpression_in_relationalExpression4701);
				rel=relationalExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_relationalExpression.Add(rel.Tree);

				}



				{
				// AST REWRITE
				// elements: 64, se, rel, 71, se, rel, 67, se, rel, 72, se, rel, 96, se, rel, 95, se, rel
				// token labels: 
				// rule labels: se, rel, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_se=new RewriteRuleSubtreeStream(adaptor,"rule se",se!=null?se.Tree:null);
				RewriteRuleSubtreeStream stream_rel=new RewriteRuleSubtreeStream(adaptor,"rule rel",rel!=null?rel.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 514:17: -> { op.Text == \"<\" }? ^( '<' $se $rel)
				if ( op.Text == "<"          )
				{
					DebugLocation(514, 49);
					// JavaScript.g:514:49: ^( '<' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(514, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanExpression(stream_64.NextToken()), root_1);

					DebugLocation(514, 81);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(514, 85);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 515:17: -> { op.Text == \">\" }? ^( '>' $se $rel)
				if ( op.Text == ">"          )
				{
					DebugLocation(515, 49);
					// JavaScript.g:515:49: ^( '>' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(515, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanExpression(stream_71.NextToken()), root_1);

					DebugLocation(515, 84);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(515, 88);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 516:17: -> { op.Text == \"<=\" }? ^( '<=' $se $rel)
				if ( op.Text == "<="         )
				{
					DebugLocation(516, 49);
					// JavaScript.g:516:49: ^( '<=' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(516, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanOrEqualToExpression(stream_67.NextToken()), root_1);

					DebugLocation(516, 91);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(516, 95);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 517:17: -> { op.Text == \">=\" }? ^( '>=' $se $rel)
				if ( op.Text == ">="         )
				{
					DebugLocation(517, 49);
					// JavaScript.g:517:49: ^( '>=' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(517, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanOrEqualToExpression(stream_72.NextToken()), root_1);

					DebugLocation(517, 94);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(517, 98);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 518:17: -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel)
				if ( op.Text == "instanceof" )
				{
					DebugLocation(518, 49);
					// JavaScript.g:518:49: ^( 'instanceof' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(518, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new InstanceOfExpression(stream_96.NextToken()), root_1);

					DebugLocation(518, 92);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(518, 96);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 519:17: -> { op.Text == \"in\" }? ^( 'in' $se $rel)
				if ( op.Text == "in"         )
				{
					DebugLocation(519, 49);
					// JavaScript.g:519:49: ^( 'in' $se $rel)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(519, 51);
					root_1 = (CommonTree)adaptor.BecomeRoot(new InExpression(stream_95.NextToken()), root_1);

					DebugLocation(519, 76);
					adaptor.AddChild(root_1, stream_se.NextTree());
					DebugLocation(519, 80);
					adaptor.AddChild(root_1, stream_rel.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 520:17: ->
				{
					DebugLocation(521, 4);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:521:8: 
				{

				{
				// AST REWRITE
				// elements: se
				// token labels: 
				// rule labels: se, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_se=new RewriteRuleSubtreeStream(adaptor,"rule se",se!=null?se.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 521:8: -> $se
				{
					DebugLocation(521, 12);
					adaptor.AddChild(root_0, stream_se.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(206); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpression", 69);
			LeaveRule("relationalExpression", 69);
			LeaveRule_relationalExpression();
			if (state.backtracking > 0) { Memoize(input, 69, relationalExpression_StartIndex); }

		}
		DebugLocation(523, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpression"); }
		return retval;

	}
	// $ANTLR end "relationalExpression"

	partial void EnterRule_relationalExpressionNoIn();
	partial void LeaveRule_relationalExpressionNoIn();
	// $ANTLR start "relationalExpressionNoIn"
	// JavaScript.g:525:1: relationalExpressionNoIn : shiftExpression ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression ) ;
	[GrammarRule("relationalExpressionNoIn")]
	private AstParserRuleReturnScope<CommonTree, IToken> relationalExpressionNoIn()
	{
		EnterRule_relationalExpressionNoIn();
		EnterRule("relationalExpressionNoIn", 70);
		TraceIn("relationalExpressionNoIn", 70);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int relationalExpressionNoIn_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT372 = default(IToken);
		IToken char_literal373 = default(IToken);
		IToken char_literal374 = default(IToken);
		IToken string_literal375 = default(IToken);
		IToken string_literal376 = default(IToken);
		IToken string_literal377 = default(IToken);
		IToken LT378 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> shiftExpression371 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> relationalExpressionNoIn379 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT372_tree = default(CommonTree);
		CommonTree char_literal373_tree = default(CommonTree);
		CommonTree char_literal374_tree = default(CommonTree);
		CommonTree string_literal375_tree = default(CommonTree);
		CommonTree string_literal376_tree = default(CommonTree);
		CommonTree string_literal377_tree = default(CommonTree);
		CommonTree LT378_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_64=new RewriteRuleITokenStream(adaptor,"token 64");
		RewriteRuleITokenStream stream_71=new RewriteRuleITokenStream(adaptor,"token 71");
		RewriteRuleITokenStream stream_67=new RewriteRuleITokenStream(adaptor,"token 67");
		RewriteRuleITokenStream stream_72=new RewriteRuleITokenStream(adaptor,"token 72");
		RewriteRuleITokenStream stream_96=new RewriteRuleITokenStream(adaptor,"token 96");
		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,"rule shiftExpression");
		RewriteRuleSubtreeStream stream_relationalExpressionNoIn=new RewriteRuleSubtreeStream(adaptor,"rule relationalExpressionNoIn");
		try { DebugEnterRule(GrammarFileName, "relationalExpressionNoIn");
		DebugLocation(525, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 70)) { return retval; }

			// JavaScript.g:526:2: ( shiftExpression ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:527:3: shiftExpression ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression )
			{
			DebugLocation(527, 3);
			PushFollow(Follow._shiftExpression_in_relationalExpressionNoIn4960);
			shiftExpression371=shiftExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_shiftExpression.Add(shiftExpression371.Tree);
			DebugLocation(528, 3);
			// JavaScript.g:528:3: ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression )
			int alt210=2;
			try { DebugEnterSubRule(210);
			try { DebugEnterDecision(210, false);
			try
			{
				alt210 = dfa210.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(210); }
			switch (alt210)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:529:4: ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn )
				{
				DebugLocation(529, 4);
				// JavaScript.g:529:4: ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn )
				DebugEnterAlt(1);
				// JavaScript.g:530:5: ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn
				{
				DebugLocation(530, 5);
				// JavaScript.g:530:5: ( LT )*
				try { DebugEnterSubRule(207);
				while (true)
				{
					int alt207=2;
					try { DebugEnterDecision(207, false);
					int LA207_1 = input.LA(1);

					if ((LA207_1==LT))
					{
						alt207 = 1;
					}


					} finally { DebugExitDecision(207); }
					switch ( alt207 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:530:5: LT
						{
						DebugLocation(530, 5);
						LT372=(IToken)Match(input,LT,Follow._LT_in_relationalExpressionNoIn4976); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT372);


						}
						break;

					default:
						goto loop207;
					}
				}

				loop207:
					;

				} finally { DebugExitSubRule(207); }

				DebugLocation(531, 5);
				// JavaScript.g:531:5: ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) )
				int alt208=5;
				try { DebugEnterSubRule(208);
				try { DebugEnterDecision(208, false);
				switch (input.LA(1))
				{
				case 64:
					{
					alt208 = 1;
					}
					break;
				case 71:
					{
					alt208 = 2;
					}
					break;
				case 67:
					{
					alt208 = 3;
					}
					break;
				case 72:
					{
					alt208 = 4;
					}
					break;
				case 96:
					{
					alt208 = 5;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 208, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(208); }
				switch (alt208)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:532:6: '<'
					{
					DebugLocation(532, 6);
					char_literal373=(IToken)Match(input,64,Follow._64_in_relationalExpressionNoIn4991); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_64.Add(char_literal373);



					{
					// AST REWRITE
					// elements: 64, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 532:14: -> ^( '<' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(532, 17);
						// JavaScript.g:532:17: ^( '<' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(532, 19);
						root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanExpression(stream_64.NextToken()), root_1);

						DebugLocation(532, 48);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(532, 64);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:533:8: '>'
					{
					DebugLocation(533, 8);
					char_literal374=(IToken)Match(input,71,Follow._71_in_relationalExpressionNoIn5019); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_71.Add(char_literal374);



					{
					// AST REWRITE
					// elements: 71, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 533:15: -> ^( '>' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(533, 18);
						// JavaScript.g:533:18: ^( '>' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(533, 20);
						root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanExpression(stream_71.NextToken()), root_1);

						DebugLocation(533, 52);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(533, 68);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:534:8: '<='
					{
					DebugLocation(534, 8);
					string_literal375=(IToken)Match(input,67,Follow._67_in_relationalExpressionNoIn5046); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_67.Add(string_literal375);



					{
					// AST REWRITE
					// elements: 67, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 534:16: -> ^( '<=' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(534, 19);
						// JavaScript.g:534:19: ^( '<=' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(534, 21);
						root_1 = (CommonTree)adaptor.BecomeRoot(new LessThanOrEqualToExpression(stream_67.NextToken()), root_1);

						DebugLocation(534, 60);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(534, 76);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:535:8: '>='
					{
					DebugLocation(535, 8);
					string_literal376=(IToken)Match(input,72,Follow._72_in_relationalExpressionNoIn5073); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_72.Add(string_literal376);



					{
					// AST REWRITE
					// elements: 72, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 535:16: -> ^( '>=' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(535, 19);
						// JavaScript.g:535:19: ^( '>=' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(535, 21);
						root_1 = (CommonTree)adaptor.BecomeRoot(new GreaterThanOrEqualToExpression(stream_72.NextToken()), root_1);

						DebugLocation(535, 63);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(535, 79);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;
				case 5:
					DebugEnterAlt(5);
					// JavaScript.g:536:8: 'instanceof'
					{
					DebugLocation(536, 8);
					string_literal377=(IToken)Match(input,96,Follow._96_in_relationalExpressionNoIn5100); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_96.Add(string_literal377);



					{
					// AST REWRITE
					// elements: 96, shiftExpression, relationalExpressionNoIn
					// token labels: 
					// rule labels: retval
					// token list labels: 
					// rule list labels: 
					// wildcard labels: 
					if (state.backtracking == 0) {
					retval.Tree = root_0;
					RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

					root_0 = (CommonTree)adaptor.Nil();
					// 536:22: -> ^( 'instanceof' shiftExpression relationalExpressionNoIn )
					{
						DebugLocation(536, 25);
						// JavaScript.g:536:25: ^( 'instanceof' shiftExpression relationalExpressionNoIn )
						{
						CommonTree root_1 = (CommonTree)adaptor.Nil();
						DebugLocation(536, 27);
						root_1 = (CommonTree)adaptor.BecomeRoot(new InstanceOfExpression(stream_96.NextToken()), root_1);

						DebugLocation(536, 67);
						adaptor.AddChild(root_1, stream_shiftExpression.NextTree());
						DebugLocation(536, 83);
						adaptor.AddChild(root_1, stream_relationalExpressionNoIn.NextTree());

						adaptor.AddChild(root_0, root_1);
						}

					}

					retval.Tree = root_0;
					}
					}

					}
					break;

				}
				} finally { DebugExitSubRule(208); }

				DebugLocation(537, 7);
				// JavaScript.g:537:7: ( LT )*
				try { DebugEnterSubRule(209);
				while (true)
				{
					int alt209=2;
					try { DebugEnterDecision(209, false);
					int LA209_1 = input.LA(1);

					if ((LA209_1==LT))
					{
						alt209 = 1;
					}


					} finally { DebugExitDecision(209); }
					switch ( alt209 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:537:7: LT
						{
						DebugLocation(537, 7);
						LT378=(IToken)Match(input,LT,Follow._LT_in_relationalExpressionNoIn5124); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT378);


						}
						break;

					default:
						goto loop209;
					}
				}

				loop209:
					;

				} finally { DebugExitSubRule(209); }

				DebugLocation(537, 11);
				PushFollow(Follow._relationalExpressionNoIn_in_relationalExpressionNoIn5127);
				relationalExpressionNoIn379=relationalExpressionNoIn();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_relationalExpressionNoIn.Add(relationalExpressionNoIn379.Tree);

				}


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:539:6: 
				{

				{
				// AST REWRITE
				// elements: shiftExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 539:6: -> shiftExpression
				{
					DebugLocation(539, 9);
					adaptor.AddChild(root_0, stream_shiftExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(210); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relationalExpressionNoIn", 70);
			LeaveRule("relationalExpressionNoIn", 70);
			LeaveRule_relationalExpressionNoIn();
			if (state.backtracking > 0) { Memoize(input, 70, relationalExpressionNoIn_StartIndex); }

		}
		DebugLocation(541, 1);
		} finally { DebugExitRule(GrammarFileName, "relationalExpressionNoIn"); }
		return retval;

	}
	// $ANTLR end "relationalExpressionNoIn"

	partial void EnterRule_shiftExpression();
	partial void LeaveRule_shiftExpression();
	// $ANTLR start "shiftExpression"
	// JavaScript.g:543:1: shiftExpression : add= additiveExpression ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add) ;
	[GrammarRule("shiftExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> shiftExpression()
	{
		EnterRule_shiftExpression();
		EnterRule("shiftExpression", 71);
		TraceIn("shiftExpression", 71);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int shiftExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT380 = default(IToken);
		IToken LT381 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> shift = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT380_tree = default(CommonTree);
		CommonTree LT381_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_65=new RewriteRuleITokenStream(adaptor,"token 65");
		RewriteRuleITokenStream stream_73=new RewriteRuleITokenStream(adaptor,"token 73");
		RewriteRuleITokenStream stream_75=new RewriteRuleITokenStream(adaptor,"token 75");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		RewriteRuleSubtreeStream stream_shiftExpression=new RewriteRuleSubtreeStream(adaptor,"rule shiftExpression");
		try { DebugEnterRule(GrammarFileName, "shiftExpression");
		DebugLocation(543, 4);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 71)) { return retval; }

			// JavaScript.g:544:2: (add= additiveExpression ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add) )
			DebugEnterAlt(1);
			// JavaScript.g:545:9: add= additiveExpression ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add)
			{
			DebugLocation(545, 12);
			PushFollow(Follow._additiveExpression_in_shiftExpression5167);
			add=additiveExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_additiveExpression.Add(add.Tree);
			DebugLocation(546, 9);
			// JavaScript.g:546:9: ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add)
			int alt214=2;
			try { DebugEnterSubRule(214);
			try { DebugEnterDecision(214, false);
			try
			{
				alt214 = dfa214.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(214); }
			switch (alt214)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:547:13: ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression )
				{
				DebugLocation(547, 13);
				// JavaScript.g:547:13: ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression )
				DebugEnterAlt(1);
				// JavaScript.g:547:14: ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression
				{
				DebugLocation(547, 14);
				// JavaScript.g:547:14: ( LT )*
				try { DebugEnterSubRule(211);
				while (true)
				{
					int alt211=2;
					try { DebugEnterDecision(211, false);
					int LA211_1 = input.LA(1);

					if ((LA211_1==LT))
					{
						alt211 = 1;
					}


					} finally { DebugExitDecision(211); }
					switch ( alt211 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:547:14: LT
						{
						DebugLocation(547, 14);
						LT380=(IToken)Match(input,LT,Follow._LT_in_shiftExpression5193); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT380);


						}
						break;

					default:
						goto loop211;
					}
				}

				loop211:
					;

				} finally { DebugExitSubRule(211); }

				DebugLocation(547, 18);
				// JavaScript.g:547:18: (op= '<<' |op= '>>' |op= '>>>' )
				int alt212=3;
				try { DebugEnterSubRule(212);
				try { DebugEnterDecision(212, false);
				switch (input.LA(1))
				{
				case 65:
					{
					alt212 = 1;
					}
					break;
				case 73:
					{
					alt212 = 2;
					}
					break;
				case 75:
					{
					alt212 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 212, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(212); }
				switch (alt212)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:547:19: op= '<<'
					{
					DebugLocation(547, 21);
					op=(IToken)Match(input,65,Follow._65_in_shiftExpression5199); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_65.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:547:29: op= '>>'
					{
					DebugLocation(547, 31);
					op=(IToken)Match(input,73,Follow._73_in_shiftExpression5205); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_73.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:547:39: op= '>>>'
					{
					DebugLocation(547, 41);
					op=(IToken)Match(input,75,Follow._75_in_shiftExpression5211); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_75.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(212); }

				DebugLocation(547, 49);
				// JavaScript.g:547:49: ( LT )*
				try { DebugEnterSubRule(213);
				while (true)
				{
					int alt213=2;
					try { DebugEnterDecision(213, false);
					int LA213_1 = input.LA(1);

					if ((LA213_1==LT))
					{
						alt213 = 1;
					}


					} finally { DebugExitDecision(213); }
					switch ( alt213 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:547:49: LT
						{
						DebugLocation(547, 49);
						LT381=(IToken)Match(input,LT,Follow._LT_in_shiftExpression5214); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT381);


						}
						break;

					default:
						goto loop213;
					}
				}

				loop213:
					;

				} finally { DebugExitSubRule(213); }

				DebugLocation(547, 58);
				PushFollow(Follow._shiftExpression_in_shiftExpression5219);
				shift=shiftExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_shiftExpression.Add(shift.Tree);

				}



				{
				// AST REWRITE
				// elements: 65, add, shift, 73, add, shift, 75, add, shift
				// token labels: 
				// rule labels: add, shift, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_add=new RewriteRuleSubtreeStream(adaptor,"rule add",add!=null?add.Tree:null);
				RewriteRuleSubtreeStream stream_shift=new RewriteRuleSubtreeStream(adaptor,"rule shift",shift!=null?shift.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 548:17: -> { op.Text == \"<<\" }? ^( '<<' $add $shift)
				if ( op.Text == "<<"  )
				{
					DebugLocation(548, 42);
					// JavaScript.g:548:42: ^( '<<' $add $shift)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(548, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftLeftExpression(stream_65.NextToken()), root_1);

					DebugLocation(548, 76);
					adaptor.AddChild(root_1, stream_add.NextTree());
					DebugLocation(548, 81);
					adaptor.AddChild(root_1, stream_shift.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 549:17: -> { op.Text == \">>\" }? ^( '>>' $add $shift)
				if ( op.Text == ">>"  )
				{
					DebugLocation(549, 42);
					// JavaScript.g:549:42: ^( '>>' $add $shift)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(549, 44);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ShiftRightExpression(stream_73.NextToken()), root_1);

					DebugLocation(549, 77);
					adaptor.AddChild(root_1, stream_add.NextTree());
					DebugLocation(549, 82);
					adaptor.AddChild(root_1, stream_shift.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 550:14: -> { op.Text == \">>>\" }? ^( '>>>' $add $shift)
				if ( op.Text == ">>>" )
				{
					DebugLocation(550, 39);
					// JavaScript.g:550:39: ^( '>>>' $add $shift)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(550, 41);
					root_1 = (CommonTree)adaptor.BecomeRoot(new RotateRightExpression(stream_75.NextToken()), root_1);

					DebugLocation(550, 76);
					adaptor.AddChild(root_1, stream_add.NextTree());
					DebugLocation(550, 81);
					adaptor.AddChild(root_1, stream_shift.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 551:17: ->
				{
					DebugLocation(552, 13);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:552:17: 
				{

				{
				// AST REWRITE
				// elements: add
				// token labels: 
				// rule labels: add, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_add=new RewriteRuleSubtreeStream(adaptor,"rule add",add!=null?add.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 552:17: -> $add
				{
					DebugLocation(552, 21);
					adaptor.AddChild(root_0, stream_add.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(214); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shiftExpression", 71);
			LeaveRule("shiftExpression", 71);
			LeaveRule_shiftExpression();
			if (state.backtracking > 0) { Memoize(input, 71, shiftExpression_StartIndex); }

		}
		DebugLocation(554, 4);
		} finally { DebugExitRule(GrammarFileName, "shiftExpression"); }
		return retval;

	}
	// $ANTLR end "shiftExpression"

	partial void EnterRule_additiveExpression();
	partial void LeaveRule_additiveExpression();
	// $ANTLR start "additiveExpression"
	// JavaScript.g:556:1: additiveExpression : mult= multiplicativeExpression ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )? -> { op == null }? $mult -> { op.Text == \"+\" }? ^( '+' $mult $add) -> { op.Text == \"-\" }? ^( '-' $mult $add) ->;
	[GrammarRule("additiveExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> additiveExpression()
	{
		EnterRule_additiveExpression();
		EnterRule("additiveExpression", 72);
		TraceIn("additiveExpression", 72);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int additiveExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT382 = default(IToken);
		IToken LT383 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> mult = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> add = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT382_tree = default(CommonTree);
		CommonTree LT383_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		RewriteRuleSubtreeStream stream_additiveExpression=new RewriteRuleSubtreeStream(adaptor,"rule additiveExpression");
		try { DebugEnterRule(GrammarFileName, "additiveExpression");
		DebugLocation(556, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 72)) { return retval; }

			// JavaScript.g:557:2: (mult= multiplicativeExpression ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )? -> { op == null }? $mult -> { op.Text == \"+\" }? ^( '+' $mult $add) -> { op.Text == \"-\" }? ^( '-' $mult $add) ->)
			DebugEnterAlt(1);
			// JavaScript.g:558:3: mult= multiplicativeExpression ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )?
			{
			DebugLocation(558, 7);
			PushFollow(Follow._multiplicativeExpression_in_additiveExpression5390);
			mult=multiplicativeExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_multiplicativeExpression.Add(mult.Tree);
			DebugLocation(559, 6);
			// JavaScript.g:559:6: ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )?
			int alt218=2;
			try { DebugEnterSubRule(218);
			try { DebugEnterDecision(218, false);
			int LA218_1 = input.LA(1);

			if ((LA218_1==LT))
			{
				int LA218_2 = input.LA(2);

				if ((EvaluatePredicate(synpred257_JavaScript_fragment)))
				{
					alt218 = 1;
				}
			}
			else if ((LA218_1==52||LA218_1==56))
			{
				alt218 = 1;
			}
			} finally { DebugExitDecision(218); }
			switch (alt218)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:559:7: ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression
				{
				DebugLocation(559, 7);
				// JavaScript.g:559:7: ( LT )*
				try { DebugEnterSubRule(215);
				while (true)
				{
					int alt215=2;
					try { DebugEnterDecision(215, false);
					int LA215_1 = input.LA(1);

					if ((LA215_1==LT))
					{
						alt215 = 1;
					}


					} finally { DebugExitDecision(215); }
					switch ( alt215 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:559:7: LT
						{
						DebugLocation(559, 7);
						LT382=(IToken)Match(input,LT,Follow._LT_in_additiveExpression5399); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT382);


						}
						break;

					default:
						goto loop215;
					}
				}

				loop215:
					;

				} finally { DebugExitSubRule(215); }

				DebugLocation(559, 11);
				// JavaScript.g:559:11: (op= '+' |op= '-' )
				int alt216=2;
				try { DebugEnterSubRule(216);
				try { DebugEnterDecision(216, false);
				int LA216_1 = input.LA(1);

				if ((LA216_1==52))
				{
					alt216 = 1;
				}
				else if ((LA216_1==56))
				{
					alt216 = 2;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 216, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				} finally { DebugExitDecision(216); }
				switch (alt216)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:559:12: op= '+'
					{
					DebugLocation(559, 14);
					op=(IToken)Match(input,52,Follow._52_in_additiveExpression5405); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_52.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:559:21: op= '-'
					{
					DebugLocation(559, 23);
					op=(IToken)Match(input,56,Follow._56_in_additiveExpression5411); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_56.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(216); }

				DebugLocation(559, 29);
				// JavaScript.g:559:29: ( LT )*
				try { DebugEnterSubRule(217);
				while (true)
				{
					int alt217=2;
					try { DebugEnterDecision(217, false);
					int LA217_1 = input.LA(1);

					if ((LA217_1==LT))
					{
						alt217 = 1;
					}


					} finally { DebugExitDecision(217); }
					switch ( alt217 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:559:29: LT
						{
						DebugLocation(559, 29);
						LT383=(IToken)Match(input,LT,Follow._LT_in_additiveExpression5414); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT383);


						}
						break;

					default:
						goto loop217;
					}
				}

				loop217:
					;

				} finally { DebugExitSubRule(217); }

				DebugLocation(559, 36);
				PushFollow(Follow._additiveExpression_in_additiveExpression5419);
				add=additiveExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_additiveExpression.Add(add.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(218); }



			{
			// AST REWRITE
			// elements: mult, 52, mult, add, 56, mult, add
			// token labels: 
			// rule labels: mult, add, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_mult=new RewriteRuleSubtreeStream(adaptor,"rule mult",mult!=null?mult.Tree:null);
			RewriteRuleSubtreeStream stream_add=new RewriteRuleSubtreeStream(adaptor,"rule add",add!=null?add.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 560:13: -> { op == null }? $mult
			if ( op      == null )
			{
				DebugLocation(560, 38);
				adaptor.AddChild(root_0, stream_mult.NextTree());

			}
			else // 561:13: -> { op.Text == \"+\" }? ^( '+' $mult $add)
			if ( op.Text == "+"  )
			{
				DebugLocation(561, 37);
				// JavaScript.g:561:37: ^( '+' $mult $add)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(561, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(new AdditionExpression(stream_52.NextToken()), root_1);

				DebugLocation(561, 69);
				adaptor.AddChild(root_1, stream_mult.NextTree());
				DebugLocation(561, 75);
				adaptor.AddChild(root_1, stream_add.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 562:13: -> { op.Text == \"-\" }? ^( '-' $mult $add)
			if ( op.Text == "-"  )
			{
				DebugLocation(562, 37);
				// JavaScript.g:562:37: ^( '-' $mult $add)
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(562, 39);
				root_1 = (CommonTree)adaptor.BecomeRoot(new SubtractionExpression(stream_56.NextToken()), root_1);

				DebugLocation(562, 72);
				adaptor.AddChild(root_1, stream_mult.NextTree());
				DebugLocation(562, 78);
				adaptor.AddChild(root_1, stream_add.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}
			else // 563:13: ->
			{
				DebugLocation(564, 2);
				root_0 = null;
			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("additiveExpression", 72);
			LeaveRule("additiveExpression", 72);
			LeaveRule_additiveExpression();
			if (state.backtracking > 0) { Memoize(input, 72, additiveExpression_StartIndex); }

		}
		DebugLocation(564, 1);
		} finally { DebugExitRule(GrammarFileName, "additiveExpression"); }
		return retval;

	}
	// $ANTLR end "additiveExpression"

	partial void EnterRule_multiplicativeExpression();
	partial void LeaveRule_multiplicativeExpression();
	// $ANTLR start "multiplicativeExpression"
	// JavaScript.g:566:1: multiplicativeExpression : ue= unaryExpression ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue) ;
	[GrammarRule("multiplicativeExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> multiplicativeExpression()
	{
		EnterRule_multiplicativeExpression();
		EnterRule("multiplicativeExpression", 73);
		TraceIn("multiplicativeExpression", 73);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int multiplicativeExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		IToken LT384 = default(IToken);
		IToken LT385 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> ue = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> me = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		CommonTree LT384_tree = default(CommonTree);
		CommonTree LT385_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_50=new RewriteRuleITokenStream(adaptor,"token 50");
		RewriteRuleITokenStream stream_60=new RewriteRuleITokenStream(adaptor,"token 60");
		RewriteRuleITokenStream stream_43=new RewriteRuleITokenStream(adaptor,"token 43");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		RewriteRuleSubtreeStream stream_multiplicativeExpression=new RewriteRuleSubtreeStream(adaptor,"rule multiplicativeExpression");
		try { DebugEnterRule(GrammarFileName, "multiplicativeExpression");
		DebugLocation(566, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 73)) { return retval; }

			// JavaScript.g:567:2: (ue= unaryExpression ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue) )
			DebugEnterAlt(1);
			// JavaScript.g:568:3: ue= unaryExpression ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue)
			{
			DebugLocation(568, 5);
			PushFollow(Follow._unaryExpression_in_multiplicativeExpression5532);
			ue=unaryExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_unaryExpression.Add(ue.Tree);
			DebugLocation(569, 3);
			// JavaScript.g:569:3: ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue)
			int alt222=2;
			try { DebugEnterSubRule(222);
			try { DebugEnterDecision(222, false);
			try
			{
				alt222 = dfa222.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(222); }
			switch (alt222)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:570:4: ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression )
				{
				DebugLocation(570, 4);
				// JavaScript.g:570:4: ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression )
				DebugEnterAlt(1);
				// JavaScript.g:570:5: ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression
				{
				DebugLocation(570, 5);
				// JavaScript.g:570:5: ( LT )*
				try { DebugEnterSubRule(219);
				while (true)
				{
					int alt219=2;
					try { DebugEnterDecision(219, false);
					int LA219_1 = input.LA(1);

					if ((LA219_1==LT))
					{
						alt219 = 1;
					}


					} finally { DebugExitDecision(219); }
					switch ( alt219 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:570:5: LT
						{
						DebugLocation(570, 5);
						LT384=(IToken)Match(input,LT,Follow._LT_in_multiplicativeExpression5543); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT384);


						}
						break;

					default:
						goto loop219;
					}
				}

				loop219:
					;

				} finally { DebugExitSubRule(219); }

				DebugLocation(570, 9);
				// JavaScript.g:570:9: (op= '*' |op= '/' |op= '%' )
				int alt220=3;
				try { DebugEnterSubRule(220);
				try { DebugEnterDecision(220, false);
				switch (input.LA(1))
				{
				case 50:
					{
					alt220 = 1;
					}
					break;
				case 60:
					{
					alt220 = 2;
					}
					break;
				case 43:
					{
					alt220 = 3;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 220, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(220); }
				switch (alt220)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:570:10: op= '*'
					{
					DebugLocation(570, 12);
					op=(IToken)Match(input,50,Follow._50_in_multiplicativeExpression5549); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_50.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:570:19: op= '/'
					{
					DebugLocation(570, 21);
					op=(IToken)Match(input,60,Follow._60_in_multiplicativeExpression5555); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_60.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:570:28: op= '%'
					{
					DebugLocation(570, 30);
					op=(IToken)Match(input,43,Follow._43_in_multiplicativeExpression5561); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_43.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(220); }

				DebugLocation(570, 36);
				// JavaScript.g:570:36: ( LT )*
				try { DebugEnterSubRule(221);
				while (true)
				{
					int alt221=2;
					try { DebugEnterDecision(221, false);
					int LA221_1 = input.LA(1);

					if ((LA221_1==LT))
					{
						alt221 = 1;
					}


					} finally { DebugExitDecision(221); }
					switch ( alt221 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:570:36: LT
						{
						DebugLocation(570, 36);
						LT385=(IToken)Match(input,LT,Follow._LT_in_multiplicativeExpression5564); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT385);


						}
						break;

					default:
						goto loop221;
					}
				}

				loop221:
					;

				} finally { DebugExitSubRule(221); }

				DebugLocation(570, 42);
				PushFollow(Follow._multiplicativeExpression_in_multiplicativeExpression5569);
				me=multiplicativeExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_multiplicativeExpression.Add(me.Tree);

				}



				{
				// AST REWRITE
				// elements: 50, ue, me, 60, ue, me, 43, ue, me
				// token labels: 
				// rule labels: ue, me, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ue=new RewriteRuleSubtreeStream(adaptor,"rule ue",ue!=null?ue.Tree:null);
				RewriteRuleSubtreeStream stream_me=new RewriteRuleSubtreeStream(adaptor,"rule me",me!=null?me.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 571:17: -> { op.Text == \"*\" }? ^( '*' $ue $me)
				if ( op.Text == "*"  )
				{
					DebugLocation(571, 41);
					// JavaScript.g:571:41: ^( '*' $ue $me)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(571, 43);
					root_1 = (CommonTree)adaptor.BecomeRoot(new MultiplicationExpression(stream_50.NextToken()), root_1);

					DebugLocation(571, 79);
					adaptor.AddChild(root_1, stream_ue.NextTree());
					DebugLocation(571, 83);
					adaptor.AddChild(root_1, stream_me.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 572:17: -> { op.Text == \"/\" }? ^( '/' $ue $me)
				if ( op.Text == "/"  )
				{
					DebugLocation(572, 41);
					// JavaScript.g:572:41: ^( '/' $ue $me)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(572, 43);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DivisionExpression(stream_60.NextToken()), root_1);

					DebugLocation(572, 73);
					adaptor.AddChild(root_1, stream_ue.NextTree());
					DebugLocation(572, 77);
					adaptor.AddChild(root_1, stream_me.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 573:17: -> { op.Text == \"\\%\" }? ^( '%' $ue $me)
				if ( op.Text == "%" )
				{
					DebugLocation(573, 41);
					// JavaScript.g:573:41: ^( '%' $ue $me)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(573, 43);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ModulusExpression(stream_43.NextToken()), root_1);

					DebugLocation(573, 72);
					adaptor.AddChild(root_1, stream_ue.NextTree());
					DebugLocation(573, 76);
					adaptor.AddChild(root_1, stream_me.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 574:8: ->
				{
					DebugLocation(575, 13);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:575:17: 
				{

				{
				// AST REWRITE
				// elements: ue
				// token labels: 
				// rule labels: ue, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ue=new RewriteRuleSubtreeStream(adaptor,"rule ue",ue!=null?ue.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 575:17: -> $ue
				{
					DebugLocation(575, 21);
					adaptor.AddChild(root_0, stream_ue.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(222); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("multiplicativeExpression", 73);
			LeaveRule("multiplicativeExpression", 73);
			LeaveRule_multiplicativeExpression();
			if (state.backtracking > 0) { Memoize(input, 73, multiplicativeExpression_StartIndex); }

		}
		DebugLocation(577, 1);
		} finally { DebugExitRule(GrammarFileName, "multiplicativeExpression"); }
		return retval;

	}
	// $ANTLR end "multiplicativeExpression"

	partial void EnterRule_unaryExpression();
	partial void LeaveRule_unaryExpression();
	// $ANTLR start "unaryExpression"
	// JavaScript.g:579:1: unaryExpression : (pfe= postfixExpression -> $pfe| ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression ) -> { op.Text == \"delete\" }? ^( 'delete' $ue) -> { op.Text == \"void\" }? ^( 'void' $ue) -> { op.Text == \"typeof\" }? ^( 'typeof' $ue) -> { op.Text == \"++\" }? ^( '++' $ue) -> { op.Text == \"--\" }? ^( '--' $ue) -> { op.Text == \"+\" }? ^( '+' $ue) -> { op.Text == \"-\" }? ^( '-' $ue) -> { op.Text == \"~\" }? ^( '~' $ue) -> { op.Text == \"!\" }? ^( '!' $ue) ->);
	[GrammarRule("unaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> unaryExpression()
	{
		EnterRule_unaryExpression();
		EnterRule("unaryExpression", 74);
		TraceIn("unaryExpression", 74);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int unaryExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken op = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> pfe = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> ue = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree op_tree = default(CommonTree);
		RewriteRuleITokenStream stream_87=new RewriteRuleITokenStream(adaptor,"token 87");
		RewriteRuleITokenStream stream_107=new RewriteRuleITokenStream(adaptor,"token 107");
		RewriteRuleITokenStream stream_105=new RewriteRuleITokenStream(adaptor,"token 105");
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleITokenStream stream_52=new RewriteRuleITokenStream(adaptor,"token 52");
		RewriteRuleITokenStream stream_56=new RewriteRuleITokenStream(adaptor,"token 56");
		RewriteRuleITokenStream stream_115=new RewriteRuleITokenStream(adaptor,"token 115");
		RewriteRuleITokenStream stream_40=new RewriteRuleITokenStream(adaptor,"token 40");
		RewriteRuleSubtreeStream stream_postfixExpression=new RewriteRuleSubtreeStream(adaptor,"rule postfixExpression");
		RewriteRuleSubtreeStream stream_unaryExpression=new RewriteRuleSubtreeStream(adaptor,"rule unaryExpression");
		try { DebugEnterRule(GrammarFileName, "unaryExpression");
		DebugLocation(579, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 74)) { return retval; }

			// JavaScript.g:580:2: (pfe= postfixExpression -> $pfe| ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression ) -> { op.Text == \"delete\" }? ^( 'delete' $ue) -> { op.Text == \"void\" }? ^( 'void' $ue) -> { op.Text == \"typeof\" }? ^( 'typeof' $ue) -> { op.Text == \"++\" }? ^( '++' $ue) -> { op.Text == \"--\" }? ^( '--' $ue) -> { op.Text == \"+\" }? ^( '+' $ue) -> { op.Text == \"-\" }? ^( '-' $ue) -> { op.Text == \"~\" }? ^( '~' $ue) -> { op.Text == \"!\" }? ^( '!' $ue) ->)
			int alt224=2;
			try { DebugEnterDecision(224, false);
			int LA224_1 = input.LA(1);

			if ((LA224_1==Identifier||LA224_1==NumericLiteral||LA224_1==StringLiteral||LA224_1==48||LA224_1==78||LA224_1==90||LA224_1==93||(LA224_1>=97 && LA224_1<=98)||LA224_1==101||LA224_1==103||LA224_1==110))
			{
				alt224 = 1;
			}
			else if ((LA224_1==40||(LA224_1>=52 && LA224_1<=53)||(LA224_1>=56 && LA224_1<=57)||LA224_1==87||LA224_1==105||LA224_1==107||LA224_1==115))
			{
				alt224 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 224, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(224); }
			switch (alt224)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:580:4: pfe= postfixExpression
				{
				DebugLocation(580, 7);
				PushFollow(Follow._postfixExpression_in_unaryExpression5722);
				pfe=postfixExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_postfixExpression.Add(pfe.Tree);


				{
				// AST REWRITE
				// elements: pfe
				// token labels: 
				// rule labels: pfe, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_pfe=new RewriteRuleSubtreeStream(adaptor,"rule pfe",pfe!=null?pfe.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 580:26: -> $pfe
				{
					DebugLocation(580, 30);
					adaptor.AddChild(root_0, stream_pfe.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:582:9: ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression )
				{
				DebugLocation(582, 9);
				// JavaScript.g:582:9: ( (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression )
				DebugEnterAlt(1);
				// JavaScript.g:583:13: (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' ) ue= unaryExpression
				{
				DebugLocation(583, 13);
				// JavaScript.g:583:13: (op= 'delete' |op= 'void' |op= 'typeof' |op= '++' |op= '--' |op= '+' |op= '-' |op= '~' |op= '!' )
				int alt223=9;
				try { DebugEnterSubRule(223);
				try { DebugEnterDecision(223, false);
				switch (input.LA(1))
				{
				case 87:
					{
					alt223 = 1;
					}
					break;
				case 107:
					{
					alt223 = 2;
					}
					break;
				case 105:
					{
					alt223 = 3;
					}
					break;
				case 53:
					{
					alt223 = 4;
					}
					break;
				case 57:
					{
					alt223 = 5;
					}
					break;
				case 52:
					{
					alt223 = 6;
					}
					break;
				case 56:
					{
					alt223 = 7;
					}
					break;
				case 115:
					{
					alt223 = 8;
					}
					break;
				case 40:
					{
					alt223 = 9;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 223, 0, input, 1);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

				} finally { DebugExitDecision(223); }
				switch (alt223)
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:583:14: op= 'delete'
					{
					DebugLocation(583, 16);
					op=(IToken)Match(input,87,Follow._87_in_unaryExpression5758); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_87.Add(op);


					}
					break;
				case 2:
					DebugEnterAlt(2);
					// JavaScript.g:583:28: op= 'void'
					{
					DebugLocation(583, 30);
					op=(IToken)Match(input,107,Follow._107_in_unaryExpression5764); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_107.Add(op);


					}
					break;
				case 3:
					DebugEnterAlt(3);
					// JavaScript.g:583:40: op= 'typeof'
					{
					DebugLocation(583, 42);
					op=(IToken)Match(input,105,Follow._105_in_unaryExpression5770); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_105.Add(op);


					}
					break;
				case 4:
					DebugEnterAlt(4);
					// JavaScript.g:583:54: op= '++'
					{
					DebugLocation(583, 56);
					op=(IToken)Match(input,53,Follow._53_in_unaryExpression5776); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_53.Add(op);


					}
					break;
				case 5:
					DebugEnterAlt(5);
					// JavaScript.g:583:64: op= '--'
					{
					DebugLocation(583, 66);
					op=(IToken)Match(input,57,Follow._57_in_unaryExpression5782); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_57.Add(op);


					}
					break;
				case 6:
					DebugEnterAlt(6);
					// JavaScript.g:583:74: op= '+'
					{
					DebugLocation(583, 76);
					op=(IToken)Match(input,52,Follow._52_in_unaryExpression5788); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_52.Add(op);


					}
					break;
				case 7:
					DebugEnterAlt(7);
					// JavaScript.g:583:83: op= '-'
					{
					DebugLocation(583, 85);
					op=(IToken)Match(input,56,Follow._56_in_unaryExpression5794); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_56.Add(op);


					}
					break;
				case 8:
					DebugEnterAlt(8);
					// JavaScript.g:583:92: op= '~'
					{
					DebugLocation(583, 94);
					op=(IToken)Match(input,115,Follow._115_in_unaryExpression5800); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_115.Add(op);


					}
					break;
				case 9:
					DebugEnterAlt(9);
					// JavaScript.g:583:101: op= '!'
					{
					DebugLocation(583, 103);
					op=(IToken)Match(input,40,Follow._40_in_unaryExpression5806); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_40.Add(op);


					}
					break;

				}
				} finally { DebugExitSubRule(223); }

				DebugLocation(584, 15);
				PushFollow(Follow._unaryExpression_in_unaryExpression5824);
				ue=unaryExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_unaryExpression.Add(ue.Tree);

				}



				{
				// AST REWRITE
				// elements: 87, ue, 107, ue, 105, ue, 53, ue, 57, ue, 52, ue, 56, ue, 115, ue, 40, ue
				// token labels: 
				// rule labels: ue, retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_ue=new RewriteRuleSubtreeStream(adaptor,"rule ue",ue!=null?ue.Tree:null);
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 586:9: -> { op.Text == \"delete\" }? ^( 'delete' $ue)
				if ( op.Text == "delete" )
				{
					DebugLocation(586, 37);
					// JavaScript.g:586:37: ^( 'delete' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(586, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new DeleteExpression(stream_87.NextToken()), root_1);

					DebugLocation(586, 72);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 587:9: -> { op.Text == \"void\" }? ^( 'void' $ue)
				if ( op.Text == "void"   )
				{
					DebugLocation(587, 37);
					// JavaScript.g:587:37: ^( 'void' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(587, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new VoidExpression(stream_107.NextToken()), root_1);

					DebugLocation(587, 68);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 588:9: -> { op.Text == \"typeof\" }? ^( 'typeof' $ue)
				if ( op.Text == "typeof" )
				{
					DebugLocation(588, 37);
					// JavaScript.g:588:37: ^( 'typeof' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(588, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new TypeofExpression(stream_105.NextToken()), root_1);

					DebugLocation(588, 72);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 589:9: -> { op.Text == \"++\" }? ^( '++' $ue)
				if ( op.Text == "++"     )
				{
					DebugLocation(589, 37);
					// JavaScript.g:589:37: ^( '++' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(589, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PrefixIncrementExpression(stream_53.NextToken()), root_1);

					DebugLocation(589, 77);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 590:9: -> { op.Text == \"--\" }? ^( '--' $ue)
				if ( op.Text == "--"     )
				{
					DebugLocation(590, 37);
					// JavaScript.g:590:37: ^( '--' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(590, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PrefixDecrementExpression(stream_57.NextToken()), root_1);

					DebugLocation(590, 77);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 591:9: -> { op.Text == \"+\" }? ^( '+' $ue)
				if ( op.Text == "+"      )
				{
					DebugLocation(591, 37);
					// JavaScript.g:591:37: ^( '+' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(591, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new UnaryPlusExpression(stream_52.NextToken()), root_1);

					DebugLocation(591, 70);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 592:9: -> { op.Text == \"-\" }? ^( '-' $ue)
				if ( op.Text == "-"      )
				{
					DebugLocation(592, 37);
					// JavaScript.g:592:37: ^( '-' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(592, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new NegationExpression(stream_56.NextToken()), root_1);

					DebugLocation(592, 69);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 593:9: -> { op.Text == \"~\" }? ^( '~' $ue)
				if ( op.Text == "~"      )
				{
					DebugLocation(593, 37);
					// JavaScript.g:593:37: ^( '~' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(593, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BitwiseNotExpression(stream_115.NextToken()), root_1);

					DebugLocation(593, 71);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 594:9: -> { op.Text == \"!\" }? ^( '!' $ue)
				if ( op.Text == "!"      )
				{
					DebugLocation(594, 37);
					// JavaScript.g:594:37: ^( '!' $ue)
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(594, 39);
					root_1 = (CommonTree)adaptor.BecomeRoot(new BooleanNotExpression(stream_40.NextToken()), root_1);

					DebugLocation(594, 71);
					adaptor.AddChild(root_1, stream_ue.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}
				else // 595:9: ->
				{
					DebugLocation(596, 2);
					root_0 = null;
				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("unaryExpression", 74);
			LeaveRule("unaryExpression", 74);
			LeaveRule_unaryExpression();
			if (state.backtracking > 0) { Memoize(input, 74, unaryExpression_StartIndex); }

		}
		DebugLocation(596, 1);
		} finally { DebugExitRule(GrammarFileName, "unaryExpression"); }
		return retval;

	}
	// $ANTLR end "unaryExpression"

	partial void EnterRule_postfixExpression();
	partial void LeaveRule_postfixExpression();
	// $ANTLR start "postfixExpression"
	// JavaScript.g:598:1: postfixExpression : leftHandSideExpression ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression ) ;
	[GrammarRule("postfixExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> postfixExpression()
	{
		EnterRule_postfixExpression();
		EnterRule("postfixExpression", 75);
		TraceIn("postfixExpression", 75);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int postfixExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal387 = default(IToken);
		IToken string_literal388 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> leftHandSideExpression386 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal387_tree = default(CommonTree);
		CommonTree string_literal388_tree = default(CommonTree);
		RewriteRuleITokenStream stream_53=new RewriteRuleITokenStream(adaptor,"token 53");
		RewriteRuleITokenStream stream_57=new RewriteRuleITokenStream(adaptor,"token 57");
		RewriteRuleSubtreeStream stream_leftHandSideExpression=new RewriteRuleSubtreeStream(adaptor,"rule leftHandSideExpression");
		try { DebugEnterRule(GrammarFileName, "postfixExpression");
		DebugLocation(598, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 75)) { return retval; }

			// JavaScript.g:599:2: ( leftHandSideExpression ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:600:3: leftHandSideExpression ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression )
			{
			DebugLocation(600, 3);
			PushFollow(Follow._leftHandSideExpression_in_postfixExpression6076);
			leftHandSideExpression386=leftHandSideExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_leftHandSideExpression.Add(leftHandSideExpression386.Tree);
			DebugLocation(601, 3);
			// JavaScript.g:601:3: ( '++' -> ^( '++' leftHandSideExpression ) | '--' -> ^( '--' leftHandSideExpression ) | -> leftHandSideExpression )
			int alt225=3;
			try { DebugEnterSubRule(225);
			try { DebugEnterDecision(225, false);
			switch (input.LA(1))
			{
			case 53:
				{
				alt225 = 1;
				}
				break;
			case 57:
				{
				alt225 = 2;
				}
				break;
			case EOF:
			case LT:
			case 41:
			case 42:
			case 43:
			case 45:
			case 46:
			case 49:
			case 50:
			case 52:
			case 55:
			case 56:
			case 60:
			case 62:
			case 63:
			case 64:
			case 65:
			case 67:
			case 69:
			case 70:
			case 71:
			case 72:
			case 73:
			case 75:
			case 77:
			case 79:
			case 80:
			case 95:
			case 96:
			case 111:
			case 113:
			case 114:
				{
				alt225 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 225, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(225); }
			switch (alt225)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:602:4: '++'
				{
				DebugLocation(602, 4);
				string_literal387=(IToken)Match(input,53,Follow._53_in_postfixExpression6086); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_53.Add(string_literal387);



				{
				// AST REWRITE
				// elements: 53, leftHandSideExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 602:9: -> ^( '++' leftHandSideExpression )
				{
					DebugLocation(602, 12);
					// JavaScript.g:602:12: ^( '++' leftHandSideExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(602, 14);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PostfixIncrementExpression(stream_53.NextToken()), root_1);

					DebugLocation(602, 52);
					adaptor.AddChild(root_1, stream_leftHandSideExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:603:6: '--'
				{
				DebugLocation(603, 6);
				string_literal388=(IToken)Match(input,57,Follow._57_in_postfixExpression6106); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_57.Add(string_literal388);



				{
				// AST REWRITE
				// elements: 57, leftHandSideExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 603:11: -> ^( '--' leftHandSideExpression )
				{
					DebugLocation(603, 14);
					// JavaScript.g:603:14: ^( '--' leftHandSideExpression )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(603, 16);
					root_1 = (CommonTree)adaptor.BecomeRoot(new PostfixDecrementExpression(stream_57.NextToken()), root_1);

					DebugLocation(603, 54);
					adaptor.AddChild(root_1, stream_leftHandSideExpression.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:604:7: 
				{

				{
				// AST REWRITE
				// elements: leftHandSideExpression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 604:7: -> leftHandSideExpression
				{
					DebugLocation(604, 10);
					adaptor.AddChild(root_0, stream_leftHandSideExpression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			} finally { DebugExitSubRule(225); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("postfixExpression", 75);
			LeaveRule("postfixExpression", 75);
			LeaveRule_postfixExpression();
			if (state.backtracking > 0) { Memoize(input, 75, postfixExpression_StartIndex); }

		}
		DebugLocation(606, 1);
		} finally { DebugExitRule(GrammarFileName, "postfixExpression"); }
		return retval;

	}
	// $ANTLR end "postfixExpression"

	partial void EnterRule_primaryExpression();
	partial void LeaveRule_primaryExpression();
	// $ANTLR start "primaryExpression"
	// JavaScript.g:608:1: primaryExpression : ( 'this' -> ^( 'this' ) | Identifier -> ^( Identifier ) | literal -> literal | arrayLiteral -> arrayLiteral | objectLiteral -> objectLiteral | '(' ( LT )* expression ( LT )* ')' -> expression );
	[GrammarRule("primaryExpression")]
	private AstParserRuleReturnScope<CommonTree, IToken> primaryExpression()
	{
		EnterRule_primaryExpression();
		EnterRule("primaryExpression", 76);
		TraceIn("primaryExpression", 76);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int primaryExpression_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal389 = default(IToken);
		IToken Identifier390 = default(IToken);
		IToken char_literal394 = default(IToken);
		IToken LT395 = default(IToken);
		IToken LT397 = default(IToken);
		IToken char_literal398 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> literal391 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> arrayLiteral392 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> objectLiteral393 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> expression396 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree string_literal389_tree = default(CommonTree);
		CommonTree Identifier390_tree = default(CommonTree);
		CommonTree char_literal394_tree = default(CommonTree);
		CommonTree LT395_tree = default(CommonTree);
		CommonTree LT397_tree = default(CommonTree);
		CommonTree char_literal398_tree = default(CommonTree);
		RewriteRuleITokenStream stream_101=new RewriteRuleITokenStream(adaptor,"token 101");
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_48=new RewriteRuleITokenStream(adaptor,"token 48");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_49=new RewriteRuleITokenStream(adaptor,"token 49");
		RewriteRuleSubtreeStream stream_literal=new RewriteRuleSubtreeStream(adaptor,"rule literal");
		RewriteRuleSubtreeStream stream_arrayLiteral=new RewriteRuleSubtreeStream(adaptor,"rule arrayLiteral");
		RewriteRuleSubtreeStream stream_objectLiteral=new RewriteRuleSubtreeStream(adaptor,"rule objectLiteral");
		RewriteRuleSubtreeStream stream_expression=new RewriteRuleSubtreeStream(adaptor,"rule expression");
		try { DebugEnterRule(GrammarFileName, "primaryExpression");
		DebugLocation(608, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 76)) { return retval; }

			// JavaScript.g:609:2: ( 'this' -> ^( 'this' ) | Identifier -> ^( Identifier ) | literal -> literal | arrayLiteral -> arrayLiteral | objectLiteral -> objectLiteral | '(' ( LT )* expression ( LT )* ')' -> expression )
			int alt228=6;
			try { DebugEnterDecision(228, false);
			switch (input.LA(1))
			{
			case 101:
				{
				alt228 = 1;
				}
				break;
			case Identifier:
				{
				alt228 = 2;
				}
				break;
			case NumericLiteral:
			case StringLiteral:
			case 90:
			case 98:
			case 103:
				{
				alt228 = 3;
				}
				break;
			case 78:
				{
				alt228 = 4;
				}
				break;
			case 110:
				{
				alt228 = 5;
				}
				break;
			case 48:
				{
				alt228 = 6;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 228, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(228); }
			switch (alt228)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:609:4: 'this'
				{
				DebugLocation(609, 4);
				string_literal389=(IToken)Match(input,101,Follow._101_in_primaryExpression6144); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_101.Add(string_literal389);



				{
				// AST REWRITE
				// elements: 101
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 609:16: -> ^( 'this' )
				{
					DebugLocation(609, 19);
					// JavaScript.g:609:19: ^( 'this' )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(609, 21);
					root_1 = (CommonTree)adaptor.BecomeRoot(new ThisExpression(stream_101.NextToken()), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:610:4: Identifier
				{
				DebugLocation(610, 4);
				Identifier390=(IToken)Match(input,Identifier,Follow._Identifier_in_primaryExpression6165); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier390);



				{
				// AST REWRITE
				// elements: Identifier
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 610:19: -> ^( Identifier )
				{
					DebugLocation(610, 22);
					// JavaScript.g:610:22: ^( Identifier )
					{
					CommonTree root_1 = (CommonTree)adaptor.Nil();
					DebugLocation(610, 24);
					root_1 = (CommonTree)adaptor.BecomeRoot(new Identifier(stream_Identifier.NextToken()), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:611:4: literal
				{
				DebugLocation(611, 4);
				PushFollow(Follow._literal_in_primaryExpression6185);
				literal391=literal();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_literal.Add(literal391.Tree);


				{
				// AST REWRITE
				// elements: literal
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 611:17: -> literal
				{
					DebugLocation(611, 20);
					adaptor.AddChild(root_0, stream_literal.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:612:4: arrayLiteral
				{
				DebugLocation(612, 4);
				PushFollow(Follow._arrayLiteral_in_primaryExpression6199);
				arrayLiteral392=arrayLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arrayLiteral.Add(arrayLiteral392.Tree);


				{
				// AST REWRITE
				// elements: arrayLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 612:21: -> arrayLiteral
				{
					DebugLocation(612, 24);
					adaptor.AddChild(root_0, stream_arrayLiteral.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:613:4: objectLiteral
				{
				DebugLocation(613, 4);
				PushFollow(Follow._objectLiteral_in_primaryExpression6212);
				objectLiteral393=objectLiteral();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_objectLiteral.Add(objectLiteral393.Tree);


				{
				// AST REWRITE
				// elements: objectLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 613:22: -> objectLiteral
				{
					DebugLocation(613, 25);
					adaptor.AddChild(root_0, stream_objectLiteral.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// JavaScript.g:614:4: '(' ( LT )* expression ( LT )* ')'
				{
				DebugLocation(614, 4);
				char_literal394=(IToken)Match(input,48,Follow._48_in_primaryExpression6225); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_48.Add(char_literal394);

				DebugLocation(614, 8);
				// JavaScript.g:614:8: ( LT )*
				try { DebugEnterSubRule(226);
				while (true)
				{
					int alt226=2;
					try { DebugEnterDecision(226, false);
					int LA226_1 = input.LA(1);

					if ((LA226_1==LT))
					{
						alt226 = 1;
					}


					} finally { DebugExitDecision(226); }
					switch ( alt226 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:614:8: LT
						{
						DebugLocation(614, 8);
						LT395=(IToken)Match(input,LT,Follow._LT_in_primaryExpression6227); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT395);


						}
						break;

					default:
						goto loop226;
					}
				}

				loop226:
					;

				} finally { DebugExitSubRule(226); }

				DebugLocation(614, 12);
				PushFollow(Follow._expression_in_primaryExpression6230);
				expression396=expression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expression.Add(expression396.Tree);
				DebugLocation(614, 23);
				// JavaScript.g:614:23: ( LT )*
				try { DebugEnterSubRule(227);
				while (true)
				{
					int alt227=2;
					try { DebugEnterDecision(227, false);
					int LA227_1 = input.LA(1);

					if ((LA227_1==LT))
					{
						alt227 = 1;
					}


					} finally { DebugExitDecision(227); }
					switch ( alt227 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:614:23: LT
						{
						DebugLocation(614, 23);
						LT397=(IToken)Match(input,LT,Follow._LT_in_primaryExpression6232); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT397);


						}
						break;

					default:
						goto loop227;
					}
				}

				loop227:
					;

				} finally { DebugExitSubRule(227); }

				DebugLocation(614, 27);
				char_literal398=(IToken)Match(input,49,Follow._49_in_primaryExpression6235); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_49.Add(char_literal398);



				{
				// AST REWRITE
				// elements: expression
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 614:31: -> expression
				{
					DebugLocation(614, 34);
					adaptor.AddChild(root_0, stream_expression.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("primaryExpression", 76);
			LeaveRule("primaryExpression", 76);
			LeaveRule_primaryExpression();
			if (state.backtracking > 0) { Memoize(input, 76, primaryExpression_StartIndex); }

		}
		DebugLocation(615, 1);
		} finally { DebugExitRule(GrammarFileName, "primaryExpression"); }
		return retval;

	}
	// $ANTLR end "primaryExpression"

	partial void EnterRule_arrayLiteral();
	partial void LeaveRule_arrayLiteral();
	// $ANTLR start "arrayLiteral"
	// JavaScript.g:618:1: arrayLiteral : '[' ( LT )* ( assignmentExpression )? ( ( LT )* ',' ( ( LT )* assignmentExpression )? )* ( LT )* ']' -> ^( '[' ( assignmentExpression )* ) ;
	[GrammarRule("arrayLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> arrayLiteral()
	{
		EnterRule_arrayLiteral();
		EnterRule("arrayLiteral", 77);
		TraceIn("arrayLiteral", 77);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int arrayLiteral_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal399 = default(IToken);
		IToken LT400 = default(IToken);
		IToken LT402 = default(IToken);
		IToken char_literal403 = default(IToken);
		IToken LT404 = default(IToken);
		IToken LT406 = default(IToken);
		IToken char_literal407 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression401 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression405 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal399_tree = default(CommonTree);
		CommonTree LT400_tree = default(CommonTree);
		CommonTree LT402_tree = default(CommonTree);
		CommonTree char_literal403_tree = default(CommonTree);
		CommonTree LT404_tree = default(CommonTree);
		CommonTree LT406_tree = default(CommonTree);
		CommonTree char_literal407_tree = default(CommonTree);
		RewriteRuleITokenStream stream_78=new RewriteRuleITokenStream(adaptor,"token 78");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_79=new RewriteRuleITokenStream(adaptor,"token 79");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "arrayLiteral");
		DebugLocation(618, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 77)) { return retval; }

			// JavaScript.g:619:2: ( '[' ( LT )* ( assignmentExpression )? ( ( LT )* ',' ( ( LT )* assignmentExpression )? )* ( LT )* ']' -> ^( '[' ( assignmentExpression )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:619:4: '[' ( LT )* ( assignmentExpression )? ( ( LT )* ',' ( ( LT )* assignmentExpression )? )* ( LT )* ']'
			{
			DebugLocation(619, 4);
			char_literal399=(IToken)Match(input,78,Follow._78_in_arrayLiteral6252); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_78.Add(char_literal399);

			DebugLocation(619, 8);
			// JavaScript.g:619:8: ( LT )*
			try { DebugEnterSubRule(229);
			while (true)
			{
				int alt229=2;
				try { DebugEnterDecision(229, false);
				int LA229_1 = input.LA(1);

				if ((LA229_1==LT))
				{
					int LA229_2 = input.LA(2);

					if ((EvaluatePredicate(synpred281_JavaScript_fragment)))
					{
						alt229 = 1;
					}


				}


				} finally { DebugExitDecision(229); }
				switch ( alt229 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:619:8: LT
					{
					DebugLocation(619, 8);
					LT400=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6254); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT400);


					}
					break;

				default:
					goto loop229;
				}
			}

			loop229:
				;

			} finally { DebugExitSubRule(229); }

			DebugLocation(619, 12);
			// JavaScript.g:619:12: ( assignmentExpression )?
			int alt230=2;
			try { DebugEnterSubRule(230);
			try { DebugEnterDecision(230, false);
			int LA230_1 = input.LA(1);

			if ((LA230_1==Identifier||LA230_1==NumericLiteral||LA230_1==StringLiteral||LA230_1==40||LA230_1==48||(LA230_1>=52 && LA230_1<=53)||(LA230_1>=56 && LA230_1<=57)||LA230_1==78||LA230_1==87||LA230_1==90||LA230_1==93||(LA230_1>=97 && LA230_1<=98)||LA230_1==101||LA230_1==103||LA230_1==105||LA230_1==107||LA230_1==110||LA230_1==115))
			{
				alt230 = 1;
			}
			} finally { DebugExitDecision(230); }
			switch (alt230)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:619:12: assignmentExpression
				{
				DebugLocation(619, 12);
				PushFollow(Follow._assignmentExpression_in_arrayLiteral6257);
				assignmentExpression401=assignmentExpression();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression401.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(230); }

			DebugLocation(619, 34);
			// JavaScript.g:619:34: ( ( LT )* ',' ( ( LT )* assignmentExpression )? )*
			try { DebugEnterSubRule(234);
			while (true)
			{
				int alt234=2;
				try { DebugEnterDecision(234, false);
				try
				{
					alt234 = dfa234.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(234); }
				switch ( alt234 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:619:35: ( LT )* ',' ( ( LT )* assignmentExpression )?
					{
					DebugLocation(619, 35);
					// JavaScript.g:619:35: ( LT )*
					try { DebugEnterSubRule(231);
					while (true)
					{
						int alt231=2;
						try { DebugEnterDecision(231, false);
						int LA231_1 = input.LA(1);

						if ((LA231_1==LT))
						{
							alt231 = 1;
						}


						} finally { DebugExitDecision(231); }
						switch ( alt231 )
						{
						case 1:
							DebugEnterAlt(1);
							// JavaScript.g:619:35: LT
							{
							DebugLocation(619, 35);
							LT402=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6261); if (state.failed) return retval; 
							if (state.backtracking == 0) stream_LT.Add(LT402);


							}
							break;

						default:
							goto loop231;
						}
					}

					loop231:
						;

					} finally { DebugExitSubRule(231); }

					DebugLocation(619, 39);
					char_literal403=(IToken)Match(input,55,Follow._55_in_arrayLiteral6264); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_55.Add(char_literal403);

					DebugLocation(619, 43);
					// JavaScript.g:619:43: ( ( LT )* assignmentExpression )?
					int alt233=2;
					try { DebugEnterSubRule(233);
					try { DebugEnterDecision(233, false);
					try
					{
						alt233 = dfa233.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(233); }
					switch (alt233)
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:619:44: ( LT )* assignmentExpression
						{
						DebugLocation(619, 44);
						// JavaScript.g:619:44: ( LT )*
						try { DebugEnterSubRule(232);
						while (true)
						{
							int alt232=2;
							try { DebugEnterDecision(232, false);
							int LA232_1 = input.LA(1);

							if ((LA232_1==LT))
							{
								alt232 = 1;
							}


							} finally { DebugExitDecision(232); }
							switch ( alt232 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:619:44: LT
								{
								DebugLocation(619, 44);
								LT404=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6267); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT404);


								}
								break;

							default:
								goto loop232;
							}
						}

						loop232:
							;

						} finally { DebugExitSubRule(232); }

						DebugLocation(619, 48);
						PushFollow(Follow._assignmentExpression_in_arrayLiteral6270);
						assignmentExpression405=assignmentExpression();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression405.Tree);

						}
						break;

					}
					} finally { DebugExitSubRule(233); }


					}
					break;

				default:
					goto loop234;
				}
			}

			loop234:
				;

			} finally { DebugExitSubRule(234); }

			DebugLocation(619, 73);
			// JavaScript.g:619:73: ( LT )*
			try { DebugEnterSubRule(235);
			while (true)
			{
				int alt235=2;
				try { DebugEnterDecision(235, false);
				int LA235_1 = input.LA(1);

				if ((LA235_1==LT))
				{
					alt235 = 1;
				}


				} finally { DebugExitDecision(235); }
				switch ( alt235 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:619:73: LT
					{
					DebugLocation(619, 73);
					LT406=(IToken)Match(input,LT,Follow._LT_in_arrayLiteral6276); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT406);


					}
					break;

				default:
					goto loop235;
				}
			}

			loop235:
				;

			} finally { DebugExitSubRule(235); }

			DebugLocation(619, 77);
			char_literal407=(IToken)Match(input,79,Follow._79_in_arrayLiteral6279); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_79.Add(char_literal407);



			{
			// AST REWRITE
			// elements: 78, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 620:3: -> ^( '[' ( assignmentExpression )* )
			{
				DebugLocation(620, 6);
				// JavaScript.g:620:6: ^( '[' ( assignmentExpression )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(620, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ArrayLiteral(stream_78.NextToken()), root_1);

				DebugLocation(620, 31);
				// JavaScript.g:620:31: ( assignmentExpression )*
				while ( stream_assignmentExpression.HasNext )
				{
					DebugLocation(620, 31);
					adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				}
				stream_assignmentExpression.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arrayLiteral", 77);
			LeaveRule("arrayLiteral", 77);
			LeaveRule_arrayLiteral();
			if (state.backtracking > 0) { Memoize(input, 77, arrayLiteral_StartIndex); }

		}
		DebugLocation(621, 1);
		} finally { DebugExitRule(GrammarFileName, "arrayLiteral"); }
		return retval;

	}
	// $ANTLR end "arrayLiteral"

	partial void EnterRule_objectLiteral();
	partial void LeaveRule_objectLiteral();
	// $ANTLR start "objectLiteral"
	// JavaScript.g:624:1: objectLiteral : '{' ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )? ( LT )* '}' -> ^( '{' ( propertyNameAndValue )* ) ;
	[GrammarRule("objectLiteral")]
	private AstParserRuleReturnScope<CommonTree, IToken> objectLiteral()
	{
		EnterRule_objectLiteral();
		EnterRule("objectLiteral", 78);
		TraceIn("objectLiteral", 78);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int objectLiteral_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken char_literal408 = default(IToken);
		IToken LT409 = default(IToken);
		IToken LT411 = default(IToken);
		IToken char_literal412 = default(IToken);
		IToken LT413 = default(IToken);
		IToken LT415 = default(IToken);
		IToken char_literal416 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> propertyNameAndValue410 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> propertyNameAndValue414 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree char_literal408_tree = default(CommonTree);
		CommonTree LT409_tree = default(CommonTree);
		CommonTree LT411_tree = default(CommonTree);
		CommonTree char_literal412_tree = default(CommonTree);
		CommonTree LT413_tree = default(CommonTree);
		CommonTree LT415_tree = default(CommonTree);
		CommonTree char_literal416_tree = default(CommonTree);
		RewriteRuleITokenStream stream_110=new RewriteRuleITokenStream(adaptor,"token 110");
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_55=new RewriteRuleITokenStream(adaptor,"token 55");
		RewriteRuleITokenStream stream_114=new RewriteRuleITokenStream(adaptor,"token 114");
		RewriteRuleSubtreeStream stream_propertyNameAndValue=new RewriteRuleSubtreeStream(adaptor,"rule propertyNameAndValue");
		try { DebugEnterRule(GrammarFileName, "objectLiteral");
		DebugLocation(624, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 78)) { return retval; }

			// JavaScript.g:625:2: ( '{' ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )? ( LT )* '}' -> ^( '{' ( propertyNameAndValue )* ) )
			DebugEnterAlt(1);
			// JavaScript.g:625:4: '{' ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )? ( LT )* '}'
			{
			DebugLocation(625, 4);
			char_literal408=(IToken)Match(input,110,Follow._110_in_objectLiteral6314); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_110.Add(char_literal408);

			DebugLocation(625, 8);
			// JavaScript.g:625:8: ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )?
			int alt240=2;
			try { DebugEnterSubRule(240);
			try { DebugEnterDecision(240, false);
			try
			{
				alt240 = dfa240.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(240); }
			switch (alt240)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:625:9: ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )*
				{
				DebugLocation(625, 9);
				// JavaScript.g:625:9: ( LT )*
				try { DebugEnterSubRule(236);
				while (true)
				{
					int alt236=2;
					try { DebugEnterDecision(236, false);
					int LA236_1 = input.LA(1);

					if ((LA236_1==LT))
					{
						alt236 = 1;
					}


					} finally { DebugExitDecision(236); }
					switch ( alt236 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:625:9: LT
						{
						DebugLocation(625, 9);
						LT409=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6317); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_LT.Add(LT409);


						}
						break;

					default:
						goto loop236;
					}
				}

				loop236:
					;

				} finally { DebugExitSubRule(236); }

				DebugLocation(625, 13);
				PushFollow(Follow._propertyNameAndValue_in_objectLiteral6320);
				propertyNameAndValue410=propertyNameAndValue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_propertyNameAndValue.Add(propertyNameAndValue410.Tree);
				DebugLocation(625, 34);
				// JavaScript.g:625:34: ( ( LT )* ',' ( LT )* propertyNameAndValue )*
				try { DebugEnterSubRule(239);
				while (true)
				{
					int alt239=2;
					try { DebugEnterDecision(239, false);
					try
					{
						alt239 = dfa239.Predict(input);
					}
					catch (NoViableAltException nvae)
					{
						DebugRecognitionException(nvae);
						throw;
					}
					} finally { DebugExitDecision(239); }
					switch ( alt239 )
					{
					case 1:
						DebugEnterAlt(1);
						// JavaScript.g:625:35: ( LT )* ',' ( LT )* propertyNameAndValue
						{
						DebugLocation(625, 35);
						// JavaScript.g:625:35: ( LT )*
						try { DebugEnterSubRule(237);
						while (true)
						{
							int alt237=2;
							try { DebugEnterDecision(237, false);
							int LA237_1 = input.LA(1);

							if ((LA237_1==LT))
							{
								alt237 = 1;
							}


							} finally { DebugExitDecision(237); }
							switch ( alt237 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:625:35: LT
								{
								DebugLocation(625, 35);
								LT411=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6323); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT411);


								}
								break;

							default:
								goto loop237;
							}
						}

						loop237:
							;

						} finally { DebugExitSubRule(237); }

						DebugLocation(625, 39);
						char_literal412=(IToken)Match(input,55,Follow._55_in_objectLiteral6326); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_55.Add(char_literal412);

						DebugLocation(625, 43);
						// JavaScript.g:625:43: ( LT )*
						try { DebugEnterSubRule(238);
						while (true)
						{
							int alt238=2;
							try { DebugEnterDecision(238, false);
							int LA238_1 = input.LA(1);

							if ((LA238_1==LT))
							{
								alt238 = 1;
							}


							} finally { DebugExitDecision(238); }
							switch ( alt238 )
							{
							case 1:
								DebugEnterAlt(1);
								// JavaScript.g:625:43: LT
								{
								DebugLocation(625, 43);
								LT413=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6328); if (state.failed) return retval; 
								if (state.backtracking == 0) stream_LT.Add(LT413);


								}
								break;

							default:
								goto loop238;
							}
						}

						loop238:
							;

						} finally { DebugExitSubRule(238); }

						DebugLocation(625, 47);
						PushFollow(Follow._propertyNameAndValue_in_objectLiteral6331);
						propertyNameAndValue414=propertyNameAndValue();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_propertyNameAndValue.Add(propertyNameAndValue414.Tree);

						}
						break;

					default:
						goto loop239;
					}
				}

				loop239:
					;

				} finally { DebugExitSubRule(239); }


				}
				break;

			}
			} finally { DebugExitSubRule(240); }

			DebugLocation(625, 72);
			// JavaScript.g:625:72: ( LT )*
			try { DebugEnterSubRule(241);
			while (true)
			{
				int alt241=2;
				try { DebugEnterDecision(241, false);
				int LA241_1 = input.LA(1);

				if ((LA241_1==LT))
				{
					alt241 = 1;
				}


				} finally { DebugExitDecision(241); }
				switch ( alt241 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:625:72: LT
					{
					DebugLocation(625, 72);
					LT415=(IToken)Match(input,LT,Follow._LT_in_objectLiteral6337); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT415);


					}
					break;

				default:
					goto loop241;
				}
			}

			loop241:
				;

			} finally { DebugExitSubRule(241); }

			DebugLocation(625, 76);
			char_literal416=(IToken)Match(input,114,Follow._114_in_objectLiteral6340); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_114.Add(char_literal416);



			{
			// AST REWRITE
			// elements: 110, propertyNameAndValue
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 626:3: -> ^( '{' ( propertyNameAndValue )* )
			{
				DebugLocation(626, 6);
				// JavaScript.g:626:6: ^( '{' ( propertyNameAndValue )* )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(626, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new ObjectLiteral(stream_110.NextToken()), root_1);

				DebugLocation(626, 32);
				// JavaScript.g:626:32: ( propertyNameAndValue )*
				while ( stream_propertyNameAndValue.HasNext )
				{
					DebugLocation(626, 32);
					adaptor.AddChild(root_1, stream_propertyNameAndValue.NextTree());

				}
				stream_propertyNameAndValue.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("objectLiteral", 78);
			LeaveRule("objectLiteral", 78);
			LeaveRule_objectLiteral();
			if (state.backtracking > 0) { Memoize(input, 78, objectLiteral_StartIndex); }

		}
		DebugLocation(627, 1);
		} finally { DebugExitRule(GrammarFileName, "objectLiteral"); }
		return retval;

	}
	// $ANTLR end "objectLiteral"

	partial void EnterRule_propertyNameAndValue();
	partial void LeaveRule_propertyNameAndValue();
	// $ANTLR start "propertyNameAndValue"
	// JavaScript.g:629:1: propertyNameAndValue : propertyName ( LT )* ':' ( LT )* assignmentExpression -> ^( ':' propertyName assignmentExpression ) ;
	[GrammarRule("propertyNameAndValue")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyNameAndValue()
	{
		EnterRule_propertyNameAndValue();
		EnterRule("propertyNameAndValue", 79);
		TraceIn("propertyNameAndValue", 79);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyNameAndValue_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken LT418 = default(IToken);
		IToken char_literal419 = default(IToken);
		IToken LT420 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> propertyName417 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> assignmentExpression421 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree LT418_tree = default(CommonTree);
		CommonTree char_literal419_tree = default(CommonTree);
		CommonTree LT420_tree = default(CommonTree);
		RewriteRuleITokenStream stream_LT=new RewriteRuleITokenStream(adaptor,"token LT");
		RewriteRuleITokenStream stream_62=new RewriteRuleITokenStream(adaptor,"token 62");
		RewriteRuleSubtreeStream stream_propertyName=new RewriteRuleSubtreeStream(adaptor,"rule propertyName");
		RewriteRuleSubtreeStream stream_assignmentExpression=new RewriteRuleSubtreeStream(adaptor,"rule assignmentExpression");
		try { DebugEnterRule(GrammarFileName, "propertyNameAndValue");
		DebugLocation(629, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 79)) { return retval; }

			// JavaScript.g:630:2: ( propertyName ( LT )* ':' ( LT )* assignmentExpression -> ^( ':' propertyName assignmentExpression ) )
			DebugEnterAlt(1);
			// JavaScript.g:630:4: propertyName ( LT )* ':' ( LT )* assignmentExpression
			{
			DebugLocation(630, 4);
			PushFollow(Follow._propertyName_in_propertyNameAndValue6368);
			propertyName417=propertyName();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_propertyName.Add(propertyName417.Tree);
			DebugLocation(630, 17);
			// JavaScript.g:630:17: ( LT )*
			try { DebugEnterSubRule(242);
			while (true)
			{
				int alt242=2;
				try { DebugEnterDecision(242, false);
				int LA242_1 = input.LA(1);

				if ((LA242_1==LT))
				{
					alt242 = 1;
				}


				} finally { DebugExitDecision(242); }
				switch ( alt242 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:630:17: LT
					{
					DebugLocation(630, 17);
					LT418=(IToken)Match(input,LT,Follow._LT_in_propertyNameAndValue6370); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT418);


					}
					break;

				default:
					goto loop242;
				}
			}

			loop242:
				;

			} finally { DebugExitSubRule(242); }

			DebugLocation(630, 21);
			char_literal419=(IToken)Match(input,62,Follow._62_in_propertyNameAndValue6373); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_62.Add(char_literal419);

			DebugLocation(630, 25);
			// JavaScript.g:630:25: ( LT )*
			try { DebugEnterSubRule(243);
			while (true)
			{
				int alt243=2;
				try { DebugEnterDecision(243, false);
				int LA243_1 = input.LA(1);

				if ((LA243_1==LT))
				{
					alt243 = 1;
				}


				} finally { DebugExitDecision(243); }
				switch ( alt243 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:630:25: LT
					{
					DebugLocation(630, 25);
					LT420=(IToken)Match(input,LT,Follow._LT_in_propertyNameAndValue6375); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_LT.Add(LT420);


					}
					break;

				default:
					goto loop243;
				}
			}

			loop243:
				;

			} finally { DebugExitSubRule(243); }

			DebugLocation(630, 29);
			PushFollow(Follow._assignmentExpression_in_propertyNameAndValue6378);
			assignmentExpression421=assignmentExpression();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_assignmentExpression.Add(assignmentExpression421.Tree);


			{
			// AST REWRITE
			// elements: 62, propertyName, assignmentExpression
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (CommonTree)adaptor.Nil();
			// 631:3: -> ^( ':' propertyName assignmentExpression )
			{
				DebugLocation(631, 6);
				// JavaScript.g:631:6: ^( ':' propertyName assignmentExpression )
				{
				CommonTree root_1 = (CommonTree)adaptor.Nil();
				DebugLocation(631, 8);
				root_1 = (CommonTree)adaptor.BecomeRoot(new PropertyAssignment(stream_62.NextToken()), root_1);

				DebugLocation(631, 37);
				adaptor.AddChild(root_1, stream_propertyName.NextTree());
				DebugLocation(631, 50);
				adaptor.AddChild(root_1, stream_assignmentExpression.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyNameAndValue", 79);
			LeaveRule("propertyNameAndValue", 79);
			LeaveRule_propertyNameAndValue();
			if (state.backtracking > 0) { Memoize(input, 79, propertyNameAndValue_StartIndex); }

		}
		DebugLocation(632, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyNameAndValue"); }
		return retval;

	}
	// $ANTLR end "propertyNameAndValue"

	partial void EnterRule_propertyName();
	partial void LeaveRule_propertyName();
	// $ANTLR start "propertyName"
	// JavaScript.g:634:1: propertyName : ( Identifier -> Identifier | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral );
	[GrammarRule("propertyName")]
	private AstParserRuleReturnScope<CommonTree, IToken> propertyName()
	{
		EnterRule_propertyName();
		EnterRule("propertyName", 80);
		TraceIn("propertyName", 80);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int propertyName_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken Identifier422 = default(IToken);
		IToken StringLiteral423 = default(IToken);
		IToken NumericLiteral424 = default(IToken);

		CommonTree Identifier422_tree = default(CommonTree);
		CommonTree StringLiteral423_tree = default(CommonTree);
		CommonTree NumericLiteral424_tree = default(CommonTree);
		RewriteRuleITokenStream stream_Identifier=new RewriteRuleITokenStream(adaptor,"token Identifier");
		RewriteRuleITokenStream stream_StringLiteral=new RewriteRuleITokenStream(adaptor,"token StringLiteral");
		RewriteRuleITokenStream stream_NumericLiteral=new RewriteRuleITokenStream(adaptor,"token NumericLiteral");
		try { DebugEnterRule(GrammarFileName, "propertyName");
		DebugLocation(634, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 80)) { return retval; }

			// JavaScript.g:635:2: ( Identifier -> Identifier | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral )
			int alt244=3;
			try { DebugEnterDecision(244, false);
			switch (input.LA(1))
			{
			case Identifier:
				{
				alt244 = 1;
				}
				break;
			case StringLiteral:
				{
				alt244 = 2;
				}
				break;
			case NumericLiteral:
				{
				alt244 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 244, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(244); }
			switch (alt244)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:635:4: Identifier
				{
				DebugLocation(635, 4);
				Identifier422=(IToken)Match(input,Identifier,Follow._Identifier_in_propertyName6407); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_Identifier.Add(Identifier422);



				{
				// AST REWRITE
				// elements: Identifier
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 635:16: -> Identifier
				{
					DebugLocation(635, 19);
					adaptor.AddChild(root_0, new Identifier(stream_Identifier.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:636:4: StringLiteral
				{
				DebugLocation(636, 4);
				StringLiteral423=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_propertyName6422); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_StringLiteral.Add(StringLiteral423);



				{
				// AST REWRITE
				// elements: StringLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 636:19: -> StringLiteral
				{
					DebugLocation(636, 22);
					adaptor.AddChild(root_0, new StringLiteral(stream_StringLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:637:4: NumericLiteral
				{
				DebugLocation(637, 4);
				NumericLiteral424=(IToken)Match(input,NumericLiteral,Follow._NumericLiteral_in_propertyName6437); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NumericLiteral.Add(NumericLiteral424);



				{
				// AST REWRITE
				// elements: NumericLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 637:19: -> NumericLiteral
				{
					DebugLocation(637, 22);
					adaptor.AddChild(root_0, new NumericLiteral(stream_NumericLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("propertyName", 80);
			LeaveRule("propertyName", 80);
			LeaveRule_propertyName();
			if (state.backtracking > 0) { Memoize(input, 80, propertyName_StartIndex); }

		}
		DebugLocation(638, 1);
		} finally { DebugExitRule(GrammarFileName, "propertyName"); }
		return retval;

	}
	// $ANTLR end "propertyName"

	partial void EnterRule_literal();
	partial void LeaveRule_literal();
	// $ANTLR start "literal"
	// JavaScript.g:641:1: literal : ( 'null' -> 'null' | 'true' -> 'true' | 'false' -> 'false' | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral );
	[GrammarRule("literal")]
	private AstParserRuleReturnScope<CommonTree, IToken> literal()
	{
		EnterRule_literal();
		EnterRule("literal", 81);
		TraceIn("literal", 81);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);
		int literal_StartIndex = input.Index;

		CommonTree root_0 = default(CommonTree);

		IToken string_literal425 = default(IToken);
		IToken string_literal426 = default(IToken);
		IToken string_literal427 = default(IToken);
		IToken StringLiteral428 = default(IToken);
		IToken NumericLiteral429 = default(IToken);

		CommonTree string_literal425_tree = default(CommonTree);
		CommonTree string_literal426_tree = default(CommonTree);
		CommonTree string_literal427_tree = default(CommonTree);
		CommonTree StringLiteral428_tree = default(CommonTree);
		CommonTree NumericLiteral429_tree = default(CommonTree);
		RewriteRuleITokenStream stream_98=new RewriteRuleITokenStream(adaptor,"token 98");
		RewriteRuleITokenStream stream_103=new RewriteRuleITokenStream(adaptor,"token 103");
		RewriteRuleITokenStream stream_90=new RewriteRuleITokenStream(adaptor,"token 90");
		RewriteRuleITokenStream stream_StringLiteral=new RewriteRuleITokenStream(adaptor,"token StringLiteral");
		RewriteRuleITokenStream stream_NumericLiteral=new RewriteRuleITokenStream(adaptor,"token NumericLiteral");
		try { DebugEnterRule(GrammarFileName, "literal");
		DebugLocation(641, 1);
		try
		{
			if (state.backtracking > 0 && AlreadyParsedRule(input, 81)) { return retval; }

			// JavaScript.g:642:2: ( 'null' -> 'null' | 'true' -> 'true' | 'false' -> 'false' | StringLiteral -> StringLiteral | NumericLiteral -> NumericLiteral )
			int alt245=5;
			try { DebugEnterDecision(245, false);
			switch (input.LA(1))
			{
			case 98:
				{
				alt245 = 1;
				}
				break;
			case 103:
				{
				alt245 = 2;
				}
				break;
			case 90:
				{
				alt245 = 3;
				}
				break;
			case StringLiteral:
				{
				alt245 = 4;
				}
				break;
			case NumericLiteral:
				{
				alt245 = 5;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 245, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(245); }
			switch (alt245)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:642:4: 'null'
				{
				DebugLocation(642, 4);
				string_literal425=(IToken)Match(input,98,Follow._98_in_literal6458); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_98.Add(string_literal425);



				{
				// AST REWRITE
				// elements: 98
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 642:13: -> 'null'
				{
					DebugLocation(642, 16);
					adaptor.AddChild(root_0, new NullLiteral(stream_98.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:643:4: 'true'
				{
				DebugLocation(643, 4);
				string_literal426=(IToken)Match(input,103,Follow._103_in_literal6474); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_103.Add(string_literal426);



				{
				// AST REWRITE
				// elements: 103
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 643:13: -> 'true'
				{
					DebugLocation(643, 16);
					adaptor.AddChild(root_0, new TrueLiteral(stream_103.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:644:4: 'false'
				{
				DebugLocation(644, 4);
				string_literal427=(IToken)Match(input,90,Follow._90_in_literal6490); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_90.Add(string_literal427);



				{
				// AST REWRITE
				// elements: 90
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 644:14: -> 'false'
				{
					DebugLocation(644, 17);
					adaptor.AddChild(root_0, new FalseLiteral(stream_90.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// JavaScript.g:645:4: StringLiteral
				{
				DebugLocation(645, 4);
				StringLiteral428=(IToken)Match(input,StringLiteral,Follow._StringLiteral_in_literal6506); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_StringLiteral.Add(StringLiteral428);



				{
				// AST REWRITE
				// elements: StringLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 645:19: -> StringLiteral
				{
					DebugLocation(645, 22);
					adaptor.AddChild(root_0, new StringLiteral(stream_StringLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// JavaScript.g:646:4: NumericLiteral
				{
				DebugLocation(646, 4);
				NumericLiteral429=(IToken)Match(input,NumericLiteral,Follow._NumericLiteral_in_literal6521); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_NumericLiteral.Add(NumericLiteral429);



				{
				// AST REWRITE
				// elements: NumericLiteral
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (CommonTree)adaptor.Nil();
				// 646:19: -> NumericLiteral
				{
					DebugLocation(646, 22);
					adaptor.AddChild(root_0, new NumericLiteral(stream_NumericLiteral.NextToken()));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("literal", 81);
			LeaveRule("literal", 81);
			LeaveRule_literal();
			if (state.backtracking > 0) { Memoize(input, 81, literal_StartIndex); }

		}
		DebugLocation(647, 1);
		} finally { DebugExitRule(GrammarFileName, "literal"); }
		return retval;

	}
	// $ANTLR end "literal"

	partial void EnterRule_synpred5_JavaScript_fragment();
	partial void LeaveRule_synpred5_JavaScript_fragment();

	// $ANTLR start synpred5_JavaScript
	public void synpred5_JavaScript_fragment()
	{
		EnterRule_synpred5_JavaScript_fragment();
		EnterRule("synpred5_JavaScript_fragment", 86);
		TraceIn("synpred5_JavaScript_fragment", 86);
		try
		{
			// JavaScript.g:44:4: ( functionDeclaration )
			DebugEnterAlt(1);
			// JavaScript.g:44:4: functionDeclaration
			{
			DebugLocation(44, 4);
			PushFollow(Follow._functionDeclaration_in_synpred5_JavaScript187);
			functionDeclaration();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred5_JavaScript_fragment", 86);
			LeaveRule("synpred5_JavaScript_fragment", 86);
			LeaveRule_synpred5_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred5_JavaScript

	partial void EnterRule_synpred9_JavaScript_fragment();
	partial void LeaveRule_synpred9_JavaScript_fragment();

	// $ANTLR start synpred9_JavaScript
	public void synpred9_JavaScript_fragment()
	{
		EnterRule_synpred9_JavaScript_fragment();
		EnterRule("synpred9_JavaScript_fragment", 90);
		TraceIn("synpred9_JavaScript_fragment", 90);
		try
		{
			// JavaScript.g:58:15: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:58:15: LT
			{
			DebugLocation(58, 15);
			Match(input,LT,Follow._LT_in_synpred9_JavaScript274); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred9_JavaScript_fragment", 90);
			LeaveRule("synpred9_JavaScript_fragment", 90);
			LeaveRule_synpred9_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred9_JavaScript

	partial void EnterRule_synpred19_JavaScript_fragment();
	partial void LeaveRule_synpred19_JavaScript_fragment();

	// $ANTLR start synpred19_JavaScript
	public void synpred19_JavaScript_fragment()
	{
		EnterRule_synpred19_JavaScript_fragment();
		EnterRule("synpred19_JavaScript_fragment", 100);
		TraceIn("synpred19_JavaScript_fragment", 100);
		try
		{
			// JavaScript.g:71:8: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:71:8: LT
			{
			DebugLocation(71, 8);
			Match(input,LT,Follow._LT_in_synpred19_JavaScript397); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred19_JavaScript_fragment", 100);
			LeaveRule("synpred19_JavaScript_fragment", 100);
			LeaveRule_synpred19_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred19_JavaScript

	partial void EnterRule_synpred22_JavaScript_fragment();
	partial void LeaveRule_synpred22_JavaScript_fragment();

	// $ANTLR start synpred22_JavaScript
	public void synpred22_JavaScript_fragment()
	{
		EnterRule_synpred22_JavaScript_fragment();
		EnterRule("synpred22_JavaScript_fragment", 103);
		TraceIn("synpred22_JavaScript_fragment", 103);
		try
		{
			// JavaScript.g:76:4: ( statementBlock )
			DebugEnterAlt(1);
			// JavaScript.g:76:4: statementBlock
			{
			DebugLocation(76, 4);
			PushFollow(Follow._statementBlock_in_synpred22_JavaScript432);
			statementBlock();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred22_JavaScript_fragment", 103);
			LeaveRule("synpred22_JavaScript_fragment", 103);
			LeaveRule_synpred22_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred22_JavaScript

	partial void EnterRule_synpred25_JavaScript_fragment();
	partial void LeaveRule_synpred25_JavaScript_fragment();

	// $ANTLR start synpred25_JavaScript
	public void synpred25_JavaScript_fragment()
	{
		EnterRule_synpred25_JavaScript_fragment();
		EnterRule("synpred25_JavaScript_fragment", 106);
		TraceIn("synpred25_JavaScript_fragment", 106);
		try
		{
			// JavaScript.g:79:4: ( expressionStatement )
			DebugEnterAlt(1);
			// JavaScript.g:79:4: expressionStatement
			{
			DebugLocation(79, 4);
			PushFollow(Follow._expressionStatement_in_synpred25_JavaScript447);
			expressionStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred25_JavaScript_fragment", 106);
			LeaveRule("synpred25_JavaScript_fragment", 106);
			LeaveRule_synpred25_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred25_JavaScript

	partial void EnterRule_synpred32_JavaScript_fragment();
	partial void LeaveRule_synpred32_JavaScript_fragment();

	// $ANTLR start synpred32_JavaScript
	public void synpred32_JavaScript_fragment()
	{
		EnterRule_synpred32_JavaScript_fragment();
		EnterRule("synpred32_JavaScript_fragment", 113);
		TraceIn("synpred32_JavaScript_fragment", 113);
		try
		{
			// JavaScript.g:86:4: ( labelledStatement )
			DebugEnterAlt(1);
			// JavaScript.g:86:4: labelledStatement
			{
			DebugLocation(86, 4);
			PushFollow(Follow._labelledStatement_in_synpred32_JavaScript482);
			labelledStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred32_JavaScript_fragment", 113);
			LeaveRule("synpred32_JavaScript_fragment", 113);
			LeaveRule_synpred32_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred32_JavaScript

	partial void EnterRule_synpred35_JavaScript_fragment();
	partial void LeaveRule_synpred35_JavaScript_fragment();

	// $ANTLR start synpred35_JavaScript
	public void synpred35_JavaScript_fragment()
	{
		EnterRule_synpred35_JavaScript_fragment();
		EnterRule("synpred35_JavaScript_fragment", 116);
		TraceIn("synpred35_JavaScript_fragment", 116);
		try
		{
			// JavaScript.g:93:8: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:93:8: LT
			{
			DebugLocation(93, 8);
			Match(input,LT,Follow._LT_in_synpred35_JavaScript511); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred35_JavaScript_fragment", 116);
			LeaveRule("synpred35_JavaScript_fragment", 116);
			LeaveRule_synpred35_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred35_JavaScript

	partial void EnterRule_synpred48_JavaScript_fragment();
	partial void LeaveRule_synpred48_JavaScript_fragment();

	// $ANTLR start synpred48_JavaScript
	public void synpred48_JavaScript_fragment()
	{
		EnterRule_synpred48_JavaScript_fragment();
		EnterRule("synpred48_JavaScript_fragment", 129);
		TraceIn("synpred48_JavaScript_fragment", 129);
		try
		{
			// JavaScript.g:114:15: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:114:15: LT
			{
			DebugLocation(114, 15);
			Match(input,LT,Follow._LT_in_synpred48_JavaScript670); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred48_JavaScript_fragment", 129);
			LeaveRule("synpred48_JavaScript_fragment", 129);
			LeaveRule_synpred48_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred48_JavaScript

	partial void EnterRule_synpred50_JavaScript_fragment();
	partial void LeaveRule_synpred50_JavaScript_fragment();

	// $ANTLR start synpred50_JavaScript
	public void synpred50_JavaScript_fragment()
	{
		EnterRule_synpred50_JavaScript_fragment();
		EnterRule("synpred50_JavaScript_fragment", 131);
		TraceIn("synpred50_JavaScript_fragment", 131);
		try
		{
			// JavaScript.g:121:15: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:121:15: LT
			{
			DebugLocation(121, 15);
			Match(input,LT,Follow._LT_in_synpred50_JavaScript722); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred50_JavaScript_fragment", 131);
			LeaveRule("synpred50_JavaScript_fragment", 131);
			LeaveRule_synpred50_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred50_JavaScript

	partial void EnterRule_synpred61_JavaScript_fragment();
	partial void LeaveRule_synpred61_JavaScript_fragment();

	// $ANTLR start synpred61_JavaScript
	public void synpred61_JavaScript_fragment()
	{
		AstParserRuleReturnScope<CommonTree, IToken> elsestmt = default(AstParserRuleReturnScope<CommonTree, IToken>);

		EnterRule_synpred61_JavaScript_fragment();
		EnterRule("synpred61_JavaScript_fragment", 142);
		TraceIn("synpred61_JavaScript_fragment", 142);
		try
		{
			// JavaScript.g:144:62: ( ( LT )* 'else' ( LT )* elsestmt= statement )
			DebugEnterAlt(1);
			// JavaScript.g:144:62: ( LT )* 'else' ( LT )* elsestmt= statement
			{
			DebugLocation(144, 62);
			// JavaScript.g:144:62: ( LT )*
			try { DebugEnterSubRule(258);
			while (true)
			{
				int alt258=2;
				try { DebugEnterDecision(258, false);
				int LA258_1 = input.LA(1);

				if ((LA258_1==LT))
				{
					alt258 = 1;
				}


				} finally { DebugExitDecision(258); }
				switch ( alt258 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:62: LT
					{
					DebugLocation(144, 62);
					Match(input,LT,Follow._LT_in_synpred61_JavaScript885); if (state.failed) return;

					}
					break;

				default:
					goto loop258;
				}
			}

			loop258:
				;

			} finally { DebugExitSubRule(258); }

			DebugLocation(144, 66);
			Match(input,89,Follow._89_in_synpred61_JavaScript888); if (state.failed) return;
			DebugLocation(144, 73);
			// JavaScript.g:144:73: ( LT )*
			try { DebugEnterSubRule(259);
			while (true)
			{
				int alt259=2;
				try { DebugEnterDecision(259, false);
				int LA259_1 = input.LA(1);

				if ((LA259_1==LT))
				{
					alt259 = 1;
				}


				} finally { DebugExitDecision(259); }
				switch ( alt259 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:144:73: LT
					{
					DebugLocation(144, 73);
					Match(input,LT,Follow._LT_in_synpred61_JavaScript890); if (state.failed) return;

					}
					break;

				default:
					goto loop259;
				}
			}

			loop259:
				;

			} finally { DebugExitSubRule(259); }

			DebugLocation(144, 85);
			PushFollow(Follow._statement_in_synpred61_JavaScript895);
			elsestmt=statement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred61_JavaScript_fragment", 142);
			LeaveRule("synpred61_JavaScript_fragment", 142);
			LeaveRule_synpred61_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred61_JavaScript

	partial void EnterRule_synpred64_JavaScript_fragment();
	partial void LeaveRule_synpred64_JavaScript_fragment();

	// $ANTLR start synpred64_JavaScript
	public void synpred64_JavaScript_fragment()
	{
		EnterRule_synpred64_JavaScript_fragment();
		EnterRule("synpred64_JavaScript_fragment", 145);
		TraceIn("synpred64_JavaScript_fragment", 145);
		try
		{
			// JavaScript.g:151:4: ( forStatement )
			DebugEnterAlt(1);
			// JavaScript.g:151:4: forStatement
			{
			DebugLocation(151, 4);
			PushFollow(Follow._forStatement_in_synpred64_JavaScript941);
			forStatement();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred64_JavaScript_fragment", 145);
			LeaveRule("synpred64_JavaScript_fragment", 145);
			LeaveRule_synpred64_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred64_JavaScript

	partial void EnterRule_synpred119_JavaScript_fragment();
	partial void LeaveRule_synpred119_JavaScript_fragment();

	// $ANTLR start synpred119_JavaScript
	public void synpred119_JavaScript_fragment()
	{
		EnterRule_synpred119_JavaScript_fragment();
		EnterRule("synpred119_JavaScript_fragment", 200);
		TraceIn("synpred119_JavaScript_fragment", 200);
		try
		{
			// JavaScript.g:226:34: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:226:34: LT
			{
			DebugLocation(226, 34);
			Match(input,LT,Follow._LT_in_synpred119_JavaScript1677); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred119_JavaScript_fragment", 200);
			LeaveRule("synpred119_JavaScript_fragment", 200);
			LeaveRule_synpred119_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred119_JavaScript

	partial void EnterRule_synpred122_JavaScript_fragment();
	partial void LeaveRule_synpred122_JavaScript_fragment();

	// $ANTLR start synpred122_JavaScript
	public void synpred122_JavaScript_fragment()
	{
		EnterRule_synpred122_JavaScript_fragment();
		EnterRule("synpred122_JavaScript_fragment", 203);
		TraceIn("synpred122_JavaScript_fragment", 203);
		try
		{
			// JavaScript.g:230:22: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:230:22: LT
			{
			DebugLocation(230, 22);
			Match(input,LT,Follow._LT_in_synpred122_JavaScript1716); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred122_JavaScript_fragment", 203);
			LeaveRule("synpred122_JavaScript_fragment", 203);
			LeaveRule_synpred122_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred122_JavaScript

	partial void EnterRule_synpred141_JavaScript_fragment();
	partial void LeaveRule_synpred141_JavaScript_fragment();

	// $ANTLR start synpred141_JavaScript
	public void synpred141_JavaScript_fragment()
	{
		EnterRule_synpred141_JavaScript_fragment();
		EnterRule("synpred141_JavaScript_fragment", 222);
		TraceIn("synpred141_JavaScript_fragment", 222);
		try
		{
			// JavaScript.g:261:4: ( conditionalExpression )
			DebugEnterAlt(1);
			// JavaScript.g:261:4: conditionalExpression
			{
			DebugLocation(261, 4);
			PushFollow(Follow._conditionalExpression_in_synpred141_JavaScript1987);
			conditionalExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred141_JavaScript_fragment", 222);
			LeaveRule("synpred141_JavaScript_fragment", 222);
			LeaveRule_synpred141_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred141_JavaScript

	partial void EnterRule_synpred144_JavaScript_fragment();
	partial void LeaveRule_synpred144_JavaScript_fragment();

	// $ANTLR start synpred144_JavaScript
	public void synpred144_JavaScript_fragment()
	{
		EnterRule_synpred144_JavaScript_fragment();
		EnterRule("synpred144_JavaScript_fragment", 225);
		TraceIn("synpred144_JavaScript_fragment", 225);
		try
		{
			// JavaScript.g:279:4: ( conditionalExpressionNoIn )
			DebugEnterAlt(1);
			// JavaScript.g:279:4: conditionalExpressionNoIn
			{
			DebugLocation(279, 4);
			PushFollow(Follow._conditionalExpressionNoIn_in_synpred144_JavaScript2299);
			conditionalExpressionNoIn();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred144_JavaScript_fragment", 225);
			LeaveRule("synpred144_JavaScript_fragment", 225);
			LeaveRule_synpred144_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred144_JavaScript

	partial void EnterRule_synpred158_JavaScript_fragment();
	partial void LeaveRule_synpred158_JavaScript_fragment();

	// $ANTLR start synpred158_JavaScript
	public void synpred158_JavaScript_fragment()
	{
		EnterRule_synpred158_JavaScript_fragment();
		EnterRule("synpred158_JavaScript_fragment", 239);
		TraceIn("synpred158_JavaScript_fragment", 239);
		try
		{
			// JavaScript.g:301:4: ( callExpression )
			DebugEnterAlt(1);
			// JavaScript.g:301:4: callExpression
			{
			DebugLocation(301, 4);
			PushFollow(Follow._callExpression_in_synpred158_JavaScript2665);
			callExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred158_JavaScript_fragment", 239);
			LeaveRule("synpred158_JavaScript_fragment", 239);
			LeaveRule_synpred158_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred158_JavaScript

	partial void EnterRule_synpred159_JavaScript_fragment();
	partial void LeaveRule_synpred159_JavaScript_fragment();

	// $ANTLR start synpred159_JavaScript
	public void synpred159_JavaScript_fragment()
	{
		EnterRule_synpred159_JavaScript_fragment();
		EnterRule("synpred159_JavaScript_fragment", 240);
		TraceIn("synpred159_JavaScript_fragment", 240);
		try
		{
			// JavaScript.g:306:4: ( memberExpression )
			DebugEnterAlt(1);
			// JavaScript.g:306:4: memberExpression
			{
			DebugLocation(306, 4);
			PushFollow(Follow._memberExpression_in_synpred159_JavaScript2682);
			memberExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred159_JavaScript_fragment", 240);
			LeaveRule("synpred159_JavaScript_fragment", 240);
			LeaveRule_synpred159_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred159_JavaScript

	partial void EnterRule_synpred163_JavaScript_fragment();
	partial void LeaveRule_synpred163_JavaScript_fragment();

	// $ANTLR start synpred163_JavaScript
	public void synpred163_JavaScript_fragment()
	{
		EnterRule_synpred163_JavaScript_fragment();
		EnterRule("synpred163_JavaScript_fragment", 244);
		TraceIn("synpred163_JavaScript_fragment", 244);
		try
		{
			// JavaScript.g:314:13: ( ( LT )* ( indexSuffix | propertyReferenceSuffix ) )
			DebugEnterAlt(1);
			// JavaScript.g:314:13: ( LT )* ( indexSuffix | propertyReferenceSuffix )
			{
			DebugLocation(314, 13);
			// JavaScript.g:314:13: ( LT )*
			try { DebugEnterSubRule(273);
			while (true)
			{
				int alt273=2;
				try { DebugEnterDecision(273, false);
				int LA273_1 = input.LA(1);

				if ((LA273_1==LT))
				{
					alt273 = 1;
				}


				} finally { DebugExitDecision(273); }
				switch ( alt273 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:314:13: LT
					{
					DebugLocation(314, 13);
					Match(input,LT,Follow._LT_in_synpred163_JavaScript2758); if (state.failed) return;

					}
					break;

				default:
					goto loop273;
				}
			}

			loop273:
				;

			} finally { DebugExitSubRule(273); }

			DebugLocation(315, 13);
			// JavaScript.g:315:13: ( indexSuffix | propertyReferenceSuffix )
			int alt274=2;
			try { DebugEnterSubRule(274);
			try { DebugEnterDecision(274, false);
			int LA274_1 = input.LA(1);

			if ((LA274_1==78))
			{
				alt274 = 1;
			}
			else if ((LA274_1==59))
			{
				alt274 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 274, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(274); }
			switch (alt274)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:316:17: indexSuffix
				{
				DebugLocation(316, 17);
				PushFollow(Follow._indexSuffix_in_synpred163_JavaScript2792);
				indexSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:317:19: propertyReferenceSuffix
				{
				DebugLocation(317, 19);
				PushFollow(Follow._propertyReferenceSuffix_in_synpred163_JavaScript2856);
				propertyReferenceSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(274); }


			}

		}
		finally
		{
			TraceOut("synpred163_JavaScript_fragment", 244);
			LeaveRule("synpred163_JavaScript_fragment", 244);
			LeaveRule_synpred163_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred163_JavaScript

	partial void EnterRule_synpred171_JavaScript_fragment();
	partial void LeaveRule_synpred171_JavaScript_fragment();

	// $ANTLR start synpred171_JavaScript
	public void synpred171_JavaScript_fragment()
	{
		AstParserRuleReturnScope<CommonTree, IToken> args = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> idx = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> prop = default(AstParserRuleReturnScope<CommonTree, IToken>);

		EnterRule_synpred171_JavaScript_fragment();
		EnterRule("synpred171_JavaScript_fragment", 252);
		TraceIn("synpred171_JavaScript_fragment", 252);
		try
		{
			// JavaScript.g:332:13: ( ( LT )* (args= arguments |idx= indexSuffix |prop= propertyReferenceSuffix ) )
			DebugEnterAlt(1);
			// JavaScript.g:332:13: ( LT )* (args= arguments |idx= indexSuffix |prop= propertyReferenceSuffix )
			{
			DebugLocation(332, 13);
			// JavaScript.g:332:13: ( LT )*
			try { DebugEnterSubRule(275);
			while (true)
			{
				int alt275=2;
				try { DebugEnterDecision(275, false);
				int LA275_1 = input.LA(1);

				if ((LA275_1==LT))
				{
					alt275 = 1;
				}


				} finally { DebugExitDecision(275); }
				switch ( alt275 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:332:13: LT
					{
					DebugLocation(332, 13);
					Match(input,LT,Follow._LT_in_synpred171_JavaScript3075); if (state.failed) return;

					}
					break;

				default:
					goto loop275;
				}
			}

			loop275:
				;

			} finally { DebugExitSubRule(275); }

			DebugLocation(333, 13);
			// JavaScript.g:333:13: (args= arguments |idx= indexSuffix |prop= propertyReferenceSuffix )
			int alt276=3;
			try { DebugEnterSubRule(276);
			try { DebugEnterDecision(276, false);
			switch (input.LA(1))
			{
			case 48:
				{
				alt276 = 1;
				}
				break;
			case 78:
				{
				alt276 = 2;
				}
				break;
			case 59:
				{
				alt276 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return;}
					NoViableAltException nvae = new NoViableAltException("", 276, 0, input, 1);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(276); }
			switch (alt276)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:334:17: args= arguments
				{
				DebugLocation(334, 21);
				PushFollow(Follow._arguments_in_synpred171_JavaScript3111);
				args=arguments();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:335:16: idx= indexSuffix
				{
				DebugLocation(335, 19);
				PushFollow(Follow._indexSuffix_in_synpred171_JavaScript3164);
				idx=indexSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// JavaScript.g:336:16: prop= propertyReferenceSuffix
				{
				DebugLocation(336, 20);
				PushFollow(Follow._propertyReferenceSuffix_in_synpred171_JavaScript3214);
				prop=propertyReferenceSuffix();
				PopFollow();
				if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(276); }


			}

		}
		finally
		{
			TraceOut("synpred171_JavaScript_fragment", 252);
			LeaveRule("synpred171_JavaScript_fragment", 252);
			LeaveRule_synpred171_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred171_JavaScript

	partial void EnterRule_synpred257_JavaScript_fragment();
	partial void LeaveRule_synpred257_JavaScript_fragment();

	// $ANTLR start synpred257_JavaScript
	public void synpred257_JavaScript_fragment()
	{
		IToken op = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> add = default(AstParserRuleReturnScope<CommonTree, IToken>);

		EnterRule_synpred257_JavaScript_fragment();
		EnterRule("synpred257_JavaScript_fragment", 338);
		TraceIn("synpred257_JavaScript_fragment", 338);
		try
		{
			// JavaScript.g:559:7: ( ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression )
			DebugEnterAlt(1);
			// JavaScript.g:559:7: ( LT )* (op= '+' |op= '-' ) ( LT )* add= additiveExpression
			{
			DebugLocation(559, 7);
			// JavaScript.g:559:7: ( LT )*
			try { DebugEnterSubRule(324);
			while (true)
			{
				int alt324=2;
				try { DebugEnterDecision(324, false);
				int LA324_1 = input.LA(1);

				if ((LA324_1==LT))
				{
					alt324 = 1;
				}


				} finally { DebugExitDecision(324); }
				switch ( alt324 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:559:7: LT
					{
					DebugLocation(559, 7);
					Match(input,LT,Follow._LT_in_synpred257_JavaScript5399); if (state.failed) return;

					}
					break;

				default:
					goto loop324;
				}
			}

			loop324:
				;

			} finally { DebugExitSubRule(324); }

			DebugLocation(559, 11);
			// JavaScript.g:559:11: (op= '+' |op= '-' )
			int alt325=2;
			try { DebugEnterSubRule(325);
			try { DebugEnterDecision(325, false);
			int LA325_1 = input.LA(1);

			if ((LA325_1==52))
			{
				alt325 = 1;
			}
			else if ((LA325_1==56))
			{
				alt325 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return;}
				NoViableAltException nvae = new NoViableAltException("", 325, 0, input, 1);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(325); }
			switch (alt325)
			{
			case 1:
				DebugEnterAlt(1);
				// JavaScript.g:559:12: op= '+'
				{
				DebugLocation(559, 14);
				op=(IToken)Match(input,52,Follow._52_in_synpred257_JavaScript5405); if (state.failed) return;

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// JavaScript.g:559:21: op= '-'
				{
				DebugLocation(559, 23);
				op=(IToken)Match(input,56,Follow._56_in_synpred257_JavaScript5411); if (state.failed) return;

				}
				break;

			}
			} finally { DebugExitSubRule(325); }

			DebugLocation(559, 29);
			// JavaScript.g:559:29: ( LT )*
			try { DebugEnterSubRule(326);
			while (true)
			{
				int alt326=2;
				try { DebugEnterDecision(326, false);
				int LA326_1 = input.LA(1);

				if ((LA326_1==LT))
				{
					alt326 = 1;
				}


				} finally { DebugExitDecision(326); }
				switch ( alt326 )
				{
				case 1:
					DebugEnterAlt(1);
					// JavaScript.g:559:29: LT
					{
					DebugLocation(559, 29);
					Match(input,LT,Follow._LT_in_synpred257_JavaScript5414); if (state.failed) return;

					}
					break;

				default:
					goto loop326;
				}
			}

			loop326:
				;

			} finally { DebugExitSubRule(326); }

			DebugLocation(559, 36);
			PushFollow(Follow._additiveExpression_in_synpred257_JavaScript5419);
			add=additiveExpression();
			PopFollow();
			if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred257_JavaScript_fragment", 338);
			LeaveRule("synpred257_JavaScript_fragment", 338);
			LeaveRule_synpred257_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred257_JavaScript

	partial void EnterRule_synpred281_JavaScript_fragment();
	partial void LeaveRule_synpred281_JavaScript_fragment();

	// $ANTLR start synpred281_JavaScript
	public void synpred281_JavaScript_fragment()
	{
		EnterRule_synpred281_JavaScript_fragment();
		EnterRule("synpred281_JavaScript_fragment", 362);
		TraceIn("synpred281_JavaScript_fragment", 362);
		try
		{
			// JavaScript.g:619:8: ( LT )
			DebugEnterAlt(1);
			// JavaScript.g:619:8: LT
			{
			DebugLocation(619, 8);
			Match(input,LT,Follow._LT_in_synpred281_JavaScript6254); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred281_JavaScript_fragment", 362);
			LeaveRule("synpred281_JavaScript_fragment", 362);
			LeaveRule_synpred281_JavaScript_fragment();
		}
	}
	// $ANTLR end synpred281_JavaScript
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA4 dfa4;
	private DFA17 dfa17;
	private DFA16 dfa16;
	private DFA27 dfa27;
	private DFA32 dfa32;
	private DFA35 dfa35;
	private DFA61 dfa61;
	private DFA64 dfa64;
	private DFA67 dfa67;
	private DFA97 dfa97;
	private DFA101 dfa101;
	private DFA100 dfa100;
	private DFA114 dfa114;
	private DFA123 dfa123;
	private DFA126 dfa126;
	private DFA150 dfa150;
	private DFA149 dfa149;
	private DFA159 dfa159;
	private DFA164 dfa164;
	private DFA167 dfa167;
	private DFA170 dfa170;
	private DFA173 dfa173;
	private DFA176 dfa176;
	private DFA179 dfa179;
	private DFA182 dfa182;
	private DFA185 dfa185;
	private DFA188 dfa188;
	private DFA191 dfa191;
	private DFA194 dfa194;
	private DFA198 dfa198;
	private DFA202 dfa202;
	private DFA206 dfa206;
	private DFA210 dfa210;
	private DFA214 dfa214;
	private DFA222 dfa222;
	private DFA234 dfa234;
	private DFA233 dfa233;
	private DFA240 dfa240;
	private DFA239 dfa239;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa4 = new DFA4( this );
		dfa17 = new DFA17( this );
		dfa16 = new DFA16( this );
		dfa27 = new DFA27( this );
		dfa32 = new DFA32( this );
		dfa35 = new DFA35( this );
		dfa61 = new DFA61( this );
		dfa64 = new DFA64( this );
		dfa67 = new DFA67( this );
		dfa97 = new DFA97( this );
		dfa101 = new DFA101( this );
		dfa100 = new DFA100( this );
		dfa114 = new DFA114( this );
		dfa123 = new DFA123( this );
		dfa126 = new DFA126( this );
		dfa150 = new DFA150( this );
		dfa149 = new DFA149( this );
		dfa159 = new DFA159( this );
		dfa164 = new DFA164( this );
		dfa167 = new DFA167( this );
		dfa170 = new DFA170( this );
		dfa173 = new DFA173( this );
		dfa176 = new DFA176( this );
		dfa179 = new DFA179( this );
		dfa182 = new DFA182( this );
		dfa185 = new DFA185( this );
		dfa188 = new DFA188( this );
		dfa191 = new DFA191( this );
		dfa194 = new DFA194( this );
		dfa198 = new DFA198( this );
		dfa202 = new DFA202( this );
		dfa206 = new DFA206( this );
		dfa210 = new DFA210( this );
		dfa214 = new DFA214( this );
		dfa222 = new DFA222( this );
		dfa234 = new DFA234( this );
		dfa233 = new DFA233( this );
		dfa240 = new DFA240( this );
		dfa239 = new DFA239( this );
	}

	private class DFA4 : DFA
	{
		private const string DFA4_eotS =
			"\x4\xFFFF";
		private const string DFA4_eofS =
			"\x2\x2\x2\xFFFF";
		private const string DFA4_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA4_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA4_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA4_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA4_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1\xFFFF\x1\x3\x1\xFFFF"+
				"\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1\xFFFF\x1\x3\x1\xFFFF"+
				"\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA4_eot = DFA.UnpackEncodedString(DFA4_eotS);
		private static readonly short[] DFA4_eof = DFA.UnpackEncodedString(DFA4_eofS);
		private static readonly char[] DFA4_min = DFA.UnpackEncodedStringToUnsignedChars(DFA4_minS);
		private static readonly char[] DFA4_max = DFA.UnpackEncodedStringToUnsignedChars(DFA4_maxS);
		private static readonly short[] DFA4_accept = DFA.UnpackEncodedString(DFA4_acceptS);
		private static readonly short[] DFA4_special = DFA.UnpackEncodedString(DFA4_specialS);
		private static readonly short[][] DFA4_transition;

		static DFA4()
		{
			int numStates = DFA4_transitionS.Length;
			DFA4_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA4_transition[i] = DFA.UnpackEncodedString(DFA4_transitionS[i]);
			}
		}

		public DFA4( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 4;
			this.eot = DFA4_eot;
			this.eof = DFA4_eof;
			this.min = DFA4_min;
			this.max = DFA4_max;
			this.accept = DFA4_accept;
			this.special = DFA4_special;
			this.transition = DFA4_transition;
		}

		public override string Description { get { return "()* loopback of 40:18: ( ( LT )* sourceElement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA17 : DFA
	{
		private const string DFA17_eotS =
			"\x4\xFFFF";
		private const string DFA17_eofS =
			"\x4\xFFFF";
		private const string DFA17_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA17_maxS =
			"\x2\x31\x2\xFFFF";
		private const string DFA17_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA17_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA17_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x18\xFFFF\x1\x3",
				"\x1\x2\x2\xFFFF\x1\x1\x18\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA17_eot = DFA.UnpackEncodedString(DFA17_eotS);
		private static readonly short[] DFA17_eof = DFA.UnpackEncodedString(DFA17_eofS);
		private static readonly char[] DFA17_min = DFA.UnpackEncodedStringToUnsignedChars(DFA17_minS);
		private static readonly char[] DFA17_max = DFA.UnpackEncodedStringToUnsignedChars(DFA17_maxS);
		private static readonly short[] DFA17_accept = DFA.UnpackEncodedString(DFA17_acceptS);
		private static readonly short[] DFA17_special = DFA.UnpackEncodedString(DFA17_specialS);
		private static readonly short[][] DFA17_transition;

		static DFA17()
		{
			int numStates = DFA17_transitionS.Length;
			DFA17_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA17_transition[i] = DFA.UnpackEncodedString(DFA17_transitionS[i]);
			}
		}

		public DFA17( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 17;
			this.eot = DFA17_eot;
			this.eof = DFA17_eof;
			this.min = DFA17_min;
			this.max = DFA17_max;
			this.accept = DFA17_accept;
			this.special = DFA17_special;
			this.transition = DFA17_transition;
		}

		public override string Description { get { return "66:8: ( ( LT )* Identifier ( ( LT )* ',' ( LT )* Identifier )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA16 : DFA
	{
		private const string DFA16_eotS =
			"\x4\xFFFF";
		private const string DFA16_eofS =
			"\x4\xFFFF";
		private const string DFA16_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA16_maxS =
			"\x2\x37\x2\xFFFF";
		private const string DFA16_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA16_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA16_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA16_eot = DFA.UnpackEncodedString(DFA16_eotS);
		private static readonly short[] DFA16_eof = DFA.UnpackEncodedString(DFA16_eofS);
		private static readonly char[] DFA16_min = DFA.UnpackEncodedStringToUnsignedChars(DFA16_minS);
		private static readonly char[] DFA16_max = DFA.UnpackEncodedStringToUnsignedChars(DFA16_maxS);
		private static readonly short[] DFA16_accept = DFA.UnpackEncodedString(DFA16_acceptS);
		private static readonly short[] DFA16_special = DFA.UnpackEncodedString(DFA16_specialS);
		private static readonly short[][] DFA16_transition;

		static DFA16()
		{
			int numStates = DFA16_transitionS.Length;
			DFA16_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA16_transition[i] = DFA.UnpackEncodedString(DFA16_transitionS[i]);
			}
		}

		public DFA16( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 16;
			this.eot = DFA16_eot;
			this.eof = DFA16_eof;
			this.min = DFA16_min;
			this.max = DFA16_max;
			this.accept = DFA16_accept;
			this.special = DFA16_special;
			this.transition = DFA16_transition;
		}

		public override string Description { get { return "()* loopback of 66:24: ( ( LT )* ',' ( LT )* Identifier )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA27 : DFA
	{
		private const string DFA27_eotS =
			"\x4\xFFFF";
		private const string DFA27_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA27_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA27_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA27_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA27_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA27_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x1\x2\x1\xFFFF\x1\x3\x1\x2\x2\x3\x1\xFFFF\x1\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x1\x3\x1\x2\x1\xFFFF\x1\x3\x1\x2\x2\x3\x1\xFFFF\x1\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF\x1\x2\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA27_eot = DFA.UnpackEncodedString(DFA27_eotS);
		private static readonly short[] DFA27_eof = DFA.UnpackEncodedString(DFA27_eofS);
		private static readonly char[] DFA27_min = DFA.UnpackEncodedStringToUnsignedChars(DFA27_minS);
		private static readonly char[] DFA27_max = DFA.UnpackEncodedStringToUnsignedChars(DFA27_maxS);
		private static readonly short[] DFA27_accept = DFA.UnpackEncodedString(DFA27_acceptS);
		private static readonly short[] DFA27_special = DFA.UnpackEncodedString(DFA27_specialS);
		private static readonly short[][] DFA27_transition;

		static DFA27()
		{
			int numStates = DFA27_transitionS.Length;
			DFA27_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA27_transition[i] = DFA.UnpackEncodedString(DFA27_transitionS[i]);
			}
		}

		public DFA27( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 27;
			this.eot = DFA27_eot;
			this.eof = DFA27_eof;
			this.min = DFA27_min;
			this.max = DFA27_max;
			this.accept = DFA27_accept;
			this.special = DFA27_special;
			this.transition = DFA27_transition;
		}

		public override string Description { get { return "()* loopback of 97:14: ( ( LT !)* statement )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA32 : DFA
	{
		private const string DFA32_eotS =
			"\x5\xFFFF";
		private const string DFA32_eofS =
			"\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2";
		private const string DFA32_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA32_maxS =
			"\x1\x3F\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA32_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA32_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA32_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x5\xFFFF\x1\x2\xE\xFFFF"+
				"\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2",
				"",
				"",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x5\xFFFF\x1\x2\xE\xFFFF"+
				"\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2"
			};

		private static readonly short[] DFA32_eot = DFA.UnpackEncodedString(DFA32_eotS);
		private static readonly short[] DFA32_eof = DFA.UnpackEncodedString(DFA32_eofS);
		private static readonly char[] DFA32_min = DFA.UnpackEncodedStringToUnsignedChars(DFA32_minS);
		private static readonly char[] DFA32_max = DFA.UnpackEncodedStringToUnsignedChars(DFA32_maxS);
		private static readonly short[] DFA32_accept = DFA.UnpackEncodedString(DFA32_acceptS);
		private static readonly short[] DFA32_special = DFA.UnpackEncodedString(DFA32_specialS);
		private static readonly short[][] DFA32_transition;

		static DFA32()
		{
			int numStates = DFA32_transitionS.Length;
			DFA32_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA32_transition[i] = DFA.UnpackEncodedString(DFA32_transitionS[i]);
			}
		}

		public DFA32( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 32;
			this.eot = DFA32_eot;
			this.eof = DFA32_eof;
			this.min = DFA32_min;
			this.max = DFA32_max;
			this.accept = DFA32_accept;
			this.special = DFA32_special;
			this.transition = DFA32_transition;
		}

		public override string Description { get { return "()* loopback of 106:24: ( ( LT )* ',' ( LT )* variableDeclaration )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA35 : DFA
	{
		private const string DFA35_eotS =
			"\x4\xFFFF";
		private const string DFA35_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA35_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA35_maxS =
			"\x2\x3F\x2\xFFFF";
		private const string DFA35_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA35_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA35_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA35_eot = DFA.UnpackEncodedString(DFA35_eotS);
		private static readonly short[] DFA35_eof = DFA.UnpackEncodedString(DFA35_eofS);
		private static readonly char[] DFA35_min = DFA.UnpackEncodedStringToUnsignedChars(DFA35_minS);
		private static readonly char[] DFA35_max = DFA.UnpackEncodedStringToUnsignedChars(DFA35_maxS);
		private static readonly short[] DFA35_accept = DFA.UnpackEncodedString(DFA35_acceptS);
		private static readonly short[] DFA35_special = DFA.UnpackEncodedString(DFA35_specialS);
		private static readonly short[][] DFA35_transition;

		static DFA35()
		{
			int numStates = DFA35_transitionS.Length;
			DFA35_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA35_transition[i] = DFA.UnpackEncodedString(DFA35_transitionS[i]);
			}
		}

		public DFA35( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 35;
			this.eot = DFA35_eot;
			this.eof = DFA35_eof;
			this.min = DFA35_min;
			this.max = DFA35_max;
			this.accept = DFA35_accept;
			this.special = DFA35_special;
			this.transition = DFA35_transition;
		}

		public override string Description { get { return "()* loopback of 110:28: ( ( LT )* ',' ( LT )* variableDeclarationNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA61 : DFA
	{
		private const string DFA61_eotS =
			"\x4\xFFFF";
		private const string DFA61_eofS =
			"\x4\xFFFF";
		private const string DFA61_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA61_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA61_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA61_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA61_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x3\x2\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA61_eot = DFA.UnpackEncodedString(DFA61_eotS);
		private static readonly short[] DFA61_eof = DFA.UnpackEncodedString(DFA61_eofS);
		private static readonly char[] DFA61_min = DFA.UnpackEncodedStringToUnsignedChars(DFA61_minS);
		private static readonly char[] DFA61_max = DFA.UnpackEncodedStringToUnsignedChars(DFA61_maxS);
		private static readonly short[] DFA61_accept = DFA.UnpackEncodedString(DFA61_acceptS);
		private static readonly short[] DFA61_special = DFA.UnpackEncodedString(DFA61_specialS);
		private static readonly short[][] DFA61_transition;

		static DFA61()
		{
			int numStates = DFA61_transitionS.Length;
			DFA61_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA61_transition[i] = DFA.UnpackEncodedString(DFA61_transitionS[i]);
			}
		}

		public DFA61( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 61;
			this.eot = DFA61_eot;
			this.eof = DFA61_eof;
			this.min = DFA61_min;
			this.max = DFA61_max;
			this.accept = DFA61_accept;
			this.special = DFA61_special;
			this.transition = DFA61_transition;
		}

		public override string Description { get { return "166:18: ( ( LT )* forStatementInitialiserPart )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA64 : DFA
	{
		private const string DFA64_eotS =
			"\x4\xFFFF";
		private const string DFA64_eofS =
			"\x4\xFFFF";
		private const string DFA64_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA64_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA64_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA64_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA64_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x2\x2\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x2\x8\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA64_eot = DFA.UnpackEncodedString(DFA64_eotS);
		private static readonly short[] DFA64_eof = DFA.UnpackEncodedString(DFA64_eofS);
		private static readonly char[] DFA64_min = DFA.UnpackEncodedStringToUnsignedChars(DFA64_minS);
		private static readonly char[] DFA64_max = DFA.UnpackEncodedStringToUnsignedChars(DFA64_maxS);
		private static readonly short[] DFA64_accept = DFA.UnpackEncodedString(DFA64_acceptS);
		private static readonly short[] DFA64_special = DFA.UnpackEncodedString(DFA64_specialS);
		private static readonly short[][] DFA64_transition;

		static DFA64()
		{
			int numStates = DFA64_transitionS.Length;
			DFA64_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA64_transition[i] = DFA.UnpackEncodedString(DFA64_transitionS[i]);
			}
		}

		public DFA64( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 64;
			this.eot = DFA64_eot;
			this.eof = DFA64_eof;
			this.min = DFA64_min;
			this.max = DFA64_max;
			this.accept = DFA64_accept;
			this.special = DFA64_special;
			this.transition = DFA64_transition;
		}

		public override string Description { get { return "166:61: ( ( LT )* condition= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA67 : DFA
	{
		private const string DFA67_eotS =
			"\x4\xFFFF";
		private const string DFA67_eofS =
			"\x4\xFFFF";
		private const string DFA67_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA67_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA67_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA67_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA67_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA67_eot = DFA.UnpackEncodedString(DFA67_eotS);
		private static readonly short[] DFA67_eof = DFA.UnpackEncodedString(DFA67_eofS);
		private static readonly char[] DFA67_min = DFA.UnpackEncodedStringToUnsignedChars(DFA67_minS);
		private static readonly char[] DFA67_max = DFA.UnpackEncodedStringToUnsignedChars(DFA67_maxS);
		private static readonly short[] DFA67_accept = DFA.UnpackEncodedString(DFA67_acceptS);
		private static readonly short[] DFA67_special = DFA.UnpackEncodedString(DFA67_specialS);
		private static readonly short[][] DFA67_transition;

		static DFA67()
		{
			int numStates = DFA67_transitionS.Length;
			DFA67_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA67_transition[i] = DFA.UnpackEncodedString(DFA67_transitionS[i]);
			}
		}

		public DFA67( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 67;
			this.eot = DFA67_eot;
			this.eof = DFA67_eof;
			this.min = DFA67_min;
			this.max = DFA67_max;
			this.accept = DFA67_accept;
			this.special = DFA67_special;
			this.transition = DFA67_transition;
		}

		public override string Description { get { return "166:97: ( ( LT )* incr= expression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA97 : DFA
	{
		private const string DFA97_eotS =
			"\x4\xFFFF";
		private const string DFA97_eofS =
			"\x4\xFFFF";
		private const string DFA97_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA97_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA97_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA97_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA97_transitionS =
			{
				"\x1\x1\x3A\xFFFF\x1\x3\x2\xFFFF\x1\x2\x1B\xFFFF\x1\x2",
				"\x1\x1\x3A\xFFFF\x1\x3\x2\xFFFF\x1\x2\x1B\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA97_eot = DFA.UnpackEncodedString(DFA97_eotS);
		private static readonly short[] DFA97_eof = DFA.UnpackEncodedString(DFA97_eofS);
		private static readonly char[] DFA97_min = DFA.UnpackEncodedStringToUnsignedChars(DFA97_minS);
		private static readonly char[] DFA97_max = DFA.UnpackEncodedStringToUnsignedChars(DFA97_maxS);
		private static readonly short[] DFA97_accept = DFA.UnpackEncodedString(DFA97_acceptS);
		private static readonly short[] DFA97_special = DFA.UnpackEncodedString(DFA97_specialS);
		private static readonly short[][] DFA97_transition;

		static DFA97()
		{
			int numStates = DFA97_transitionS.Length;
			DFA97_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA97_transition[i] = DFA.UnpackEncodedString(DFA97_transitionS[i]);
			}
		}

		public DFA97( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 97;
			this.eot = DFA97_eot;
			this.eof = DFA97_eof;
			this.min = DFA97_min;
			this.max = DFA97_max;
			this.accept = DFA97_accept;
			this.special = DFA97_special;
			this.transition = DFA97_transition;
		}

		public override string Description { get { return "()* loopback of 222:9: ( ( LT !)* caseClause )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA101 : DFA
	{
		private const string DFA101_eotS =
			"\x4\xFFFF";
		private const string DFA101_eofS =
			"\x4\xFFFF";
		private const string DFA101_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA101_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA101_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA101_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA101_transitionS =
			{
				"\x1\x1\x3D\xFFFF\x1\x2\x1B\xFFFF\x1\x3",
				"\x1\x1\x3D\xFFFF\x1\x2\x1B\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA101_eot = DFA.UnpackEncodedString(DFA101_eotS);
		private static readonly short[] DFA101_eof = DFA.UnpackEncodedString(DFA101_eofS);
		private static readonly char[] DFA101_min = DFA.UnpackEncodedStringToUnsignedChars(DFA101_minS);
		private static readonly char[] DFA101_max = DFA.UnpackEncodedStringToUnsignedChars(DFA101_maxS);
		private static readonly short[] DFA101_accept = DFA.UnpackEncodedString(DFA101_acceptS);
		private static readonly short[] DFA101_special = DFA.UnpackEncodedString(DFA101_specialS);
		private static readonly short[][] DFA101_transition;

		static DFA101()
		{
			int numStates = DFA101_transitionS.Length;
			DFA101_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA101_transition[i] = DFA.UnpackEncodedString(DFA101_transitionS[i]);
			}
		}

		public DFA101( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 101;
			this.eot = DFA101_eot;
			this.eof = DFA101_eof;
			this.min = DFA101_min;
			this.max = DFA101_max;
			this.accept = DFA101_accept;
			this.special = DFA101_special;
			this.transition = DFA101_transition;
		}

		public override string Description { get { return "222:28: ( ( LT !)* defaultClause ( ( LT !)* caseClause )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA100 : DFA
	{
		private const string DFA100_eotS =
			"\x4\xFFFF";
		private const string DFA100_eofS =
			"\x4\xFFFF";
		private const string DFA100_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA100_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA100_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA100_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA100_transitionS =
			{
				"\x1\x1\x3A\xFFFF\x1\x3\x1E\xFFFF\x1\x2",
				"\x1\x1\x3A\xFFFF\x1\x3\x1E\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA100_eot = DFA.UnpackEncodedString(DFA100_eotS);
		private static readonly short[] DFA100_eof = DFA.UnpackEncodedString(DFA100_eofS);
		private static readonly char[] DFA100_min = DFA.UnpackEncodedStringToUnsignedChars(DFA100_minS);
		private static readonly char[] DFA100_max = DFA.UnpackEncodedStringToUnsignedChars(DFA100_maxS);
		private static readonly short[] DFA100_accept = DFA.UnpackEncodedString(DFA100_acceptS);
		private static readonly short[] DFA100_special = DFA.UnpackEncodedString(DFA100_specialS);
		private static readonly short[][] DFA100_transition;

		static DFA100()
		{
			int numStates = DFA100_transitionS.Length;
			DFA100_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA100_transition[i] = DFA.UnpackEncodedString(DFA100_transitionS[i]);
			}
		}

		public DFA100( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 100;
			this.eot = DFA100_eot;
			this.eof = DFA100_eof;
			this.min = DFA100_min;
			this.max = DFA100_max;
			this.accept = DFA100_accept;
			this.special = DFA100_special;
			this.transition = DFA100_transition;
		}

		public override string Description { get { return "()* loopback of 222:48: ( ( LT !)* caseClause )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA114 : DFA
	{
		private const string DFA114_eotS =
			"\x4\xFFFF";
		private const string DFA114_eofS =
			"\x2\x3\x2\xFFFF";
		private const string DFA114_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA114_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA114_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA114_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA114_transitionS =
			{
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\x2\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF"+
				"\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x1\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x1\x3\x3\xFFFF\x2\x3\x2\xFFFF\x2\x3\x5\xFFFF\x1\x3\xE\xFFFF\x1"+
				"\x3\x3\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\x2\x3\x3\x2\xFFFF\xE\x3\x3\xFFFF"+
				"\x2\x3",
				"",
				""
			};

		private static readonly short[] DFA114_eot = DFA.UnpackEncodedString(DFA114_eotS);
		private static readonly short[] DFA114_eof = DFA.UnpackEncodedString(DFA114_eofS);
		private static readonly char[] DFA114_min = DFA.UnpackEncodedStringToUnsignedChars(DFA114_minS);
		private static readonly char[] DFA114_max = DFA.UnpackEncodedStringToUnsignedChars(DFA114_maxS);
		private static readonly short[] DFA114_accept = DFA.UnpackEncodedString(DFA114_acceptS);
		private static readonly short[] DFA114_special = DFA.UnpackEncodedString(DFA114_specialS);
		private static readonly short[][] DFA114_transition;

		static DFA114()
		{
			int numStates = DFA114_transitionS.Length;
			DFA114_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA114_transition[i] = DFA.UnpackEncodedString(DFA114_transitionS[i]);
			}
		}

		public DFA114( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 114;
			this.eot = DFA114_eot;
			this.eof = DFA114_eof;
			this.min = DFA114_min;
			this.max = DFA114_max;
			this.accept = DFA114_accept;
			this.special = DFA114_special;
			this.transition = DFA114_transition;
		}

		public override string Description { get { return "238:62: ( ( LT )* finallyClause )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA123 : DFA
	{
		private const string DFA123_eotS =
			"\x5\xFFFF";
		private const string DFA123_eofS =
			"\x2\x2\x2\xFFFF\x1\x2";
		private const string DFA123_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA123_maxS =
			"\x1\x4F\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA123_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1\x1\xFFFF";
		private const string DFA123_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA123_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3\x6\xFFFF\x2\x2\xF\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x4\xFFFF\x2\x2\xE\xFFFF"+
				"\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2",
				"",
				"",
				"\x1\x2\x2\xFFFF\x1\x4\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x4\xFFFF\x2\x2\xE\xFFFF"+
				"\x2\x2\x2\xFFFF\x2\x2\x1\xFFFF\x6\x2\x1\xFFFF\x3\x2\x2\xFFFF\xE\x2\x3"+
				"\xFFFF\x2\x2"
			};

		private static readonly short[] DFA123_eot = DFA.UnpackEncodedString(DFA123_eotS);
		private static readonly short[] DFA123_eof = DFA.UnpackEncodedString(DFA123_eofS);
		private static readonly char[] DFA123_min = DFA.UnpackEncodedStringToUnsignedChars(DFA123_minS);
		private static readonly char[] DFA123_max = DFA.UnpackEncodedStringToUnsignedChars(DFA123_maxS);
		private static readonly short[] DFA123_accept = DFA.UnpackEncodedString(DFA123_acceptS);
		private static readonly short[] DFA123_special = DFA.UnpackEncodedString(DFA123_specialS);
		private static readonly short[][] DFA123_transition;

		static DFA123()
		{
			int numStates = DFA123_transitionS.Length;
			DFA123_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA123_transition[i] = DFA.UnpackEncodedString(DFA123_transitionS[i]);
			}
		}

		public DFA123( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 123;
			this.eot = DFA123_eot;
			this.eof = DFA123_eof;
			this.min = DFA123_min;
			this.max = DFA123_max;
			this.accept = DFA123_accept;
			this.special = DFA123_special;
			this.transition = DFA123_transition;
		}

		public override string Description { get { return "()* loopback of 253:25: ( ( LT )* ',' ( LT )* assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA126 : DFA
	{
		private const string DFA126_eotS =
			"\x4\xFFFF";
		private const string DFA126_eofS =
			"\x1\x2\x3\xFFFF";
		private const string DFA126_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA126_maxS =
			"\x2\x3F\x2\xFFFF";
		private const string DFA126_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA126_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA126_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x7\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA126_eot = DFA.UnpackEncodedString(DFA126_eotS);
		private static readonly short[] DFA126_eof = DFA.UnpackEncodedString(DFA126_eofS);
		private static readonly char[] DFA126_min = DFA.UnpackEncodedStringToUnsignedChars(DFA126_minS);
		private static readonly char[] DFA126_max = DFA.UnpackEncodedStringToUnsignedChars(DFA126_maxS);
		private static readonly short[] DFA126_accept = DFA.UnpackEncodedString(DFA126_acceptS);
		private static readonly short[] DFA126_special = DFA.UnpackEncodedString(DFA126_specialS);
		private static readonly short[][] DFA126_transition;

		static DFA126()
		{
			int numStates = DFA126_transitionS.Length;
			DFA126_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA126_transition[i] = DFA.UnpackEncodedString(DFA126_transitionS[i]);
			}
		}

		public DFA126( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 126;
			this.eot = DFA126_eot;
			this.eof = DFA126_eof;
			this.min = DFA126_min;
			this.max = DFA126_max;
			this.accept = DFA126_accept;
			this.special = DFA126_special;
			this.transition = DFA126_transition;
		}

		public override string Description { get { return "()* loopback of 257:29: ( ( LT )* ',' ( LT )* assignmentExpressionNoIn )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA150 : DFA
	{
		private const string DFA150_eotS =
			"\x4\xFFFF";
		private const string DFA150_eofS =
			"\x4\xFFFF";
		private const string DFA150_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA150_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA150_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA150_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA150_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x1\x3\x2\xFFFF\x2\x2\x2\xFFFF\x2\x2\x14\xFFFF\x1\x2\x8"+
				"\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4\xFFFF"+
				"\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA150_eot = DFA.UnpackEncodedString(DFA150_eotS);
		private static readonly short[] DFA150_eof = DFA.UnpackEncodedString(DFA150_eofS);
		private static readonly char[] DFA150_min = DFA.UnpackEncodedStringToUnsignedChars(DFA150_minS);
		private static readonly char[] DFA150_max = DFA.UnpackEncodedStringToUnsignedChars(DFA150_maxS);
		private static readonly short[] DFA150_accept = DFA.UnpackEncodedString(DFA150_acceptS);
		private static readonly short[] DFA150_special = DFA.UnpackEncodedString(DFA150_specialS);
		private static readonly short[][] DFA150_transition;

		static DFA150()
		{
			int numStates = DFA150_transitionS.Length;
			DFA150_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA150_transition[i] = DFA.UnpackEncodedString(DFA150_transitionS[i]);
			}
		}

		public DFA150( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 150;
			this.eot = DFA150_eot;
			this.eof = DFA150_eof;
			this.min = DFA150_min;
			this.max = DFA150_max;
			this.accept = DFA150_accept;
			this.special = DFA150_special;
			this.transition = DFA150_transition;
		}

		public override string Description { get { return "346:8: ( ( LT )* assignmentExpression ( ( LT )* ',' ( LT )* assignmentExpression )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA149 : DFA
	{
		private const string DFA149_eotS =
			"\x4\xFFFF";
		private const string DFA149_eofS =
			"\x4\xFFFF";
		private const string DFA149_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA149_maxS =
			"\x2\x37\x2\xFFFF";
		private const string DFA149_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA149_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA149_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"\x1\x1\x18\xFFFF\x1\x2\x5\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA149_eot = DFA.UnpackEncodedString(DFA149_eotS);
		private static readonly short[] DFA149_eof = DFA.UnpackEncodedString(DFA149_eofS);
		private static readonly char[] DFA149_min = DFA.UnpackEncodedStringToUnsignedChars(DFA149_minS);
		private static readonly char[] DFA149_max = DFA.UnpackEncodedStringToUnsignedChars(DFA149_maxS);
		private static readonly short[] DFA149_accept = DFA.UnpackEncodedString(DFA149_acceptS);
		private static readonly short[] DFA149_special = DFA.UnpackEncodedString(DFA149_specialS);
		private static readonly short[][] DFA149_transition;

		static DFA149()
		{
			int numStates = DFA149_transitionS.Length;
			DFA149_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA149_transition[i] = DFA.UnpackEncodedString(DFA149_transitionS[i]);
			}
		}

		public DFA149( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 149;
			this.eot = DFA149_eot;
			this.eof = DFA149_eof;
			this.min = DFA149_min;
			this.max = DFA149_max;
			this.accept = DFA149_accept;
			this.special = DFA149_special;
			this.transition = DFA149_transition;
		}

		public override string Description { get { return "()* loopback of 346:34: ( ( LT )* ',' ( LT )* assignmentExpression )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA159 : DFA
	{
		private const string DFA159_eotS =
			"\x5\xFFFF";
		private const string DFA159_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA159_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA159_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA159_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA159_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA159_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x2"+
				"\x1\xFFFF\x1\x3\x22\xFFFF\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x1"+
				"\x2\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3"+
				"\x3\xFFFF\x2\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x1"+
				"\x2\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3"+
				"\x3\xFFFF\x2\x3"
			};

		private static readonly short[] DFA159_eot = DFA.UnpackEncodedString(DFA159_eotS);
		private static readonly short[] DFA159_eof = DFA.UnpackEncodedString(DFA159_eofS);
		private static readonly char[] DFA159_min = DFA.UnpackEncodedStringToUnsignedChars(DFA159_minS);
		private static readonly char[] DFA159_max = DFA.UnpackEncodedStringToUnsignedChars(DFA159_maxS);
		private static readonly short[] DFA159_accept = DFA.UnpackEncodedString(DFA159_acceptS);
		private static readonly short[] DFA159_special = DFA.UnpackEncodedString(DFA159_specialS);
		private static readonly short[][] DFA159_transition;

		static DFA159()
		{
			int numStates = DFA159_transitionS.Length;
			DFA159_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA159_transition[i] = DFA.UnpackEncodedString(DFA159_transitionS[i]);
			}
		}

		public DFA159( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 159;
			this.eot = DFA159_eot;
			this.eof = DFA159_eof;
			this.min = DFA159_min;
			this.max = DFA159_max;
			this.accept = DFA159_accept;
			this.special = DFA159_special;
			this.transition = DFA159_transition;
		}

		public override string Description { get { return "361:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpression ( LT )* ':' ( LT )* iffalse= assignmentExpression -> ^( '?' logicalORExpression $iftrue $iffalse) | -> logicalORExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA164 : DFA
	{
		private const string DFA164_eotS =
			"\x4\xFFFF";
		private const string DFA164_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA164_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA164_maxS =
			"\x2\x5F\x2\xFFFF";
		private const string DFA164_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA164_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA164_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x2\x11\xFFFF\x1\x3",
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x2\x11\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA164_eot = DFA.UnpackEncodedString(DFA164_eotS);
		private static readonly short[] DFA164_eof = DFA.UnpackEncodedString(DFA164_eofS);
		private static readonly char[] DFA164_min = DFA.UnpackEncodedStringToUnsignedChars(DFA164_minS);
		private static readonly char[] DFA164_max = DFA.UnpackEncodedStringToUnsignedChars(DFA164_maxS);
		private static readonly short[] DFA164_accept = DFA.UnpackEncodedString(DFA164_acceptS);
		private static readonly short[] DFA164_special = DFA.UnpackEncodedString(DFA164_specialS);
		private static readonly short[][] DFA164_transition;

		static DFA164()
		{
			int numStates = DFA164_transitionS.Length;
			DFA164_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA164_transition[i] = DFA.UnpackEncodedString(DFA164_transitionS[i]);
			}
		}

		public DFA164( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 164;
			this.eot = DFA164_eot;
			this.eof = DFA164_eof;
			this.min = DFA164_min;
			this.max = DFA164_max;
			this.accept = DFA164_accept;
			this.special = DFA164_special;
			this.transition = DFA164_transition;
		}

		public override string Description { get { return "371:3: ( ( LT )* '?' ( LT )* iftrue= assignmentExpressionNoIn ( LT )* ':' ( LT )* iffalse= assignmentExpressionNoIn -> ^( '?' logicalORExpressionNoIn $iftrue $iffalse) | -> logicalORExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA167 : DFA
	{
		private const string DFA167_eotS =
			"\x5\xFFFF";
		private const string DFA167_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA167_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA167_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA167_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA167_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA167_transitionS =
			{
				"\x1\x1\x18\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x1\xFFFF\x1\x3\x21\xFFFF\x1\x2\x1\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x3"+
				"\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3\x2\xFFFF"+
				"\x1\x2\x2\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x7"+
				"\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2\x3\xD\xFFFF\x3"+
				"\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF\xE\x3\x2\xFFFF"+
				"\x1\x2\x2\x3"
			};

		private static readonly short[] DFA167_eot = DFA.UnpackEncodedString(DFA167_eotS);
		private static readonly short[] DFA167_eof = DFA.UnpackEncodedString(DFA167_eofS);
		private static readonly char[] DFA167_min = DFA.UnpackEncodedStringToUnsignedChars(DFA167_minS);
		private static readonly char[] DFA167_max = DFA.UnpackEncodedStringToUnsignedChars(DFA167_maxS);
		private static readonly short[] DFA167_accept = DFA.UnpackEncodedString(DFA167_acceptS);
		private static readonly short[] DFA167_special = DFA.UnpackEncodedString(DFA167_specialS);
		private static readonly short[][] DFA167_transition;

		static DFA167()
		{
			int numStates = DFA167_transitionS.Length;
			DFA167_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA167_transition[i] = DFA.UnpackEncodedString(DFA167_transitionS[i]);
			}
		}

		public DFA167( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 167;
			this.eot = DFA167_eot;
			this.eof = DFA167_eof;
			this.min = DFA167_min;
			this.max = DFA167_max;
			this.accept = DFA167_accept;
			this.special = DFA167_special;
			this.transition = DFA167_transition;
		}

		public override string Description { get { return "381:3: ( ( ( LT )* '||' ( LT )* logicalORExpression ) -> ^( '||' logicalANDExpression logicalORExpression ) | -> logicalANDExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA170 : DFA
	{
		private const string DFA170_eotS =
			"\x4\xFFFF";
		private const string DFA170_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA170_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA170_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA170_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA170_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA170_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3\x11\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3\x11\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA170_eot = DFA.UnpackEncodedString(DFA170_eotS);
		private static readonly short[] DFA170_eof = DFA.UnpackEncodedString(DFA170_eofS);
		private static readonly char[] DFA170_min = DFA.UnpackEncodedStringToUnsignedChars(DFA170_minS);
		private static readonly char[] DFA170_max = DFA.UnpackEncodedStringToUnsignedChars(DFA170_maxS);
		private static readonly short[] DFA170_accept = DFA.UnpackEncodedString(DFA170_acceptS);
		private static readonly short[] DFA170_special = DFA.UnpackEncodedString(DFA170_specialS);
		private static readonly short[][] DFA170_transition;

		static DFA170()
		{
			int numStates = DFA170_transitionS.Length;
			DFA170_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA170_transition[i] = DFA.UnpackEncodedString(DFA170_transitionS[i]);
			}
		}

		public DFA170( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 170;
			this.eot = DFA170_eot;
			this.eof = DFA170_eof;
			this.min = DFA170_min;
			this.max = DFA170_max;
			this.accept = DFA170_accept;
			this.special = DFA170_special;
			this.transition = DFA170_transition;
		}

		public override string Description { get { return "391:3: ( ( ( LT )* '||' ( LT )* logicalORExpressionNoIn ) -> ^( '||' logicalANDExpressionNoIn logicalORExpressionNoIn ) | -> logicalANDExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA173 : DFA
	{
		private const string DFA173_eotS =
			"\x5\xFFFF";
		private const string DFA173_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA173_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA173_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA173_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA173_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA173_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x2\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x3\x21\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x2\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x2\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x2\xFFFF\x3\x3"
			};

		private static readonly short[] DFA173_eot = DFA.UnpackEncodedString(DFA173_eotS);
		private static readonly short[] DFA173_eof = DFA.UnpackEncodedString(DFA173_eofS);
		private static readonly char[] DFA173_min = DFA.UnpackEncodedStringToUnsignedChars(DFA173_minS);
		private static readonly char[] DFA173_max = DFA.UnpackEncodedStringToUnsignedChars(DFA173_maxS);
		private static readonly short[] DFA173_accept = DFA.UnpackEncodedString(DFA173_acceptS);
		private static readonly short[] DFA173_special = DFA.UnpackEncodedString(DFA173_specialS);
		private static readonly short[][] DFA173_transition;

		static DFA173()
		{
			int numStates = DFA173_transitionS.Length;
			DFA173_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA173_transition[i] = DFA.UnpackEncodedString(DFA173_transitionS[i]);
			}
		}

		public DFA173( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 173;
			this.eot = DFA173_eot;
			this.eof = DFA173_eof;
			this.min = DFA173_min;
			this.max = DFA173_max;
			this.accept = DFA173_accept;
			this.special = DFA173_special;
			this.transition = DFA173_transition;
		}

		public override string Description { get { return "401:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpression ) -> ^( '&&' bitwiseORExpression logicalANDExpression ) | -> bitwiseORExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA176 : DFA
	{
		private const string DFA176_eotS =
			"\x4\xFFFF";
		private const string DFA176_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA176_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA176_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA176_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA176_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA176_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x2\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\x11\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x2\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\x11\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA176_eot = DFA.UnpackEncodedString(DFA176_eotS);
		private static readonly short[] DFA176_eof = DFA.UnpackEncodedString(DFA176_eofS);
		private static readonly char[] DFA176_min = DFA.UnpackEncodedStringToUnsignedChars(DFA176_minS);
		private static readonly char[] DFA176_max = DFA.UnpackEncodedStringToUnsignedChars(DFA176_maxS);
		private static readonly short[] DFA176_accept = DFA.UnpackEncodedString(DFA176_acceptS);
		private static readonly short[] DFA176_special = DFA.UnpackEncodedString(DFA176_specialS);
		private static readonly short[][] DFA176_transition;

		static DFA176()
		{
			int numStates = DFA176_transitionS.Length;
			DFA176_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA176_transition[i] = DFA.UnpackEncodedString(DFA176_transitionS[i]);
			}
		}

		public DFA176( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 176;
			this.eot = DFA176_eot;
			this.eof = DFA176_eof;
			this.min = DFA176_min;
			this.max = DFA176_max;
			this.accept = DFA176_accept;
			this.special = DFA176_special;
			this.transition = DFA176_transition;
		}

		public override string Description { get { return "411:3: ( ( ( LT )* '&&' ( LT )* logicalANDExpressionNoIn ) -> ^( '&&' bitwiseORExpressionNoIn logicalANDExpressionNoIn ) | -> bitwiseORExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA179 : DFA
	{
		private const string DFA179_eotS =
			"\x5\xFFFF";
		private const string DFA179_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA179_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA179_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA179_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA179_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA179_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1F\xFFFF\x1\x2\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x1\x2\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\xFFFF"+
				"\xE\x3\x1\x2\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA179_eot = DFA.UnpackEncodedString(DFA179_eotS);
		private static readonly short[] DFA179_eof = DFA.UnpackEncodedString(DFA179_eofS);
		private static readonly char[] DFA179_min = DFA.UnpackEncodedStringToUnsignedChars(DFA179_minS);
		private static readonly char[] DFA179_max = DFA.UnpackEncodedStringToUnsignedChars(DFA179_maxS);
		private static readonly short[] DFA179_accept = DFA.UnpackEncodedString(DFA179_acceptS);
		private static readonly short[] DFA179_special = DFA.UnpackEncodedString(DFA179_specialS);
		private static readonly short[][] DFA179_transition;

		static DFA179()
		{
			int numStates = DFA179_transitionS.Length;
			DFA179_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA179_transition[i] = DFA.UnpackEncodedString(DFA179_transitionS[i]);
			}
		}

		public DFA179( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 179;
			this.eot = DFA179_eot;
			this.eof = DFA179_eof;
			this.min = DFA179_min;
			this.max = DFA179_max;
			this.accept = DFA179_accept;
			this.special = DFA179_special;
			this.transition = DFA179_transition;
		}

		public override string Description { get { return "421:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpression ) -> ^( '|' bitwiseXORExpression bitwiseORExpression ) | -> bitwiseXORExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA182 : DFA
	{
		private const string DFA182_eotS =
			"\x4\xFFFF";
		private const string DFA182_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA182_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA182_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA182_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA182_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA182_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\xF\xFFFF\x1\x2\x1\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x11\xFFFF\x1\x3\xF\xFFFF\x1\x2\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA182_eot = DFA.UnpackEncodedString(DFA182_eotS);
		private static readonly short[] DFA182_eof = DFA.UnpackEncodedString(DFA182_eofS);
		private static readonly char[] DFA182_min = DFA.UnpackEncodedStringToUnsignedChars(DFA182_minS);
		private static readonly char[] DFA182_max = DFA.UnpackEncodedStringToUnsignedChars(DFA182_maxS);
		private static readonly short[] DFA182_accept = DFA.UnpackEncodedString(DFA182_acceptS);
		private static readonly short[] DFA182_special = DFA.UnpackEncodedString(DFA182_specialS);
		private static readonly short[][] DFA182_transition;

		static DFA182()
		{
			int numStates = DFA182_transitionS.Length;
			DFA182_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA182_transition[i] = DFA.UnpackEncodedString(DFA182_transitionS[i]);
			}
		}

		public DFA182( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 182;
			this.eot = DFA182_eot;
			this.eof = DFA182_eof;
			this.min = DFA182_min;
			this.max = DFA182_max;
			this.accept = DFA182_accept;
			this.special = DFA182_special;
			this.transition = DFA182_transition;
		}

		public override string Description { get { return "431:3: ( ( ( LT )* '|' ( LT )* bitwiseORExpressionNoIn ) -> ^( '|' bitwiseXORExpressionNoIn bitwiseORExpressionNoIn ) | -> bitwiseXORExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA185 : DFA
	{
		private const string DFA185_eotS =
			"\x5\xFFFF";
		private const string DFA185_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA185_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA185_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA185_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA185_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA185_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x3\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\xD\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\x2\x1E\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\xD\xFFFF\x3\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA185_eot = DFA.UnpackEncodedString(DFA185_eotS);
		private static readonly short[] DFA185_eof = DFA.UnpackEncodedString(DFA185_eofS);
		private static readonly char[] DFA185_min = DFA.UnpackEncodedStringToUnsignedChars(DFA185_minS);
		private static readonly char[] DFA185_max = DFA.UnpackEncodedStringToUnsignedChars(DFA185_maxS);
		private static readonly short[] DFA185_accept = DFA.UnpackEncodedString(DFA185_acceptS);
		private static readonly short[] DFA185_special = DFA.UnpackEncodedString(DFA185_specialS);
		private static readonly short[][] DFA185_transition;

		static DFA185()
		{
			int numStates = DFA185_transitionS.Length;
			DFA185_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA185_transition[i] = DFA.UnpackEncodedString(DFA185_transitionS[i]);
			}
		}

		public DFA185( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 185;
			this.eot = DFA185_eot;
			this.eof = DFA185_eof;
			this.min = DFA185_min;
			this.max = DFA185_max;
			this.accept = DFA185_accept;
			this.special = DFA185_special;
			this.transition = DFA185_transition;
		}

		public override string Description { get { return "441:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpression ) -> ^( '^' bitwiseANDExpression bitwiseXORExpression ) | -> bitwiseANDExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA188 : DFA
	{
		private const string DFA188_eotS =
			"\x4\xFFFF";
		private const string DFA188_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA188_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA188_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA188_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA188_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA188_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x2\xFFFF\x1\x2\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x3\x9\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF\x1\x3"+
				"\x2\xFFFF\x1\x2\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA188_eot = DFA.UnpackEncodedString(DFA188_eotS);
		private static readonly short[] DFA188_eof = DFA.UnpackEncodedString(DFA188_eofS);
		private static readonly char[] DFA188_min = DFA.UnpackEncodedStringToUnsignedChars(DFA188_minS);
		private static readonly char[] DFA188_max = DFA.UnpackEncodedStringToUnsignedChars(DFA188_maxS);
		private static readonly short[] DFA188_accept = DFA.UnpackEncodedString(DFA188_acceptS);
		private static readonly short[] DFA188_special = DFA.UnpackEncodedString(DFA188_specialS);
		private static readonly short[][] DFA188_transition;

		static DFA188()
		{
			int numStates = DFA188_transitionS.Length;
			DFA188_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA188_transition[i] = DFA.UnpackEncodedString(DFA188_transitionS[i]);
			}
		}

		public DFA188( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 188;
			this.eot = DFA188_eot;
			this.eof = DFA188_eof;
			this.min = DFA188_min;
			this.max = DFA188_max;
			this.accept = DFA188_accept;
			this.special = DFA188_special;
			this.transition = DFA188_transition;
		}

		public override string Description { get { return "451:3: ( ( ( LT )* '^' ( LT )* bitwiseXORExpressionNoIn ) -> ^( '^' bitwiseANDExpressionNoIn bitwiseXORExpressionNoIn ) | -> bitwiseANDExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA191 : DFA
	{
		private const string DFA191_eotS =
			"\x5\xFFFF";
		private const string DFA191_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA191_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA191_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA191_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA191_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA191_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x1\x2\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3\x6\xFFFF"+
				"\x2\x3\xD\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1E\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x1\x2\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\xD\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2"+
				"\xFFFF\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x4"+
				"\xFFFF\x1\x3\x1\x2\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\xD\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2"+
				"\xFFFF\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA191_eot = DFA.UnpackEncodedString(DFA191_eotS);
		private static readonly short[] DFA191_eof = DFA.UnpackEncodedString(DFA191_eofS);
		private static readonly char[] DFA191_min = DFA.UnpackEncodedStringToUnsignedChars(DFA191_minS);
		private static readonly char[] DFA191_max = DFA.UnpackEncodedStringToUnsignedChars(DFA191_maxS);
		private static readonly short[] DFA191_accept = DFA.UnpackEncodedString(DFA191_acceptS);
		private static readonly short[] DFA191_special = DFA.UnpackEncodedString(DFA191_specialS);
		private static readonly short[][] DFA191_transition;

		static DFA191()
		{
			int numStates = DFA191_transitionS.Length;
			DFA191_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA191_transition[i] = DFA.UnpackEncodedString(DFA191_transitionS[i]);
			}
		}

		public DFA191( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 191;
			this.eot = DFA191_eot;
			this.eof = DFA191_eof;
			this.min = DFA191_min;
			this.max = DFA191_max;
			this.accept = DFA191_accept;
			this.special = DFA191_special;
			this.transition = DFA191_transition;
		}

		public override string Description { get { return "461:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpression ) -> ^( '&' equalityExpression bitwiseANDExpression ) | -> equalityExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA194 : DFA
	{
		private const string DFA194_eotS =
			"\x4\xFFFF";
		private const string DFA194_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA194_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA194_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA194_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA194_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA194_transitionS =
			{
				"\x1\x1\x14\xFFFF\x1\x3\x1\x2\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF"+
				"\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x14\xFFFF\x1\x3\x1\x2\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3\xD\xFFFF"+
				"\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA194_eot = DFA.UnpackEncodedString(DFA194_eotS);
		private static readonly short[] DFA194_eof = DFA.UnpackEncodedString(DFA194_eofS);
		private static readonly char[] DFA194_min = DFA.UnpackEncodedStringToUnsignedChars(DFA194_minS);
		private static readonly char[] DFA194_max = DFA.UnpackEncodedStringToUnsignedChars(DFA194_maxS);
		private static readonly short[] DFA194_accept = DFA.UnpackEncodedString(DFA194_acceptS);
		private static readonly short[] DFA194_special = DFA.UnpackEncodedString(DFA194_specialS);
		private static readonly short[][] DFA194_transition;

		static DFA194()
		{
			int numStates = DFA194_transitionS.Length;
			DFA194_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA194_transition[i] = DFA.UnpackEncodedString(DFA194_transitionS[i]);
			}
		}

		public DFA194( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 194;
			this.eot = DFA194_eot;
			this.eof = DFA194_eof;
			this.min = DFA194_min;
			this.max = DFA194_max;
			this.accept = DFA194_accept;
			this.special = DFA194_special;
			this.transition = DFA194_transition;
		}

		public override string Description { get { return "471:3: ( ( ( LT )* '&' ( LT )* bitwiseANDExpressionNoIn ) -> ^( '&' equalityExpressionNoIn bitwiseANDExpressionNoIn ) | -> equalityExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA198 : DFA
	{
		private const string DFA198_eotS =
			"\x5\xFFFF";
		private const string DFA198_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA198_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA198_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA198_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA198_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA198_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x2\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3"+
				"\x6\xFFFF\x2\x3\x5\xFFFF\x2\x2\x6\xFFFF\x1\x3\x1\xFFFF\x2\x3\x1E\xFFFF"+
				"\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x2"+
				"\x2\x2\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\x5\xFFFF\x2\x2\x6\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x1\x3\x2"+
				"\x2\x2\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF"+
				"\x2\x3\x5\xFFFF\x2\x2\x6\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1"+
				"\xFFFF\x3\x3\x2\xFFFF\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA198_eot = DFA.UnpackEncodedString(DFA198_eotS);
		private static readonly short[] DFA198_eof = DFA.UnpackEncodedString(DFA198_eofS);
		private static readonly char[] DFA198_min = DFA.UnpackEncodedStringToUnsignedChars(DFA198_minS);
		private static readonly char[] DFA198_max = DFA.UnpackEncodedStringToUnsignedChars(DFA198_maxS);
		private static readonly short[] DFA198_accept = DFA.UnpackEncodedString(DFA198_acceptS);
		private static readonly short[] DFA198_special = DFA.UnpackEncodedString(DFA198_specialS);
		private static readonly short[][] DFA198_transition;

		static DFA198()
		{
			int numStates = DFA198_transitionS.Length;
			DFA198_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA198_transition[i] = DFA.UnpackEncodedString(DFA198_transitionS[i]);
			}
		}

		public DFA198( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 198;
			this.eot = DFA198_eot;
			this.eof = DFA198_eof;
			this.min = DFA198_min;
			this.max = DFA198_max;
			this.accept = DFA198_accept;
			this.special = DFA198_special;
			this.transition = DFA198_transition;
		}

		public override string Description { get { return "481:3: ( ( ( LT )* (op= '==' |op= '!=' |op= '===' |op= '!==' ) ( LT )* eq= equalityExpression ) -> { op.Text == \"==\" }? ^( '==' $rel $eq) -> { op.Text == \"!=\" }? ^( '!=' $rel $eq) -> { op.Text == \"===\" }? ^( '===' $rel $eq) -> { op.Text == \"!==\" }? ^( '!==' $rel $eq) ->| -> relationalExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA202 : DFA
	{
		private const string DFA202_eotS =
			"\x4\xFFFF";
		private const string DFA202_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA202_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA202_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA202_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA202_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA202_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x2\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x5\xFFFF\x2\x2\x6\xFFFF\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF"+
				"\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x10\xFFFF\x2\x2\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x5\xFFFF\x2\x2\x6\xFFFF\x1\x3\x2\xFFFF\x1\x3\xE\xFFFF\x1\x3\xF\xFFFF"+
				"\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA202_eot = DFA.UnpackEncodedString(DFA202_eotS);
		private static readonly short[] DFA202_eof = DFA.UnpackEncodedString(DFA202_eofS);
		private static readonly char[] DFA202_min = DFA.UnpackEncodedStringToUnsignedChars(DFA202_minS);
		private static readonly char[] DFA202_max = DFA.UnpackEncodedStringToUnsignedChars(DFA202_maxS);
		private static readonly short[] DFA202_accept = DFA.UnpackEncodedString(DFA202_acceptS);
		private static readonly short[] DFA202_special = DFA.UnpackEncodedString(DFA202_specialS);
		private static readonly short[][] DFA202_transition;

		static DFA202()
		{
			int numStates = DFA202_transitionS.Length;
			DFA202_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA202_transition[i] = DFA.UnpackEncodedString(DFA202_transitionS[i]);
			}
		}

		public DFA202( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 202;
			this.eot = DFA202_eot;
			this.eof = DFA202_eof;
			this.min = DFA202_min;
			this.max = DFA202_max;
			this.accept = DFA202_accept;
			this.special = DFA202_special;
			this.transition = DFA202_transition;
		}

		public override string Description { get { return "495:3: ( ( ( LT )* ( '==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!=' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '===' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) | '!==' -> ^( '==' relationalExpressionNoIn equalityExpressionNoIn ) ) ( LT )* equalityExpressionNoIn ) | -> relationalExpressionNoIn )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA206 : DFA
	{
		private const string DFA206_eotS =
			"\x5\xFFFF";
		private const string DFA206_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA206_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA206_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA206_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA206_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA206_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3"+
				"\x6\xFFFF\x2\x3\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x1"+
				"\x3\x1\xFFFF\x2\x3\xE\xFFFF\x2\x2\xE\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x4\x3\x1\xFFFF"+
				"\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\x2\xF\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x2"+
				"\x3\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x4\x3\x1\xFFFF"+
				"\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x3\x3\x2\x2\xF\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA206_eot = DFA.UnpackEncodedString(DFA206_eotS);
		private static readonly short[] DFA206_eof = DFA.UnpackEncodedString(DFA206_eofS);
		private static readonly char[] DFA206_min = DFA.UnpackEncodedStringToUnsignedChars(DFA206_minS);
		private static readonly char[] DFA206_max = DFA.UnpackEncodedStringToUnsignedChars(DFA206_maxS);
		private static readonly short[] DFA206_accept = DFA.UnpackEncodedString(DFA206_acceptS);
		private static readonly short[] DFA206_special = DFA.UnpackEncodedString(DFA206_specialS);
		private static readonly short[][] DFA206_transition;

		static DFA206()
		{
			int numStates = DFA206_transitionS.Length;
			DFA206_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA206_transition[i] = DFA.UnpackEncodedString(DFA206_transitionS[i]);
			}
		}

		public DFA206( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 206;
			this.eot = DFA206_eot;
			this.eof = DFA206_eof;
			this.min = DFA206_min;
			this.max = DFA206_max;
			this.accept = DFA206_accept;
			this.special = DFA206_special;
			this.transition = DFA206_transition;
		}

		public override string Description { get { return "512:3: ( ( ( LT )* (op= '<' |op= '>' |op= '<=' |op= '>=' |op= 'instanceof' |op= 'in' ) ( LT )* rel= relationalExpression ) -> { op.Text == \"<\" }? ^( '<' $se $rel) -> { op.Text == \">\" }? ^( '>' $se $rel) -> { op.Text == \"<=\" }? ^( '<=' $se $rel) -> { op.Text == \">=\" }? ^( '>=' $se $rel) -> { op.Text == \"instanceof\" }? ^( 'instanceof' $se $rel) -> { op.Text == \"in\" }? ^( 'in' $se $rel) ->| -> $se)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA210 : DFA
	{
		private const string DFA210_eotS =
			"\x4\xFFFF";
		private const string DFA210_eofS =
			"\x1\x3\x3\xFFFF";
		private const string DFA210_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA210_maxS =
			"\x2\x71\x2\xFFFF";
		private const string DFA210_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA210_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA210_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\x3\xE\xFFFF\x1\x3\x1\x2\xE\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x8\xFFFF\x1\x3\x6\xFFFF\x2\x3"+
				"\x1\x2\x2\xFFFF\x1\x2\x1\xFFFF\x2\x3\x2\x2\x4\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\x3\xE\xFFFF\x1\x3\x1\x2\xE\xFFFF\x1\x3\x1\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA210_eot = DFA.UnpackEncodedString(DFA210_eotS);
		private static readonly short[] DFA210_eof = DFA.UnpackEncodedString(DFA210_eofS);
		private static readonly char[] DFA210_min = DFA.UnpackEncodedStringToUnsignedChars(DFA210_minS);
		private static readonly char[] DFA210_max = DFA.UnpackEncodedStringToUnsignedChars(DFA210_maxS);
		private static readonly short[] DFA210_accept = DFA.UnpackEncodedString(DFA210_acceptS);
		private static readonly short[] DFA210_special = DFA.UnpackEncodedString(DFA210_specialS);
		private static readonly short[][] DFA210_transition;

		static DFA210()
		{
			int numStates = DFA210_transitionS.Length;
			DFA210_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA210_transition[i] = DFA.UnpackEncodedString(DFA210_transitionS[i]);
			}
		}

		public DFA210( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 210;
			this.eot = DFA210_eot;
			this.eof = DFA210_eof;
			this.min = DFA210_min;
			this.max = DFA210_max;
			this.accept = DFA210_accept;
			this.special = DFA210_special;
			this.transition = DFA210_transition;
		}

		public override string Description { get { return "528:3: ( ( ( LT )* ( '<' -> ^( '<' shiftExpression relationalExpressionNoIn ) | '>' -> ^( '>' shiftExpression relationalExpressionNoIn ) | '<=' -> ^( '<=' shiftExpression relationalExpressionNoIn ) | '>=' -> ^( '>=' shiftExpression relationalExpressionNoIn ) | 'instanceof' -> ^( 'instanceof' shiftExpression relationalExpressionNoIn ) ) ( LT )* relationalExpressionNoIn ) | -> shiftExpression )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA214 : DFA
	{
		private const string DFA214_eotS =
			"\x5\xFFFF";
		private const string DFA214_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA214_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA214_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA214_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA214_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA214_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x2\xFFFF\x2\x3\x2\xFFFF\x1\x3\x5\xFFFF\x1\x3"+
				"\x6\xFFFF\x3\x3\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x4\x3\x1\x2\x1\xFFFF\x1"+
				"\x2\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3\xE\xFFFF\x2\x3\xE\xFFFF\x1\x3\x1\xFFFF"+
				"\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x3"+
				"\x3\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x4\x3\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
				"\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x2"+
				"\xFFFF\x2\x3\x1\xFFFF\x2\x3\x2\xFFFF\x2\x3\x1\xFFFF\x3\x3\x4\xFFFF\x3"+
				"\x3\x1\x2\x1\xFFFF\x1\x3\x1\xFFFF\x4\x3\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF"+
				"\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA214_eot = DFA.UnpackEncodedString(DFA214_eotS);
		private static readonly short[] DFA214_eof = DFA.UnpackEncodedString(DFA214_eofS);
		private static readonly char[] DFA214_min = DFA.UnpackEncodedStringToUnsignedChars(DFA214_minS);
		private static readonly char[] DFA214_max = DFA.UnpackEncodedStringToUnsignedChars(DFA214_maxS);
		private static readonly short[] DFA214_accept = DFA.UnpackEncodedString(DFA214_acceptS);
		private static readonly short[] DFA214_special = DFA.UnpackEncodedString(DFA214_specialS);
		private static readonly short[][] DFA214_transition;

		static DFA214()
		{
			int numStates = DFA214_transitionS.Length;
			DFA214_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA214_transition[i] = DFA.UnpackEncodedString(DFA214_transitionS[i]);
			}
		}

		public DFA214( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 214;
			this.eot = DFA214_eot;
			this.eof = DFA214_eof;
			this.min = DFA214_min;
			this.max = DFA214_max;
			this.accept = DFA214_accept;
			this.special = DFA214_special;
			this.transition = DFA214_transition;
		}

		public override string Description { get { return "546:9: ( ( ( LT )* (op= '<<' |op= '>>' |op= '>>>' ) ( LT )* shift= shiftExpression ) -> { op.Text == \"<<\" }? ^( '<<' $add $shift) -> { op.Text == \">>\" }? ^( '>>' $add $shift) -> { op.Text == \">>>\" }? ^( '>>>' $add $shift) ->| -> $add)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA222 : DFA
	{
		private const string DFA222_eotS =
			"\x5\xFFFF";
		private const string DFA222_eofS =
			"\x2\x3\x2\xFFFF\x1\x3";
		private const string DFA222_minS =
			"\x1\x18\x1\x15\x2\xFFFF\x1\x15";
		private const string DFA222_maxS =
			"\x1\x72\x1\x73\x2\xFFFF\x1\x73";
		private const string DFA222_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2\x1\xFFFF";
		private const string DFA222_specialS =
			"\x5\xFFFF}>";
		private static readonly string[] DFA222_transitionS =
			{
				"\x1\x1\x10\xFFFF\x2\x3\x1\x2\x1\xFFFF\x2\x3\x2\xFFFF\x1\x3\x1\x2\x1"+
				"\xFFFF\x1\x3\x2\xFFFF\x2\x3\x3\xFFFF\x1\x2\x1\xFFFF\x4\x3\x1\xFFFF\x1"+
				"\x3\x1\xFFFF\x5\x3\x1\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\xFFFF\x2\x3\xE\xFFFF"+
				"\x2\x3\xE\xFFFF\x1\x3\x1\xFFFF\x2\x3",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x1"+
				"\x2\x1\xFFFF\x2\x3\x1\xFFFF\x2\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\x1\x2\x1\xFFFF\x4\x3\x1\xFFFF\x1\x3\x1\xFFFF\x5\x3\x1\xFFFF"+
				"\x1\x3\x1\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3"+
				"\x1\xFFFF\x3\x3",
				"",
				"",
				"\x1\x3\x2\xFFFF\x1\x4\x2\xFFFF\x1\x3\x4\xFFFF\x1\x3\x7\xFFFF\x3\x3\x1"+
				"\x2\x1\xFFFF\x2\x3\x1\xFFFF\x2\x3\x1\x2\x1\xFFFF\x2\x3\x1\xFFFF\x3\x3"+
				"\x2\xFFFF\x1\x2\x1\xFFFF\x4\x3\x1\xFFFF\x1\x3\x1\xFFFF\x5\x3\x1\xFFFF"+
				"\x1\x3\x1\xFFFF\x4\x3\x1\xFFFF\x2\x3\x1\xFFFF\x6\x3\x1\xFFFF\x14\x3"+
				"\x1\xFFFF\x3\x3"
			};

		private static readonly short[] DFA222_eot = DFA.UnpackEncodedString(DFA222_eotS);
		private static readonly short[] DFA222_eof = DFA.UnpackEncodedString(DFA222_eofS);
		private static readonly char[] DFA222_min = DFA.UnpackEncodedStringToUnsignedChars(DFA222_minS);
		private static readonly char[] DFA222_max = DFA.UnpackEncodedStringToUnsignedChars(DFA222_maxS);
		private static readonly short[] DFA222_accept = DFA.UnpackEncodedString(DFA222_acceptS);
		private static readonly short[] DFA222_special = DFA.UnpackEncodedString(DFA222_specialS);
		private static readonly short[][] DFA222_transition;

		static DFA222()
		{
			int numStates = DFA222_transitionS.Length;
			DFA222_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA222_transition[i] = DFA.UnpackEncodedString(DFA222_transitionS[i]);
			}
		}

		public DFA222( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 222;
			this.eot = DFA222_eot;
			this.eof = DFA222_eof;
			this.min = DFA222_min;
			this.max = DFA222_max;
			this.accept = DFA222_accept;
			this.special = DFA222_special;
			this.transition = DFA222_transition;
		}

		public override string Description { get { return "569:3: ( ( ( LT )* (op= '*' |op= '/' |op= '%' ) ( LT )* me= multiplicativeExpression ) -> { op.Text == \"*\" }? ^( '*' $ue $me) -> { op.Text == \"/\" }? ^( '/' $ue $me) -> { op.Text == \"\\%\" }? ^( '%' $ue $me) ->| -> $ue)"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA234 : DFA
	{
		private const string DFA234_eotS =
			"\x4\xFFFF";
		private const string DFA234_eofS =
			"\x4\xFFFF";
		private const string DFA234_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA234_maxS =
			"\x2\x4F\x2\xFFFF";
		private const string DFA234_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA234_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA234_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x17\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x17\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA234_eot = DFA.UnpackEncodedString(DFA234_eotS);
		private static readonly short[] DFA234_eof = DFA.UnpackEncodedString(DFA234_eofS);
		private static readonly char[] DFA234_min = DFA.UnpackEncodedStringToUnsignedChars(DFA234_minS);
		private static readonly char[] DFA234_max = DFA.UnpackEncodedStringToUnsignedChars(DFA234_maxS);
		private static readonly short[] DFA234_accept = DFA.UnpackEncodedString(DFA234_acceptS);
		private static readonly short[] DFA234_special = DFA.UnpackEncodedString(DFA234_specialS);
		private static readonly short[][] DFA234_transition;

		static DFA234()
		{
			int numStates = DFA234_transitionS.Length;
			DFA234_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA234_transition[i] = DFA.UnpackEncodedString(DFA234_transitionS[i]);
			}
		}

		public DFA234( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 234;
			this.eot = DFA234_eot;
			this.eof = DFA234_eof;
			this.min = DFA234_min;
			this.max = DFA234_max;
			this.accept = DFA234_accept;
			this.special = DFA234_special;
			this.transition = DFA234_transition;
		}

		public override string Description { get { return "()* loopback of 619:34: ( ( LT )* ',' ( ( LT )* assignmentExpression )? )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA233 : DFA
	{
		private const string DFA233_eotS =
			"\x4\xFFFF";
		private const string DFA233_eofS =
			"\x4\xFFFF";
		private const string DFA233_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA233_maxS =
			"\x2\x73\x2\xFFFF";
		private const string DFA233_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA233_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA233_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x14\xFFFF\x1\x2\x1"+
				"\x3\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x7\xFFFF\x1\x2\x7"+
				"\xFFFF\x1\x2\x3\xFFFF\x2\x2\x1\xFFFF\x1\x3\x2\x2\x14\xFFFF\x1\x2\x1"+
				"\x3\x7\xFFFF\x1\x2\x2\xFFFF\x1\x2\x2\xFFFF\x1\x2\x3\xFFFF\x2\x2\x2\xFFFF"+
				"\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x1\xFFFF\x1\x2\x2\xFFFF\x1\x2\x4"+
				"\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA233_eot = DFA.UnpackEncodedString(DFA233_eotS);
		private static readonly short[] DFA233_eof = DFA.UnpackEncodedString(DFA233_eofS);
		private static readonly char[] DFA233_min = DFA.UnpackEncodedStringToUnsignedChars(DFA233_minS);
		private static readonly char[] DFA233_max = DFA.UnpackEncodedStringToUnsignedChars(DFA233_maxS);
		private static readonly short[] DFA233_accept = DFA.UnpackEncodedString(DFA233_acceptS);
		private static readonly short[] DFA233_special = DFA.UnpackEncodedString(DFA233_specialS);
		private static readonly short[][] DFA233_transition;

		static DFA233()
		{
			int numStates = DFA233_transitionS.Length;
			DFA233_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA233_transition[i] = DFA.UnpackEncodedString(DFA233_transitionS[i]);
			}
		}

		public DFA233( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 233;
			this.eot = DFA233_eot;
			this.eof = DFA233_eof;
			this.min = DFA233_min;
			this.max = DFA233_max;
			this.accept = DFA233_accept;
			this.special = DFA233_special;
			this.transition = DFA233_transition;
		}

		public override string Description { get { return "619:43: ( ( LT )* assignmentExpression )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA240 : DFA
	{
		private const string DFA240_eotS =
			"\x4\xFFFF";
		private const string DFA240_eofS =
			"\x4\xFFFF";
		private const string DFA240_minS =
			"\x2\x15\x2\xFFFF";
		private const string DFA240_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA240_acceptS =
			"\x2\xFFFF\x1\x1\x1\x2";
		private const string DFA240_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA240_transitionS =
			{
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x51\xFFFF\x1\x3",
				"\x1\x2\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2\x4\xFFFF\x1\x2\x51\xFFFF\x1\x3",
				"",
				""
			};

		private static readonly short[] DFA240_eot = DFA.UnpackEncodedString(DFA240_eotS);
		private static readonly short[] DFA240_eof = DFA.UnpackEncodedString(DFA240_eofS);
		private static readonly char[] DFA240_min = DFA.UnpackEncodedStringToUnsignedChars(DFA240_minS);
		private static readonly char[] DFA240_max = DFA.UnpackEncodedStringToUnsignedChars(DFA240_maxS);
		private static readonly short[] DFA240_accept = DFA.UnpackEncodedString(DFA240_acceptS);
		private static readonly short[] DFA240_special = DFA.UnpackEncodedString(DFA240_specialS);
		private static readonly short[][] DFA240_transition;

		static DFA240()
		{
			int numStates = DFA240_transitionS.Length;
			DFA240_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA240_transition[i] = DFA.UnpackEncodedString(DFA240_transitionS[i]);
			}
		}

		public DFA240( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 240;
			this.eot = DFA240_eot;
			this.eof = DFA240_eof;
			this.min = DFA240_min;
			this.max = DFA240_max;
			this.accept = DFA240_accept;
			this.special = DFA240_special;
			this.transition = DFA240_transition;
		}

		public override string Description { get { return "625:8: ( ( LT )* propertyNameAndValue ( ( LT )* ',' ( LT )* propertyNameAndValue )* )?"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA239 : DFA
	{
		private const string DFA239_eotS =
			"\x4\xFFFF";
		private const string DFA239_eofS =
			"\x4\xFFFF";
		private const string DFA239_minS =
			"\x2\x18\x2\xFFFF";
		private const string DFA239_maxS =
			"\x2\x72\x2\xFFFF";
		private const string DFA239_acceptS =
			"\x2\xFFFF\x1\x2\x1\x1";
		private const string DFA239_specialS =
			"\x4\xFFFF}>";
		private static readonly string[] DFA239_transitionS =
			{
				"\x1\x1\x1E\xFFFF\x1\x3\x3A\xFFFF\x1\x2",
				"\x1\x1\x1E\xFFFF\x1\x3\x3A\xFFFF\x1\x2",
				"",
				""
			};

		private static readonly short[] DFA239_eot = DFA.UnpackEncodedString(DFA239_eotS);
		private static readonly short[] DFA239_eof = DFA.UnpackEncodedString(DFA239_eofS);
		private static readonly char[] DFA239_min = DFA.UnpackEncodedStringToUnsignedChars(DFA239_minS);
		private static readonly char[] DFA239_max = DFA.UnpackEncodedStringToUnsignedChars(DFA239_maxS);
		private static readonly short[] DFA239_accept = DFA.UnpackEncodedString(DFA239_acceptS);
		private static readonly short[] DFA239_special = DFA.UnpackEncodedString(DFA239_specialS);
		private static readonly short[][] DFA239_transition;

		static DFA239()
		{
			int numStates = DFA239_transitionS.Length;
			DFA239_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA239_transition[i] = DFA.UnpackEncodedString(DFA239_transitionS[i]);
			}
		}

		public DFA239( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 239;
			this.eot = DFA239_eot;
			this.eof = DFA239_eof;
			this.min = DFA239_min;
			this.max = DFA239_max;
			this.accept = DFA239_accept;
			this.special = DFA239_special;
			this.transition = DFA239_transition;
		}

		public override string Description { get { return "()* loopback of 625:34: ( ( LT )* ',' ( LT )* propertyNameAndValue )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _LT_in_program129 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _sourceElements_in_program132 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _LT_in_program134 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_program137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _sourceElement_in_sourceElements162 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_sourceElements165 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _sourceElement_in_sourceElements168 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _functionDeclaration_in_sourceElement187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_sourceElement192 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _93_in_functionDeclaration205 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_functionDeclaration207 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_functionDeclaration210 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_functionDeclaration212 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _formalParameterList_in_functionDeclaration215 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_functionDeclaration217 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _functionBody_in_functionDeclaration220 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _93_in_functionExpression272 = new BitSet(new ulong[]{0x1000001200000UL});
		public static readonly BitSet _LT_in_functionExpression274 = new BitSet(new ulong[]{0x1000001200000UL});
		public static readonly BitSet _Identifier_in_functionExpression277 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_functionExpression280 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _formalParameterList_in_functionExpression283 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_functionExpression285 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _functionBody_in_functionExpression288 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_formalParameterList337 = new BitSet(new ulong[]{0x2000001200000UL});
		public static readonly BitSet _LT_in_formalParameterList340 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_formalParameterList343 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_formalParameterList346 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_formalParameterList349 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_formalParameterList351 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_formalParameterList354 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_formalParameterList360 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_formalParameterList363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_functionBody395 = new BitSet(new ulong[]{0x8331010109200000UL,0xC7FFE75A44000UL});
		public static readonly BitSet _LT_in_functionBody397 = new BitSet(new ulong[]{0x8331010109200000UL,0xC7FFE75A44000UL});
		public static readonly BitSet _sourceElements_in_functionBody400 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_functionBody403 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_functionBody406 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementBlock_in_statement432 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableStatement_in_statement437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyStatement_in_statement442 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_statement447 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_statement452 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _iterationStatement_in_statement457 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _continueStatement_in_statement462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _breakStatement_in_statement467 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _returnStatement_in_statement472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _withStatement_in_statement477 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_statement482 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switchStatement_in_statement487 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _throwStatement_in_statement492 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _tryStatement_in_statement497 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_statementBlock509 = new BitSet(new ulong[]{0x8331010109200000UL,0xC7FFE75A44000UL});
		public static readonly BitSet _LT_in_statementBlock511 = new BitSet(new ulong[]{0x8331010109200000UL,0xC7FFE75A44000UL});
		public static readonly BitSet _statementList_in_statementBlock514 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_statementBlock517 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_statementBlock520 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statement_in_statementList546 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_statementList549 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_statementList553 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _106_in_variableStatement567 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_variableStatement569 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationList_in_variableStatement572 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_variableStatement575 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_variableStatement579 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList608 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_variableDeclarationList611 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_variableDeclarationList614 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_variableDeclarationList616 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationList619 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _variableDeclarationNoIn_in_variableDeclarationListNoIn638 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_variableDeclarationListNoIn641 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_variableDeclarationListNoIn644 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_variableDeclarationListNoIn646 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_variableDeclarationListNoIn649 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _Identifier_in_variableDeclaration668 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _LT_in_variableDeclaration670 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _initialiser_in_variableDeclaration673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_variableDeclarationNoIn720 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _LT_in_variableDeclarationNoIn722 = new BitSet(new ulong[]{0x1000002UL,0x10UL});
		public static readonly BitSet _initialiserNoIn_in_variableDeclarationNoIn725 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_initialiser770 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_initialiser772 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_initialiser775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _68_in_initialiserNoIn794 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_initialiserNoIn796 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_initialiserNoIn799 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_emptyStatement815 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_expressionStatement836 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_expressionStatement839 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_expressionStatement843 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _94_in_ifStatement860 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_ifStatement862 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_ifStatement865 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_ifStatement867 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_ifStatement870 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_ifStatement872 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_ifStatement875 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_ifStatement877 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_ifStatement882 = new BitSet(new ulong[]{0x1000002UL,0x2000000UL});
		public static readonly BitSet _LT_in_ifStatement885 = new BitSet(new ulong[]{0x1000000UL,0x2000000UL});
		public static readonly BitSet _89_in_ifStatement888 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_ifStatement890 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_ifStatement895 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _doWhileStatement_in_iterationStatement931 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_iterationStatement936 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_iterationStatement941 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forInStatement_in_iterationStatement946 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _88_in_doWhileStatement958 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_doWhileStatement960 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_doWhileStatement963 = new BitSet(new ulong[]{0x1000000UL,0x100000000000UL});
		public static readonly BitSet _LT_in_doWhileStatement965 = new BitSet(new ulong[]{0x1000000UL,0x100000000000UL});
		public static readonly BitSet _108_in_doWhileStatement968 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_doWhileStatement970 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_doWhileStatement973 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_doWhileStatement975 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _49_in_doWhileStatement977 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_doWhileStatement980 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_doWhileStatement984 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _108_in_whileStatement1014 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_whileStatement1016 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_whileStatement1019 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_whileStatement1021 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_whileStatement1024 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_whileStatement1026 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_whileStatement1029 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_whileStatement1031 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_whileStatement1034 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_forStatement1064 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_forStatement1066 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_forStatement1069 = new BitSet(new ulong[]{0x8331010109200000UL,0x84EA624804000UL});
		public static readonly BitSet _LT_in_forStatement1072 = new BitSet(new ulong[]{0x331010109200000UL,0x84EA624804000UL});
		public static readonly BitSet _forStatementInitialiserPart_in_forStatement1075 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_forStatement1079 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _63_in_forStatement1082 = new BitSet(new ulong[]{0x8331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_forStatement1085 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_forStatement1090 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_forStatement1094 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _63_in_forStatement1097 = new BitSet(new ulong[]{0x333010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_forStatement1100 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_forStatement1105 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_forStatement1109 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_forStatement1112 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_forStatement1114 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_forStatement1117 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionNoIn_in_forStatementInitialiserPart1213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _106_in_forStatementInitialiserPart1218 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_forStatementInitialiserPart1220 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationListNoIn_in_forStatementInitialiserPart1223 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _92_in_forInStatement1251 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_forInStatement1253 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_forInStatement1256 = new BitSet(new ulong[]{0x1000109200000UL,0x44A624004000UL});
		public static readonly BitSet _LT_in_forInStatement1258 = new BitSet(new ulong[]{0x1000109200000UL,0x44A624004000UL});
		public static readonly BitSet _forInStatementInitialiserPart_in_forInStatement1261 = new BitSet(new ulong[]{0x1000000UL,0x80000000UL});
		public static readonly BitSet _LT_in_forInStatement1263 = new BitSet(new ulong[]{0x1000000UL,0x80000000UL});
		public static readonly BitSet _95_in_forInStatement1266 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_forInStatement1268 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_forInStatement1271 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_forInStatement1273 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_forInStatement1276 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_forInStatement1278 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_forInStatement1281 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_forInStatementInitialiserPart1323 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _106_in_forInStatementInitialiserPart1328 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_forInStatementInitialiserPart1330 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _variableDeclarationNoIn_in_forInStatementInitialiserPart1333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _85_in_continueStatement1348 = new BitSet(new ulong[]{0x8000000001200000UL});
		public static readonly BitSet _Identifier_in_continueStatement1350 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_continueStatement1354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_continueStatement1358 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _82_in_breakStatement1392 = new BitSet(new ulong[]{0x8000000001200000UL});
		public static readonly BitSet _Identifier_in_breakStatement1394 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_breakStatement1398 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_breakStatement1402 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _99_in_returnStatement1433 = new BitSet(new ulong[]{0x8331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_returnStatement1435 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_returnStatement1439 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_returnStatement1443 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _109_in_withStatement1470 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_withStatement1472 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_withStatement1475 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_withStatement1477 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_withStatement1480 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_withStatement1482 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_withStatement1485 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_withStatement1487 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_withStatement1490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_labelledStatement1519 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_labelledStatement1521 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_labelledStatement1524 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_labelledStatement1526 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_labelledStatement1529 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _100_in_switchStatement1570 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_switchStatement1572 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_switchStatement1575 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_switchStatement1577 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_switchStatement1580 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_switchStatement1582 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_switchStatement1585 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_switchStatement1587 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _caseBlock_in_switchStatement1590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_caseBlock1619 = new BitSet(new ulong[]{0x1000000UL,0x4000000480000UL});
		public static readonly BitSet _LT_in_caseBlock1623 = new BitSet(new ulong[]{0x1000000UL,0x80000UL});
		public static readonly BitSet _caseClause_in_caseBlock1627 = new BitSet(new ulong[]{0x1000000UL,0x4000000480000UL});
		public static readonly BitSet _LT_in_caseBlock1632 = new BitSet(new ulong[]{0x1000000UL,0x400000UL});
		public static readonly BitSet _defaultClause_in_caseBlock1636 = new BitSet(new ulong[]{0x1000000UL,0x4000000080000UL});
		public static readonly BitSet _LT_in_caseBlock1639 = new BitSet(new ulong[]{0x1000000UL,0x80000UL});
		public static readonly BitSet _caseClause_in_caseBlock1643 = new BitSet(new ulong[]{0x1000000UL,0x4000000080000UL});
		public static readonly BitSet _LT_in_caseBlock1649 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_caseBlock1653 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _83_in_caseClause1665 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_caseClause1667 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_caseClause1670 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_caseClause1672 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_caseClause1675 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_caseClause1677 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _statementList_in_caseClause1680 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _86_in_defaultClause1709 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_defaultClause1711 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_defaultClause1714 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_defaultClause1716 = new BitSet(new ulong[]{0x8331010109200002UL,0x87FFE75A44000UL});
		public static readonly BitSet _statementList_in_defaultClause1719 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _102_in_throwStatement1746 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_throwStatement1748 = new BitSet(new ulong[]{0x8000000001000000UL});
		public static readonly BitSet _LT_in_throwStatement1751 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _63_in_throwStatement1755 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _104_in_tryStatement1780 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_tryStatement1782 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _statementBlock_in_tryStatement1785 = new BitSet(new ulong[]{0x1000000UL,0x8100000UL});
		public static readonly BitSet _LT_in_tryStatement1787 = new BitSet(new ulong[]{0x1000000UL,0x8100000UL});
		public static readonly BitSet _finallyClause_in_tryStatement1791 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _catchClause_in_tryStatement1795 = new BitSet(new ulong[]{0x1000002UL,0x8000000UL});
		public static readonly BitSet _LT_in_tryStatement1798 = new BitSet(new ulong[]{0x1000000UL,0x8000000UL});
		public static readonly BitSet _finallyClause_in_tryStatement1801 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _84_in_catchClause1843 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_catchClause1845 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _48_in_catchClause1848 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_catchClause1850 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_catchClause1853 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_catchClause1855 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_catchClause1858 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_catchClause1860 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _statementBlock_in_catchClause1863 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _91_in_finallyClause1897 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _LT_in_finallyClause1899 = new BitSet(new ulong[]{0x1000000UL,0x400000000000UL});
		public static readonly BitSet _statementBlock_in_finallyClause1902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentExpression_in_expression1927 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_expression1930 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_expression1933 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_expression1935 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_expression1938 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn1957 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _LT_in_expressionNoIn1960 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_expressionNoIn1963 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_expressionNoIn1965 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_expressionNoIn1968 = new BitSet(new ulong[]{0x80000001000002UL});
		public static readonly BitSet _conditionalExpression_in_assignmentExpression1987 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_assignmentExpression1998 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _LT_in_assignmentExpression2000 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpression2005 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_assignmentExpression2007 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_assignmentExpression2012 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_assignmentExpressionNoIn2299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_assignmentExpressionNoIn2310 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _LT_in_assignmentExpressionNoIn2312 = new BitSet(new ulong[]{0x2448900001000000UL,0x1000000021414UL});
		public static readonly BitSet _assignmentOperator_in_assignmentExpressionNoIn2317 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_assignmentExpressionNoIn2319 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_assignmentExpressionNoIn2324 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callExpression_in_leftHandSideExpression2665 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _newExpression_in_leftHandSideExpression2670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_newExpression2682 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _97_in_newExpression2687 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _LT_in_newExpression2689 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _newExpression_in_newExpression2692 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _nonMemberExpression_in_memberExpression2729 = new BitSet(new ulong[]{0x800000001000002UL,0x4000UL});
		public static readonly BitSet _LT_in_memberExpression2758 = new BitSet(new ulong[]{0x800000001000000UL,0x4000UL});
		public static readonly BitSet _indexSuffix_in_memberExpression2792 = new BitSet(new ulong[]{0x800000001000002UL,0x4000UL});
		public static readonly BitSet _propertyReferenceSuffix_in_memberExpression2856 = new BitSet(new ulong[]{0x800000001000002UL,0x4000UL});
		public static readonly BitSet _primaryExpression_in_nonMemberExpression2928 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionExpression_in_nonMemberExpression2961 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _97_in_nonMemberExpression2993 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _LT_in_nonMemberExpression2995 = new BitSet(new ulong[]{0x1000109200000UL,0x40A624004000UL});
		public static readonly BitSet _memberExpression_in_nonMemberExpression2998 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_nonMemberExpression3001 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _arguments_in_nonMemberExpression3004 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _primaryCallExpression_in_callExpression3045 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _LT_in_callExpression3075 = new BitSet(new ulong[]{0x801000001000000UL,0x4000UL});
		public static readonly BitSet _arguments_in_callExpression3111 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _indexSuffix_in_callExpression3164 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _propertyReferenceSuffix_in_callExpression3214 = new BitSet(new ulong[]{0x801000001000002UL,0x4000UL});
		public static readonly BitSet _memberExpression_in_primaryCallExpression3276 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _LT_in_primaryCallExpression3278 = new BitSet(new ulong[]{0x1000001000000UL});
		public static readonly BitSet _arguments_in_primaryCallExpression3283 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_arguments3315 = new BitSet(new ulong[]{0x333010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_arguments3318 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_arguments3321 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_arguments3324 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_arguments3327 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_arguments3329 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_arguments3332 = new BitSet(new ulong[]{0x82000001000000UL});
		public static readonly BitSet _LT_in_arguments3338 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_arguments3341 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _78_in_indexSuffix3369 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_indexSuffix3371 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_indexSuffix3374 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
		public static readonly BitSet _LT_in_indexSuffix3376 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
		public static readonly BitSet _79_in_indexSuffix3379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _59_in_propertyReferenceSuffix3396 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _LT_in_propertyReferenceSuffix3398 = new BitSet(new ulong[]{0x1200000UL});
		public static readonly BitSet _Identifier_in_propertyReferenceSuffix3401 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpression_in_conditionalExpression3423 = new BitSet(new ulong[]{0x1000002UL,0x2000UL});
		public static readonly BitSet _LT_in_conditionalExpression3433 = new BitSet(new ulong[]{0x1000000UL,0x2000UL});
		public static readonly BitSet _77_in_conditionalExpression3436 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpression3438 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression3443 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_conditionalExpression3445 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_conditionalExpression3448 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpression3450 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_conditionalExpression3455 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_conditionalExpressionNoIn3505 = new BitSet(new ulong[]{0x1000002UL,0x2000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3515 = new BitSet(new ulong[]{0x1000000UL,0x2000UL});
		public static readonly BitSet _77_in_conditionalExpressionNoIn3518 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3520 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn3525 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3527 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_conditionalExpressionNoIn3530 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_conditionalExpressionNoIn3532 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpressionNoIn_in_conditionalExpressionNoIn3537 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalANDExpression_in_logicalORExpression3588 = new BitSet(new ulong[]{0x1000002UL,0x2000000000000UL});
		public static readonly BitSet _LT_in_logicalORExpression3599 = new BitSet(new ulong[]{0x1000000UL,0x2000000000000UL});
		public static readonly BitSet _113_in_logicalORExpression3602 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalORExpression3604 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalORExpression_in_logicalORExpression3607 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalORExpressionNoIn3655 = new BitSet(new ulong[]{0x1000002UL,0x2000000000000UL});
		public static readonly BitSet _LT_in_logicalORExpressionNoIn3665 = new BitSet(new ulong[]{0x1000000UL,0x2000000000000UL});
		public static readonly BitSet _113_in_logicalORExpressionNoIn3668 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalORExpressionNoIn3670 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalORExpressionNoIn_in_logicalORExpressionNoIn3673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseORExpression_in_logicalANDExpression3721 = new BitSet(new ulong[]{0x200001000002UL});
		public static readonly BitSet _LT_in_logicalANDExpression3732 = new BitSet(new ulong[]{0x200001000000UL});
		public static readonly BitSet _45_in_logicalANDExpression3735 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalANDExpression3737 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalANDExpression_in_logicalANDExpression3740 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_logicalANDExpressionNoIn3788 = new BitSet(new ulong[]{0x200001000002UL});
		public static readonly BitSet _LT_in_logicalANDExpressionNoIn3798 = new BitSet(new ulong[]{0x200001000000UL});
		public static readonly BitSet _45_in_logicalANDExpressionNoIn3801 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_logicalANDExpressionNoIn3803 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _logicalANDExpressionNoIn_in_logicalANDExpressionNoIn3806 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseORExpression3854 = new BitSet(new ulong[]{0x1000002UL,0x800000000000UL});
		public static readonly BitSet _LT_in_bitwiseORExpression3864 = new BitSet(new ulong[]{0x1000000UL,0x800000000000UL});
		public static readonly BitSet _111_in_bitwiseORExpression3867 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseORExpression3869 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseORExpression_in_bitwiseORExpression3872 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseORExpressionNoIn3920 = new BitSet(new ulong[]{0x1000002UL,0x800000000000UL});
		public static readonly BitSet _LT_in_bitwiseORExpressionNoIn3930 = new BitSet(new ulong[]{0x1000000UL,0x800000000000UL});
		public static readonly BitSet _111_in_bitwiseORExpressionNoIn3933 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseORExpressionNoIn3935 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseORExpressionNoIn_in_bitwiseORExpressionNoIn3938 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseXORExpression3986 = new BitSet(new ulong[]{0x1000002UL,0x10000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpression3997 = new BitSet(new ulong[]{0x1000000UL,0x10000UL});
		public static readonly BitSet _80_in_bitwiseXORExpression4000 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpression4002 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseXORExpression_in_bitwiseXORExpression4005 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseXORExpressionNoIn4053 = new BitSet(new ulong[]{0x1000002UL,0x10000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpressionNoIn4063 = new BitSet(new ulong[]{0x1000000UL,0x10000UL});
		public static readonly BitSet _80_in_bitwiseXORExpressionNoIn4066 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseXORExpressionNoIn4068 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseXORExpressionNoIn_in_bitwiseXORExpressionNoIn4071 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpression_in_bitwiseANDExpression4119 = new BitSet(new ulong[]{0x400001000002UL});
		public static readonly BitSet _LT_in_bitwiseANDExpression4130 = new BitSet(new ulong[]{0x400001000000UL});
		public static readonly BitSet _46_in_bitwiseANDExpression4133 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseANDExpression4135 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseANDExpression_in_bitwiseANDExpression4138 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _equalityExpressionNoIn_in_bitwiseANDExpressionNoIn4186 = new BitSet(new ulong[]{0x400001000002UL});
		public static readonly BitSet _LT_in_bitwiseANDExpressionNoIn4196 = new BitSet(new ulong[]{0x400001000000UL});
		public static readonly BitSet _46_in_bitwiseANDExpressionNoIn4199 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_bitwiseANDExpressionNoIn4201 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _bitwiseANDExpressionNoIn_in_bitwiseANDExpressionNoIn4204 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpression_in_equalityExpression4253 = new BitSet(new ulong[]{0x60001000002UL,0x60UL});
		public static readonly BitSet _LT_in_equalityExpression4264 = new BitSet(new ulong[]{0x60001000000UL,0x60UL});
		public static readonly BitSet _69_in_equalityExpression4270 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _41_in_equalityExpression4276 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _70_in_equalityExpression4282 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _42_in_equalityExpression4288 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_equalityExpression4291 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _equalityExpression_in_equalityExpression4296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relationalExpressionNoIn_in_equalityExpressionNoIn4483 = new BitSet(new ulong[]{0x60001000002UL,0x60UL});
		public static readonly BitSet _LT_in_equalityExpressionNoIn4498 = new BitSet(new ulong[]{0x60001000000UL,0x60UL});
		public static readonly BitSet _69_in_equalityExpressionNoIn4513 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _41_in_equalityExpressionNoIn4537 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _70_in_equalityExpressionNoIn4561 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _42_in_equalityExpressionNoIn4585 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_equalityExpressionNoIn4608 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _equalityExpressionNoIn_in_equalityExpressionNoIn4611 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shiftExpression_in_relationalExpression4646 = new BitSet(new ulong[]{0x1000002UL,0x180000189UL});
		public static readonly BitSet _LT_in_relationalExpression4657 = new BitSet(new ulong[]{0x1000000UL,0x180000189UL});
		public static readonly BitSet _64_in_relationalExpression4663 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _71_in_relationalExpression4669 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _67_in_relationalExpression4675 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _72_in_relationalExpression4681 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _96_in_relationalExpression4687 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _95_in_relationalExpression4693 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_relationalExpression4696 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _relationalExpression_in_relationalExpression4701 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shiftExpression_in_relationalExpressionNoIn4960 = new BitSet(new ulong[]{0x1000002UL,0x100000189UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn4976 = new BitSet(new ulong[]{0x1000000UL,0x100000189UL});
		public static readonly BitSet _64_in_relationalExpressionNoIn4991 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _71_in_relationalExpressionNoIn5019 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _67_in_relationalExpressionNoIn5046 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _72_in_relationalExpressionNoIn5073 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _96_in_relationalExpressionNoIn5100 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_relationalExpressionNoIn5124 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _relationalExpressionNoIn_in_relationalExpressionNoIn5127 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _additiveExpression_in_shiftExpression5167 = new BitSet(new ulong[]{0x1000002UL,0xA02UL});
		public static readonly BitSet _LT_in_shiftExpression5193 = new BitSet(new ulong[]{0x1000000UL,0xA02UL});
		public static readonly BitSet _65_in_shiftExpression5199 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _73_in_shiftExpression5205 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _75_in_shiftExpression5211 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_shiftExpression5214 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _shiftExpression_in_shiftExpression5219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _multiplicativeExpression_in_additiveExpression5390 = new BitSet(new ulong[]{0x110000001000002UL});
		public static readonly BitSet _LT_in_additiveExpression5399 = new BitSet(new ulong[]{0x110000001000000UL});
		public static readonly BitSet _52_in_additiveExpression5405 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _56_in_additiveExpression5411 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_additiveExpression5414 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _additiveExpression_in_additiveExpression5419 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _unaryExpression_in_multiplicativeExpression5532 = new BitSet(new ulong[]{0x1004080001000002UL});
		public static readonly BitSet _LT_in_multiplicativeExpression5543 = new BitSet(new ulong[]{0x1004080001000000UL});
		public static readonly BitSet _50_in_multiplicativeExpression5549 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _60_in_multiplicativeExpression5555 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _43_in_multiplicativeExpression5561 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_multiplicativeExpression5564 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _multiplicativeExpression_in_multiplicativeExpression5569 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _postfixExpression_in_unaryExpression5722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _87_in_unaryExpression5758 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _107_in_unaryExpression5764 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _105_in_unaryExpression5770 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _53_in_unaryExpression5776 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _57_in_unaryExpression5782 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _52_in_unaryExpression5788 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _56_in_unaryExpression5794 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _115_in_unaryExpression5800 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _40_in_unaryExpression5806 = new BitSet(new ulong[]{0x331010108200000UL,0x84AA624804000UL});
		public static readonly BitSet _unaryExpression_in_unaryExpression5824 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _leftHandSideExpression_in_postfixExpression6076 = new BitSet(new ulong[]{0x220000000000002UL});
		public static readonly BitSet _53_in_postfixExpression6086 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _57_in_postfixExpression6106 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _101_in_primaryExpression6144 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_primaryExpression6165 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _literal_in_primaryExpression6185 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _arrayLiteral_in_primaryExpression6199 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _objectLiteral_in_primaryExpression6212 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _48_in_primaryExpression6225 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_primaryExpression6227 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _expression_in_primaryExpression6230 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _LT_in_primaryExpression6232 = new BitSet(new ulong[]{0x2000001000000UL});
		public static readonly BitSet _49_in_primaryExpression6235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _78_in_arrayLiteral6252 = new BitSet(new ulong[]{0x3B1010109200000UL,0x84AA62480C000UL});
		public static readonly BitSet _LT_in_arrayLiteral6254 = new BitSet(new ulong[]{0x3B1010109200000UL,0x84AA62480C000UL});
		public static readonly BitSet _assignmentExpression_in_arrayLiteral6257 = new BitSet(new ulong[]{0x80000001000000UL,0x8000UL});
		public static readonly BitSet _LT_in_arrayLiteral6261 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_arrayLiteral6264 = new BitSet(new ulong[]{0x3B1010109200000UL,0x84AA62480C000UL});
		public static readonly BitSet _LT_in_arrayLiteral6267 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_arrayLiteral6270 = new BitSet(new ulong[]{0x80000001000000UL,0x8000UL});
		public static readonly BitSet _LT_in_arrayLiteral6276 = new BitSet(new ulong[]{0x1000000UL,0x8000UL});
		public static readonly BitSet _79_in_arrayLiteral6279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _110_in_objectLiteral6314 = new BitSet(new ulong[]{0x109200000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_objectLiteral6317 = new BitSet(new ulong[]{0x109200000UL});
		public static readonly BitSet _propertyNameAndValue_in_objectLiteral6320 = new BitSet(new ulong[]{0x80000001000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_objectLiteral6323 = new BitSet(new ulong[]{0x80000001000000UL});
		public static readonly BitSet _55_in_objectLiteral6326 = new BitSet(new ulong[]{0x109200000UL});
		public static readonly BitSet _LT_in_objectLiteral6328 = new BitSet(new ulong[]{0x109200000UL});
		public static readonly BitSet _propertyNameAndValue_in_objectLiteral6331 = new BitSet(new ulong[]{0x80000001000000UL,0x4000000000000UL});
		public static readonly BitSet _LT_in_objectLiteral6337 = new BitSet(new ulong[]{0x1000000UL,0x4000000000000UL});
		public static readonly BitSet _114_in_objectLiteral6340 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyName_in_propertyNameAndValue6368 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _LT_in_propertyNameAndValue6370 = new BitSet(new ulong[]{0x4000000001000000UL});
		public static readonly BitSet _62_in_propertyNameAndValue6373 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_propertyNameAndValue6375 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _assignmentExpression_in_propertyNameAndValue6378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _Identifier_in_propertyName6407 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_propertyName6422 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NumericLiteral_in_propertyName6437 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _98_in_literal6458 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _103_in_literal6474 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _90_in_literal6490 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _StringLiteral_in_literal6506 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NumericLiteral_in_literal6521 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _functionDeclaration_in_synpred5_JavaScript187 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred9_JavaScript274 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred19_JavaScript397 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _statementBlock_in_synpred22_JavaScript432 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expressionStatement_in_synpred25_JavaScript447 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _labelledStatement_in_synpred32_JavaScript482 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred35_JavaScript511 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred48_JavaScript670 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred50_JavaScript722 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred61_JavaScript885 = new BitSet(new ulong[]{0x1000000UL,0x2000000UL});
		public static readonly BitSet _89_in_synpred61_JavaScript888 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _LT_in_synpred61_JavaScript890 = new BitSet(new ulong[]{0x8331010109200000UL,0x87FFE75A44000UL});
		public static readonly BitSet _statement_in_synpred61_JavaScript895 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_synpred64_JavaScript941 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred119_JavaScript1677 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred122_JavaScript1716 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpression_in_synpred141_JavaScript1987 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalExpressionNoIn_in_synpred144_JavaScript2299 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _callExpression_in_synpred158_JavaScript2665 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _memberExpression_in_synpred159_JavaScript2682 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred163_JavaScript2758 = new BitSet(new ulong[]{0x800000001000000UL,0x4000UL});
		public static readonly BitSet _indexSuffix_in_synpred163_JavaScript2792 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyReferenceSuffix_in_synpred163_JavaScript2856 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred171_JavaScript3075 = new BitSet(new ulong[]{0x801000001000000UL,0x4000UL});
		public static readonly BitSet _arguments_in_synpred171_JavaScript3111 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _indexSuffix_in_synpred171_JavaScript3164 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _propertyReferenceSuffix_in_synpred171_JavaScript3214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred257_JavaScript5399 = new BitSet(new ulong[]{0x110000001000000UL});
		public static readonly BitSet _52_in_synpred257_JavaScript5405 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _56_in_synpred257_JavaScript5411 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _LT_in_synpred257_JavaScript5414 = new BitSet(new ulong[]{0x331010109200000UL,0x84AA624804000UL});
		public static readonly BitSet _additiveExpression_in_synpred257_JavaScript5419 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LT_in_synpred281_JavaScript6254 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace  Jacobsoft.Amd.Internals.AntlrGenerated 
